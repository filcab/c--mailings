<table style="width:79%;">
<colgroup>
<col width="27%" />
<col width="51%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">Title:</td>
<td align="left">A Unified Executors Proposal for C++</td>
</tr>
<tr class="even">
<td align="left">Authors:</td>
<td align="left">Jared Hoberock, jhoberock@nvidia.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Michael Garland, mgarland@nvidia.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Chris Kohlhoff, chris@kohlhoff.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Chris Mysen, mysen@google.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Carter Edwards, hcedwar@sandia.gov</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Gordon Brown, gordon@codeplay.com</td>
</tr>
<tr class="even">
<td align="left">Other Contributors:</td>
<td align="left">Hans Boehm, hboehm@google.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Thomas Heller, thom.heller@gmail.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Lee Howes, lwh@fb.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Bryce Lelbach, brycelelbach@gmail.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Hartmut Kaiser, hartmut.kaiser@gmail.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Bryce Lelbach, brycelelbach@gmail.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Gor Nishanov, gorn@microsoft.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Thomas Rodgers, rodgert@twrodgers.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">David Hollman, dshollm@sandia.gov</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Michael Wong, michael@codeplay.com</td>
</tr>
<tr class="even">
<td align="left">Document Number:</td>
<td align="left">P0443R1</td>
</tr>
<tr class="odd">
<td align="left">Date:</td>
<td align="left">2017-01-06</td>
</tr>
<tr class="even">
<td align="left">Audience:</td>
<td align="left">SG1 - Concurrency and Parallelism</td>
</tr>
<tr class="odd">
<td align="left">Reply-to:</td>
<td align="left">jhoberock@nvidia.com</td>
</tr>
</tbody>
</table>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>This paper describes a programming model for executors, which are modular components for creating execution. Executors decouple software from the disparate, non-uniform interfaces of execution resources and present a uniform interface for work creation. The model proposed by this paper represents what we believe is the functionality necessary to compose executors with existing standard control structures such as <code>std::async()</code> and parallel algorithms, as well as near-standards such as the functionality found in various technical specifications, including the Concurrency, Networking, and Parallelism TSes. We intend this proposal to be an extensible basis for future development of execution in C++ which necessarily entails functionality beyond the scope of this basic proposal.</p>
<p>In our programming model, executors introduce a uniform interface for creating execution that may not be common to the underlying execution resources actually responsible for the mechanics of implementing that execution. There are three major concepts involved in this interplay: execution resources, execution contexts, and executors.</p>
<p>An <strong>execution resource</strong> is an instance of a hardware and/or software facility capable of executing a callable function object. Different resources may offer a broad array of functionality and semantics, and may range from SIMD vector units accessible in a single thread to an entire runtime managing a large collection of threads. In practice, different resources may also exhibit different performance characteristics of interest to the performance-conscious programmer. For example, an implementation might expose different processor cores, with potentially non-uniform access to memory, as separate resources to enable programmers to reason about locality.</p>
<p>An <strong>execution context</strong> is a program object that represents a specific collection of execution resources.</p>
<p>An <strong>executor</strong> is an object associated with a specific execution context. It provides a mechanism for creating execution agents from a callable function object. The agents created are bound to the executor's context, and hence to one or more of the resources that context represents.</p>
<p>Executors themselves are the primary concern of our design.</p>
<h2 id="design-goals"><span class="header-section-number">1.1</span> Design goals</h2>
<p>The design outlined in this proposal is intended to achieve our goals for executors, which are objects for creating all kinds of execution in C++. Executors should be <em>composable</em>, <em>adaptable</em>, and <em>customizable</em>, which we believe reflects the needs of users, library implementors, and executor authors, respectively. Short code examples demonstrating how our design accomodates the needs of these different audiences may be found in the <a href="p0443r1.html#code-examples">Appendix</a>.</p>
<p>By <em>composable</em>, we mean that executors should cross software boundaries allowing disparate software components to interoperate using a commonly-understood protocol. By <em>adaptable</em>, we mean that executors specially-designed for a particular use case should be applicable in other use cases when it is possible. By <em>customizable</em>, we mean that requirements placed on executors should be broad enough to encompass user-defined executors, rather than limited to the set of concrete executors which may eventually become part of the C++ Standard Library. Only a design including well-defined interfaces with clear semantics will achieve these goals.</p>
<h2 id="customization-points"><span class="header-section-number">1.2</span> Customization Points</h2>
<p>In our design, these well-defined interfaces with clearly-expressed execution semantics are called executor <em>customization points</em> and are foundational to the mechanics of our design. Each executor customization point is a function which delineates a specific use case which we have identified as fundamental to the needs of the C++ Standard Library and other technical specifications for execution creation. For example, the customization point <code>execution::async_execute()</code> asynchronously creates a single execution agent to invoke a given function and returns a future corresponding to that function's eventual result. A C++ Standard Library function like <code>std::async()</code> may compose with a user-supplied executor by using calling <code>execute::async_execute()</code> in its implementation. As another example, the customization point <code>execution::sync_execute()</code> synchronously creates a single execution agent to invoke a given function and immediately returns that function's result. These semantics provide a natural fit for the composition of user-provided executors with <code>std::invoke()</code>.</p>
<p>Because we envision executors to be the workhorses of execution in generic code, it is critical that they be adaptable to a variety of use cases. For example, a generic function like <code>std::invoke()</code> should be interoperable with as many types of executor as possible, not just that set of executors which natively provide the synchronous, single-agent execution function <code>sync_execute()</code>. To generalize across use cases, we have designed executor customization points to adapt the behavior of an executor when its native behavior is not a precise match for the use case of interest. For example, <code>std::invoke()</code> may interoperate with an executor which natively provides the execution function <code>async_execute()</code> by calling the customization point <code>execution::sync_execute()</code>. This customization point will adapt the executor by calling its natively provided <code>async_execute()</code> execution function, and wait on the resulting future. In this way, generic code may uniformly compose with executors with minimal restriction.</p>
<p>These adaptations performed by executor customization points are always performed in such a way as to ensure that various semantic guarantees provided by executors are never weakened. For example, if an executor guarantees that its possibly-blocking execution functions are always non-blocking, then an adapted implementation of <code>execution::async_execute</code> will always be non-blocking when that executor is composed with this customization point.</p>
<p>Our design focuses on defining a set of optional execution functions instead of imposing a set of strict executor requirements to maximize the latitude of executor authors. Rather than prematurely attempt to circumscribe the universe of all possible executors with a set of universal requirements, we believe it is more flexible to identify a set of use cases for work creation which can grow in the future. Executor authors may choose to natively support one or more of these use cases by implementing the appropriate execution function, and may opt in to natively supporting new use cases as they are introduced. Due to their adaptability, an executor will be future-proof to new customization points.</p>
<p>The following diagram shows the automatic adaptations performed by the customization points, assuming a corresponding native implementation (member or free function) is unavailable. A dotted line shows an adaptation that will be used only if <code>executor_execute_blocking_category_t&lt;Executor&gt;</code> is <code>non_blocking_execution_tag</code>.</p>
<p><img style="width:80%;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLEAAAFbCAYAAAAqWBwXAAAAAXNSR0IArs4c6QAAQABJREFUeAHsnQncFdMbx5/2fRVSaJOKKEWokOy7Ivu+RmSPpKRsyb4vRdbKUn8kIUmIQmgjVEo72vdt/ud3/v8z5t537r0z973LzNzf+Xze985y5izfOTPznOc85zklLMt6UxhIgARIgARIgARIgARIgARIgARIgARIgARIILgElpdQSiwruOVjyUiABEiABEiABEiABEiABEiABEiABEiABEhAFpYkBBIgARIgARIgARIgARIgARIgARIgARIgARIIOgEqsYJ+h1g+EiABEiABEiABEiABEiABEiABEiABEiABoRKLjYAESIAESIAESIAESIAESIAESIAESIAESCDwBEoHvoQsIAl4IDBv3jxp2rSpbNy40UNsRskUgYoVK8rs2bOldu3amUqS6ZAACZAACZBA1gksXLhQGjduLBs2bMh6XswgugQqVaokf/zxh9SqVSu6lWTNSCBNAkcccYSMGzcuzat5GQn8j8CQIUPkwgsvjMFBJVYMDu6ElcDy5cu1Auvxxx+nQiVHN3H+/Ply8803y8qVK8k8R8yZDQmQAAmQQGYIrFixQiuwHnnkEalbt25mEmUqBUVg7ty5cuutt8qqVauoxCqoO8/KeiWwaNEiOeOMM+T000/3egnjkUAMgWuvvVYWL14ccww7VGIVQcIDYSZw/PHHS6NGjcJchdCUfdq0aaEpKwtKAiRAAiRAAm4Ejj32WG3J7XaOx0ggGYEffvhBK7GSxeE5Eih0As2bN5cuXboUOgbWP00CPXv2dL2SPrFcsfAgCZAACZAACZAACZAACZAACZAACZAACZBAkAhQiRWku8GykAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJuBKgEssVCw+SAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAkEiQCVWEG6GywLCZAACZAACZAACZAACZAACZAACZAACZCAKwEqsVyx8CAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkECQCFCJFaS7wbKQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAm4EqASyxULD5IACZAACZAACZAACZAACZAACZAACZAACQSJAJVYQbobLAsJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkIArASqxXLHwIAmQ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J2DaUsirweKTQMYJ4Nno06eP/st44kywYAi4vWNLWCoUDAFWNJIE1q5dK7///rsMHz5c5s+fL0uWLJGFCxfK4sWLZfXq1Xad8QBs27ZNypUrJ0888YRUr17dPpevjZUrV8pVV10lJUuWlOeee04qV66cr6LE5As+X3zxhT5mXhxgZ0LFihVlxx13lN13313at28vDRs2tP9wDPVhIAESIAESIIGgEoD4O3r0aFm/fn3SIuLbd//998vUqVMlHZH54osvluOOOy5pHkE8GVT5xC+rzZs3S69evWTevHm+Li1RooTsueee0qVLF9l3330TXgu5LYz3N2GFeIIEMkjgxx9/lN9++y2DKUY7qaeeeko+//xzueSSS+TYY4+NdmU91g7v4iOOOEJq1KjhvGIhlVhOHNwODYEJEyZIjx499Itx+fLldrnLli0r27dvl61bt9rH4jcGDRokl156afzhvOz37t1bC8fIvF+/ftKzZ8+8lCM+UwivTZo0kb///lvzjD+fbL9Tp04yYsSIZFF4jgRIgARIgARCRWDVqlUyZswYee+992TUqFF6kKxMmTKyZcsW13pgMOeKK66QZ555xvV80A8GVT5JhxsGN1u3bi3Lli1zlQ/NfcQgJzqOnTt3lhNPPFFq1qyZTna8hgRIgAR8E0D/dYcddhD0wSpVqqQNNGrXru07nQK5gEqsArnRkavm999/L3feeadAww+rKwQIjJjahlE3t4Bzhx56qHz66adup3N+bMOGDYKXk7EWq1Wrlq4LFHFBCBDW3UYXoRGHwGc4Q+jba6+9ZP/999ejlcccc4w0btw4CFVgGUiABEiABEgg4wTQ2fj666/l/fffl0cffVQ2bdqkZRAcR4C8cdhhh8lHH30kxpo544XIYoJBl0/SqfrMmTPlwAMP1JZ35j6ZdPbZZx+599575cgjj5Ty5cubw/wlARIggZwR+Oqrr/TsFmSIb8jpp58uQ4cOzVn+IctoIef8hOyOsbj/I4ARNYyELliwQDCdcPLkyQILq2uuuUY6duzoOp0NipeXXnopMAiHDBmiy24K9M8//8gbb7xhdvP+i9FImLPiReoMmE4BQe+dd97RlnAQdqdMmSLPP/+85k8FlpMWt0mABEiABKJGAEqQOXPmaKssKLAQjGIE30xMsYdFchgVWKhL0OUTlNFvwGAblI4YiDMBciEG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lpMESIAESIAESIAESIAESIAESIAESCDSBKjESn57qcRKzodnSYAESIAESIAESIAESIAESIAESIAESCAnBBYvXiyVK1fWfznJMGSZUIkVshvG4pIACZAACZAACZAACZAACZAACZAACUSTAJRYu+yySzQrl4Falc5AGkyCBEiABEiABEiABEiABEiABEJNYNu2bWL+tm7dam/j2A477CClSpUKdf1YeBIggXAQoBIr+X0KhRILH4yhQ4fqv+TVKdyz559/ft4rbz7s7dq1y3tZWIDCIGDaXBBqi7IMHz5c3nzzzSAUJ7BlqFSpUmDLxoIlJ4A2/uKLL+q/5DF5NugETj/99MAUEe1q2bJlUqJEicCUiQUhgTAQCJIMZHihTOeee67+M8f4G20CQWyHUSAOn1h06p74TpawVEh8OhhnZs+eLVOmTMlbYbZv3y49evSQ+fPny6233iqtW7fOW1kSZdymTRupV69eotM5O/7xxx/LqlWrspbf0qVLBX///POP/sPyo3/99Zf+w/bGjRvtvCEQ48WK0TM088svv1yOOuoo+3wQNlauXClXXXWVlCxZUp577rlAzntesGCB3HLLLZpj6dKlNUswdQZwrlq1qlSvXl2PVNasWVNvY//AAw+UKlWqOKNnZBt5HHHEERlJKxOJzJ07V7777rtMJJXxNLZs2SIXXnih4F324IMPyq677prxPLwmWLduXWnbtq3X6IwXIAK//fab/PjjjwEqUfGLAqXz22+/LYcddph069at+AmGJAXIMQ0bNgxEaVevXi2ffPKJfj8FokCqEJs2bZIxY8bIl19+KfPmzfNVLHwn+/fvL40aNfJ1XdAih0E+8cts/fr10rNnT4GFg5/QuHFjOeSQQ+TQQw+VihUr+rk0a3EhNx577LEStIEhPDN++WYNUh4S/uabb+Thhx+WBg0ayP333x955XyZMmXkhBNOEPwyZJYAZGX07x999NHMJhyN1BaGwhILgkA+hYFnnnlG/vzzT60QgQKlS5cu0bj9WajF0UcfnYVU/5ckNNJ+5gZDcQVTcAiUhx9+uDz//PNZK1u6Cffu3Vt/4FBW1A/CVRBDuXLldAcPPN0ClForVqzQf1DmmABFIhSHQRr1N2XL9C8EFvwFMUC5jHsHZSM67RMnToy8YBXE+xD2MqEjh7+ohJkzZ8rIkSN1daZPn67fU7QG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N2/OZZZZywtKrK1bt2pFVtYyYcKhITB58mT5+++/Bf6sGdIjQCWWCzcosYI0lRAv8P79++u54/R35XLDeIgEQkDgnnvu0U6l77///kAJZWZ6lZluFQKULCIJ+CYASyzT1n1fHIALIOz27t1byyYjR44MQIlYBBIgARLILoERI0bowYe+ffvKP//8k93Mspy6sQKmc/csgw5J8phKiCn/WCmYIU0CamWtmDBx4kRLmdxbKjn+FQgD5Yw6pg1kcmfBggVWhQoV2JYKpC1l672hfCZYf/31VyabZkxa9957L9so26hrG3jkkUdi2komdxo1auSaZ7aeI6ZLuSaTbUA5pLWmTp2ayUfCTmvQoEF8NvhOZhv4fxtQU/0ttWiD/XxkeuOAAw4gaz5vkW8D5cuXt9SCJ5l+fNJKr3Xr1tZVV12V1rW8SBNYUMQnFqa7wHxz6NChnLOrpL2gBHW7JBv+arAyAlYzylZYsWKFYPqD6ghK3bp1s5UN040wAYxa3XrrrbJq1SqpVatWVmq6cOFCbel41113ZSV9Z6LZepadeXA7MwR69uyZ1WmWaHfdunXTqzRlpsRMJcoEguRLBas9XnLJJaIGF7KCHNOb69SpI48++mhW0meiJBAmAldffXVWv0V43rA4zQknnBBILEF69wUSEAuVksCSJUuke/fusnz58ry7DFq8eLFMmTJFYGHIkD6BIkosk9Tpp58upUsnPG2i8TfkBFavXp1VJZbBc+yxx4qy+DK7/CUBzwR++OEHrcTyfEGaEXfccUfp0qVLmlfzsigSyPb0bQxMtGnThu0uio0n4nVCRyDbAYvr8J2cbcpMPwwEbr755qwXs2XLlnzesk6ZGeSLAFwKBCXAJUDFihXlyCOPDEqRQlkO+sQK5W1joUmABEiABEiABEiABEiABEiABEiABMJCAL7e4NBdTW8MS5EDWU4qsQJ5W1goEiABEiABEiABEiABEiABEiABEiCBKBDAAgWff/65nHbaaVGoTl7rQCVWXvEzcxIgARIgARIgARIgARIgARIgARIggSgTeO+997TPcVhiMRSPAJVYxePHq0mABEiABEiABEiABEiABEiABEiABEggIYF33nlHjj76aIHPR4biEaASq3j8eDUJkAAJkAAJkAAJkAAJkAAJkAAJkAAJuBJYuXKljB07llMJXen4P0glln9mvIIE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tGljo0aNso8++sg6duxovXr1StnQKk8ilBoCySEg21ddunSx1atXewFWu3btkpM5cpIXAgix8oKRSCAAAQhAAAIQgAAEIACBciKgl+NHH33Upk2bZtLS2muvvUw2tD788MNywkBZIZAYAq+88or9/ve/ty233NImT55sm266aWLyRkbyRwAhVv5YEhMEIAABCEAAAhCAAAQgUGYEdtttN29zZ/z48TZ//nzbaaed7IwzzjAtacJBAAJ1Q0AC5R49elj37t1twoQJ1qpVq7pJmFTqnABCrDpHToIQgAAEIAABCEAAAhCAQKkR0Av09OnT7b777vMv0VtvvbUNHjzYtEMaDgIQKAyBIAjs8ssvtz59+thZZ51lo0ePtmbNmhUmMWJNBAF2J0xENZAJCEAAAhCAAAQgAAEIQKBUCKxcudJuvfVWGzp0qDVo0MAuvfRS69evnzVt2rRUikg5IFDvBJYvX24nnniiPfvss3bbbbd5Dch6zxQZKDSBhQixCo2Y+CEAAQhAAAIQgAAEIACBsiTw3Xff2bBhw+yWW26xjTbayK699lo77rjjvGCrLIFQaAjkicDcuXO9DbrFixf7HUJlCwtXFgQWspywLOqZQkIAAhCAAAQgAAEIQAACdU2gZcuWdv3119ucOXNs77339lojnTp18ja06jovpAeBUiEgzSv1o0aNGtnbb7/tjbmXStkoR24CCLFyM8IHBCAAAQhAAAIQgAAEIACBGhPQLmmylTVr1iyvkSXj07KhNXPmzBrHSUAIlBuBVatWeTtzPXv2NP1NmTLFNt9883LDUPblRYhV9k0AABCAAAQgAAEIQAACEIBAXRDYYYcd7JlnnrFXXnnFtNSwY8eOXjtr3rx5dZE8aUCgaAlo2WC3bt1s5MiRds8999j9999va665ZtGWh4zXnABCrJqzIyQEIAABCEAAAhCAAAQgAIHYBLS08M033/Q7qU2dOtW23XZb+8tf/mJLly6NHRcBIFDqBLR8cOedd7YFCxaY+stpp51W6kWmfNUQQIhVDRxuQQACEIAABCAAAQhAAAIQKBSBo48+2j788EMbMWKEPfzww9auXTu77rrrbMWKFYVKknghUDQE1A/OPvtsO/TQQ/3y2+nTp3thVtEUgIwWhAC7ExYEK5FCAAIQgAAEIAABCEAAAhCITmD58uU2fPhwL9CSQfirr77a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BAL1TIDlhPVcASQPAQhAAAIQgAAEIAABCJQXAQluBgwY4AU0++23n22yySZ2xRVXZEC44YYbvHDrp59+yrh+7LHH2mGHHZZxraYnEigdfPDBtuOOO9qsWbNiRfOPf/zD508COAnWXn/99dS5rh166KEV4pMfCba6detmXbt29UKsUNASev7111+tf//+1qpVK5MNr5122skLcl566aXQiynfSuOBBx7wNr622247O/DAA61du3YmbjV177zzjo9D8SmPG2ywgZ122mmWXgcSEEm4JW7pyyMfe+wxL3C89dZbU8lHKUvoWX6HDBnihXIq89577+3zMnjw4NCLL5vKnZ4f3cxuE7vvvrvnM3DgQB/2mGOOyaib8ePHp+KMk8dUIA4gUI8EEGLVI3yShgAEIAABCEAAAhCAAATKj8Dtt99uTz31lP3rX//yWj89e/a0q6++2qZNm1ZnMKSB9cc//tFrRT3xxBPV2rSqLFMyEP/uu+/6v0033dT22GOP1LmuP/nkkxWCHXXUUdavXz8v9Lruuuvso48+suHDh2f4u+iii+yuu+6y0aNHm/IojStpVx1xxBEV7HldcsklPg5xmzp1qhd4XXbZZSkNsYyIc5xI80qCI2l9yXbY8uXL7d5777X777/frrzyylToPffc09fV5MmT7cYbb/TXpZGmcu22226pa7oRpywSal566aV2/PHHm5ZnSntKwibZOYvrJk2a5OtCQjG5hx56KKNuunfvnooyTh5TgTiAQH0ScOqSOAhAAAIQgAAEIAABCEAAAhCIScAJngKnGRM5lFtyF7h3v8AJZQKngZQK5wQW/vq5556buuaMtftrTpiSuqYDJywKdt5554xr4clf//pXH8YJkcJLGb9OQBPsu+++gRMOBT169AjWWGON4LnnnsvwU5MTpwHl46sqbFiWUaNGpbw4LabALXHz+QkvionTUgucQCe85H8/+OADXy4n+PLnIUexd0suU35Hjhzp/b3yyiupa1EPzjvvPM/j66+/zghy9NFHB2uttVbgluelrivvBxxwgM/re++9Fxx55JGBM7AfuOWEKT9Ry6IATpgXNGzYMOjdu3cqfGUHIceobeLBBx/0PN54443KovNtMArvSgNXcnHzzTcPnFCykjtcgkDeCCzAJlZ9ShBJGwIQgAAEIAABCEAAAhAoOwJOMOKXqoUFl+0j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"></p>
<h2 id="executor-type-traits"><span class="header-section-number">1.3</span> Executor type traits</h2>
<p>In order to help programmers define their own ad hoc requirements for executor types, our design provides a set of executor type traits for introspecting the properties of executors at compile time. These fine-grained type traits detect characteristics such as native support for execution functions as well as compatibility between an executor type and an executor customization point.</p>
<p>For example, for an execution function such as <code>execute</code>, the executor supports the following traits:</p>
<ul>
<li><code>has_execute_member&lt;X&gt;</code> and <code>has_execute_member_v&lt;X&gt;</code>, to detect the presence of a member named <code>execute</code> that satisfies the corresponding syntactic requirements.</li>
<li><code>has_execute_free_function&lt;X&gt;</code> and <code>has_execute_free_function_v&lt;X&gt;</code>, to detect the presence of a free function named <code>execute</code>, accepting the executor as the initial parameter, and that satisfies the corresponding syntactic requirements.</li>
<li><code>can_execute&lt;X&gt;</code> and <code>can_execute_v&lt;X&gt;</code>, to determine whether the corresponding customization point is well-formed for the executor.</li>
</ul>
<p>Programmers may employ these type traits at software boundaries to define requirements for executor composition as well as reject types of executors which are known to be incompatible.</p>
<p>These traits may also be used to determine which implementation strategy will be used by a customization point. That is, whether the customization support can use native support (via member or free function) or an adaptation. If a particular customization point's adaptation is inefficient when implementing some higher level algorithm, the trait may be used to select an alternative algorithm implementation not based on that customization point.</p>
<p>While these traits are not strictly required by this proposal -- we may employ SFINAE to detect the presence of members or free functions -- correctly detecting adherence to the syntactic requirements is complex. Therefore these traits are included to simplify feature detection for programmers, as well as reducing the verbosity of this proposal's wording.</p>
<h2 id="executor-categories"><span class="header-section-number">1.4</span> Executor Categories</h2>
<p>Our design organizes executors into <em>executor categories</em> based on how they are expected to be used by software components composing with them. These categories correspond to the application domains served by the C++ Standard Library and the Parallelism, Concurrency, and Networking Technical Specifications. The requirements for membership in an executor category include basic requirements on executor types as well as requirements based on their compatibility with customization points. For example, the executor category <code>TwoWayExecutor</code> includes all executors compatible with the two-way, single-agent executor customization points such as <code>execution::async_execute()</code>. Executor categories are not necessarily mutually exclusive, and one executor type may be a member of multiple categories if the requirements for those categories admit mutual membership.</p>
<p>This proposal defines four named categories: <code>OneWayExecutor</code>, <code>TwoWayExecutor</code>, <code>BulkTwoWayExecutor</code>, and <code>NonblockingOneWayExecutor</code>. <code>OneWayExecutor</code> and <code>TwoWayExecutor</code> summarize the requirements for basic executors which create single-agent execution with minimal guarantees. <code>OneWayExecutor</code>s do not provide a channel for synchronizing with the completion of execution, while <code>TwoWayExecutor</code>s do provide such a channel. <code>BulkTwoWayExecutor</code> summarizes requirements for executors which create bulk-agent execution and also provide a channel for synchronization. This category summarizes the requirements for executors which can compose with parallel algorithms. Finally, <code>NonblockingOneWayExecutor</code> extends <code>OneWayExecutor</code>'s requirements by demanding that an executor's execution functions do not block the calling thread of those operations. This additional requirement on blocking behavior is critical to the needs of the Networking TS.</p>
<p>We have not attempted to completely capture every kind of interesting collection of executors in our categorization. By design, our categorization of executors is incomplete to accommodate future extension. Moreover, we recognize that the particular categories we define may not precisely match the requirements of all existing software interfaces which need to compose with executors. For example, the regularity of our design suggests the existence of a hypothetical executor category named <code>NonblockingHostBasedBulkTwoWayExecutor</code>. Such a category would correspond to executor types which create bulk, two-way execution hosted on a thread, and would create execution in a way that is guaranteed not to block the calling thread. However, our proposal does not define such a category. Instead, this category could be created by composing the executor type traits described above.</p>
<h2 id="execution-contexts"><span class="header-section-number">1.5</span> Execution Contexts</h2>
<p>In our design, <em>execution contexts</em> are objects that represent a specific collection of resources and may be used by executor to create execution. For example, a thread pool is an execution context which manages a collection of threads upon which an associated executor may create execution agents. For our purposes of defining a programming model for executors, the only salient expectation for execution contexts is the ability to obtain an executor from them. However, we have chosen not to prescribe a required interface for doing so. Instead, we have defined very basic requirements for execution contexts which allow almost any type of object to be an execution context. Our requirements for execution contexts are deliberately minimal and intended to provide a standard protocol for obtaining an executor's context and reason about its identity in generic code. Yet, these minimal requirements still allow for further refinement in future libraries. For example, we illustrate requirements for a <code>NetworkingExecutionContext</code> that we expect the Networking TS to define which would enumerate expectations on execution contexts compatible with networking use cases. This refinement's requirements significantly strengthen our weak requirements in part by demanding that all such contexts derive from a specific concrete class.</p>
<p>In order to evaluate this proposal, it will be useful to have at least one concrete execution context readily available. Our proposal specifies a single execution context, <code>static_thread_pool</code>, which abstracts a explicitly-sized collection of threads and implements an effectively unbounded work queue. This thread pool type provides functions for typical thread pool operations as well as an <code>.executor()</code> function for obtaining an executor associated with the thread pool. We recognize that different types of thread pools are suited to different use cases and emphasize that this proposal's <code>static_thread_pool</code> represents a single design in this space which is not intended as definitive.</p>
<h2 id="extensibility"><span class="header-section-number">1.6</span> Extensibility</h2>
<p>This proposal is intended to provide a foundation for future enhancements to executors and execution in general in C++. Naturally, it is incomplete and we anticipate extension. Here, we discuss briefly our vision for how the major components of our overall design can be extended by future follow-on proposals.</p>
<p><strong><code>Future</code> concept.</strong> One immediate concern is the conceptualization of <code>std::future</code>-like types. We anticipate that some types of executors will expose idiosyncratic, custom, and non-standard future types to represent asynchronous tasks due to requirements of underlying execution resources. An elaboration of the requirements of a hypothetical <code>Future</code> concept is needed.</p>
<p><strong>Execution resources.</strong> Our proposal is silent about how a program might enumerate and represent the available execution resources present in the system. A future proposal describing a means of representing system resources with standard execution contexts and obtaining executors from them would provide programmers concerned with performance the tools to reason about locality.</p>
<p><strong>Execution contexts.</strong> This paper proposes a single concrete execution context, <code>static_thread_pool</code>, which embodies one approach for representing a thread pool. There are other approaches to thread pools with different features and limitations which others could propose. For example, a hypothetical <code>dynamic_thread_pool</code> type could automatically change its thread count to adapt to the state of the system, with the goal of guaranteeing concurrent execution. Another possible execution context could emulate the existing behavior of <code>std::async()</code> to aid in migration from the standard library's existing features for concurrency and parallelism to this new model of executors. Such a context would allow programmers to introduce executors without breaking any assumed semantics of <code>std::async()</code>, such as concurrent execution agents, thread-per-request, and future blocking behavior.</p>
<p>Besides introducing concrete execution context types, future proposals could refine our <code>ExecutionContext</code> concept by introducing concepts with additional requirements. As an example, a parallel execution framework might define requirements for a hypothetical <code>IntrospectableExecutionContext</code> which would require contexts to provide functionality for resource introspection. Generic code could depend on such functionality to query the number of hardware threads associated with execution context. These and other extensions to our basic model of execution contexts may be explored as future proposals.</p>
<p><strong>Executor categories.</strong> Future proposals might expand our executor categorization to additional application domains if the categorizations proposed here are insufficient for representing their requirements. For example, our proposal does not directly address issues related to heterogeneous execution resources. These issues can be addressed in the future with new kinds of executors incorporated into the overall framework with the appropriate categorization.</p>
<h2 id="changelog"><span class="header-section-number">1.7</span> Changelog</h2>
<h3 id="changes-since-r0"><span class="header-section-number">1.7.1</span> Changes since R0</h3>
<ul>
<li>Executor category simplification</li>
<li>Specified executor customization points in detail</li>
<li>Introduced new fine-grained executor type traits
<ul>
<li>Detectors for execution functions</li>
<li>Traits for introspecting cross-cutting concerns
<ul>
<li>Introspection of mapping of agents to threads</li>
<li>Introspection of execution function blocking behavior</li>
</ul></li>
</ul></li>
<li>Allocator support for single agent execution functions</li>
<li>Renamed <code>thread_pool</code> to <code>static_thread_pool</code></li>
<li>New introduction</li>
</ul>
<h1 id="proposed-wording"><span class="header-section-number">2</span> Proposed Wording</h1>
<h3 id="header-execution-synopsis"><span class="header-section-number">2.0.1</span> Header <code>&lt;execution&gt;</code> synopsis</h3>
<pre><code>namespace std {
namespace experimental {
inline namespace concurrency_v2 {
namespace execution {

  // Member detection type traits:

  template&lt;class T&gt; struct has_execute_member;
  template&lt;class T&gt; struct has_post_member;
  template&lt;class T&gt; struct has_defer_member;
  template&lt;class T&gt; struct has_sync_execute_member;
  template&lt;class T&gt; struct has_async_execute_member;
  template&lt;class T&gt; struct has_async_post_member;
  template&lt;class T&gt; struct has_async_defer_member;
  template&lt;class T&gt; struct has_then_execute_member;
  template&lt;class T&gt; struct has_bulk_execute_member;
  template&lt;class T&gt; struct has_bulk_post_member;
  template&lt;class T&gt; struct has_bulk_defer_member;
  template&lt;class T&gt; struct has_bulk_sync_execute_member;
  template&lt;class T&gt; struct has_bulk_async_execute_member;
  template&lt;class T&gt; struct has_bulk_async_post_member;
  template&lt;class T&gt; struct has_bulk_async_defer_member;
  template&lt;class T&gt; struct has_bulk_then_execute_member;

  template&lt;class T&gt; constexpr bool has_execute_member_v = has_execute_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_post_member_v = has_post_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_defer_member_v = has_defer_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_sync_execute_member_v = has_sync_execute_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_async_execute_member_v = has_async_execute_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_async_post_member_v = has_async_post_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_async_defer_member_v = has_async_defer_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_then_execute_member_v = has_then_execute_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_execute_member_v = has_bulk_execute_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_post_member_v = has_bulk_post_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_defer_member_v = has_bulk_defer_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_sync_execute_member_v = has_bulk_sync_execute_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_async_execute_member_v = has_bulk_async_execute_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_async_post_member_v = has_bulk_async_post_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_async_defer_member_v = has_bulk_async_defer_member&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_then_execute_member_v = has_bulk_then_execute_member&lt;T&gt;::value;

  // Free function detection type traits:

  template&lt;class T&gt; struct has_execute_free_function;
  template&lt;class T&gt; struct has_post_free_function;
  template&lt;class T&gt; struct has_defer_free_function;
  template&lt;class T&gt; struct has_sync_execute_free_function;
  template&lt;class T&gt; struct has_async_execute_free_function;
  template&lt;class T&gt; struct has_async_post_free_function;
  template&lt;class T&gt; struct has_async_defer_free_function;
  template&lt;class T&gt; struct has_then_execute_free_function;
  template&lt;class T&gt; struct has_bulk_execute_free_function;
  template&lt;class T&gt; struct has_bulk_post_free_function;
  template&lt;class T&gt; struct has_bulk_defer_free_function;
  template&lt;class T&gt; struct has_bulk_sync_execute_free_function;
  template&lt;class T&gt; struct has_bulk_async_execute_free_function;
  template&lt;class T&gt; struct has_bulk_async_post_free_function;
  template&lt;class T&gt; struct has_bulk_async_defer_free_function;
  template&lt;class T&gt; struct has_bulk_then_execute_free_function;

  template&lt;class T&gt; constexpr bool has_execute_free_function_v = has_execute_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_post_free_function_v = has_post_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_defer_free_function_v = has_defer_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_sync_execute_free_function_v = has_sync_execute_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_async_execute_free_function_v = has_async_execute_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_async_post_free_function_v = has_async_post_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_async_defer_free_function_v = has_async_defer_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_then_execute_free_function_v = has_then_execute_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_execute_free_function_v = has_bulk_execute_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_post_free_function_v = has_bulk_post_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_defer_free_function_v = has_bulk_defer_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_sync_execute_free_function_v = has_bulk_sync_execute_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_async_execute_free_function_v = has_bulk_async_execute_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_async_post_free_function_v = has_bulk_async_post_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_async_defer_free_function_v = has_bulk_async_defer_free_function&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool has_bulk_then_execute_free_function_v = has_bulk_then_execute_free_function&lt;T&gt;::value;

  // Customization points:

  namespace {
    constexpr unspecified execute = unspecified;
    constexpr unspecified post = unspecified;
    constexpr unspecified defer = unspecified;
    constexpr unspecified sync_execute = unspecified;
    constexpr unspecified async_execute = unspecified;
    constexpr unspecified async_post = unspecified;
    constexpr unspecified async_defer = unspecified;
    constexpr unspecified then_execute = unspecified;
    constexpr unspecified bulk_execute = unspecified;
    constexpr unspecified bulk_post = unspecified;
    constexpr unspecified bulk_defer = unspecified;
    constexpr unspecified bulk_sync_execute = unspecified;
    constexpr unspecified bulk_async_execute = unspecified;
    constexpr unspecified bulk_async_post = unspecified;
    constexpr unspecified bulk_async_defer = unspecified;
    constexpr unspecified bulk_then_execute = unspecified;
  }

  // Customization point type traits:

  template&lt;class T&gt; struct can_execute;
  template&lt;class T&gt; struct can_post;
  template&lt;class T&gt; struct can_defer;
  template&lt;class T&gt; struct can_sync_execute;
  template&lt;class T&gt; struct can_async_execute;
  template&lt;class T&gt; struct can_async_post;
  template&lt;class T&gt; struct can_async_defer;
  template&lt;class T&gt; struct can_then_execute;
  template&lt;class T&gt; struct can_bulk_execute;
  template&lt;class T&gt; struct can_post_execute;
  template&lt;class T&gt; struct can_defer_execute;
  template&lt;class T&gt; struct can_bulk_sync_execute;
  template&lt;class T&gt; struct can_bulk_async_execute;
  template&lt;class T&gt; struct can_bulk_async_post;
  template&lt;class T&gt; struct can_bulk_async_defer;
  template&lt;class T&gt; struct can_bulk_then_execute;

  template&lt;class T&gt; constexpr bool can_execute_v = can_execute&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_post_v = can_post&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_defer_v = can_defer&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_sync_execute_v = can_sync_execute&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_async_execute_v = can_async_execute&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_async_post_v = can_async_post&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_async_defer_v = can_async_defer&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_then_execute_v = can_then_execute&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_execute_v = can_bulk_execute&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_post_v = can_bulk_post&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_defer_v = can_bulk_defer&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_sync_execute_v = can_bulk_sync_execute&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_async_execute_v = can_bulk_async_execute&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_async_post_v = can_bulk_async_post&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_async_defer_v = can_bulk_async_defer&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool can_bulk_then_execute_v = can_bulk_then_execute&lt;T&gt;::value;

  // Executor type traits:

  template&lt;class T&gt; struct is_one_way_executor;
  template&lt;class T&gt; struct is_non_blocking_one_way_executor;
  template&lt;class T&gt; struct is_two_way_executor;
  template&lt;class T&gt; struct is_bulk_two_way_executor;

  template&lt;class T&gt; constexpr bool is_one_way_executor_v = is_one_way_executor&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool is_non_blocking_one_way_executor_v = is_non_blocking_one_way_executor&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool is_two_way_executor_v = is_two_way_executor&lt;T&gt;::value;
  template&lt;class T&gt; constexpr bool is_bulk_two_way_executor_v = is_bulk_two_way_executor&lt;T&gt;::value;

  template&lt;class Executor&gt; struct executor_context;

  template&lt;class Executor&gt;
    using executor_context_t = typename executor_context&lt;Executor&gt;::type;

  template&lt;class Executor, class T&gt; struct executor_future;

  template&lt;class Executor, class T&gt;
    using executor_future_t = typename executor_future&lt;Executor, T&gt;::type;

  struct other_execution_mapping_tag {};
  struct thread_execution_mapping_tag {};
  struct unique_thread_execution_mapping_tag {};

  template&lt;class Executor&gt; struct executor_execution_mapping_category;

  template&lt;class Executor&gt;
    using executor_execution_mapping_category_t = typename executor_execution_mapping_catetory&lt;Executor&gt;::type;

  struct blocking_execution_tag {};
  struct possibly_blocking_execution_tag {};
  struct non_blocking_execution_tag {};

  template&lt;class Executor&gt; struct executor_execute_blocking_category;

  template&lt;class Executor&gt;
    using executor_execute_blocking_category_t = typename executor_execute_blocking_category&lt;Executor&gt;::type;

  // Bulk executor traits:

  struct sequenced_execution_tag {};
  struct parallel_execution_tag {};
  struct unsequenced_execution_tag {};

  template&lt;class Executor&gt; struct executor_execution_category;

  template&lt;class Executor&gt;
    using executor_execution_category_t = typename executor_execution_category&lt;Executor&gt;::type;

  template&lt;class Executor&gt; struct executor_shape;

  template&lt;class Executor&gt;
    using executor_shape_t = typename executor_shape&lt;Executor&gt;::type;

  template&lt;class Executor&gt; struct executor_index;

  template&lt;class Executor&gt;
    using executor_index_t = typename executor_index&lt;Executor&gt;::type;

  // Executor work guard:

  template &lt;class Executor&gt;
    class executor_work_guard;

  // Polymorphic executor wrappers:

  class one_way_executor;
  class non_blocking_one_way_executor;
  class two_way_executor;

} // namespace execution
} // inline namespace concurrency_v2
} // namespace experimental
} // namespace std</code></pre>
<h2 id="requirements"><span class="header-section-number">2.1</span> Requirements</h2>
<h3 id="customization-point-objects"><span class="header-section-number">2.1.1</span> Customization point objects</h3>
<p><em>(The following text has been adapted from the draft Ranges Technical Specification.)</em></p>
<p>A <em>customization point object</em> is a function object (C++ Std, [function.objects]) with a literal class type that interacts with user-defined types while enforcing semantic requirements on that interaction.</p>
<p>The type of a customization point object shall satisfy the requirements of <code>CopyConstructible</code> (C++Std [copyconstructible]) and <code>Destructible</code> (C++Std [destructible]).</p>
<p>All instances of a specific customization point object type shall be equal.</p>
<p>Let <code>t</code> be a (possibly const) customization point object of type <code>T</code>, and <code>args...</code> be a parameter pack expansion of some parameter pack <code>Args...</code>. The customization point object <code>t</code> shall be callable as <code>t(args...)</code> when the types of <code>Args...</code> meet the requirements specified in that customization point object's definition. Otherwise, <code>T</code> shall not have a function call operator that participates in overload resolution.</p>
<p>Each customization point object type constrains its return type to satisfy some particular type requirements.</p>
<p>The library defines several named customization point objects. In every translation unit where such a name is defined, it shall refer to the same instance of the customization point object.</p>
<p>[<em>Note:</em> Many of the customization points objects in the library evaluate function call expressions with an unqualified name which results in a call to a user-defined function found by argument dependent name lookup (C++Std [basic.lookup.argdep]). To preclude such an expression resulting in a call to unconstrained functions with the same name in namespace <code>std</code>, customization point objects specify that lookup for these expressions is performed in a context that includes deleted overloads matching the signatures of overloads defined in namespace <code>std</code>. When the deleted overloads are viable, user-defined overloads must be more specialized (C++Std [temp.func.order]) to be used by a customization point object. <em>--end note</em>]</p>
<h3 id="future-requirements"><span class="header-section-number">2.1.2</span> <code>Future</code> requirements</h3>
<p>A type <code>F</code> meets the <code>Future</code> requirements for some value type <code>T</code> if <code>F</code> is <code>std::experimental::future&lt;T&gt;</code> (defined in the C++ Concurrency TS, ISO/IEC TS 19571:2016). [<em>Note:</em> This concept is included as a placeholder to be elaborated, with the expectation that the elaborated requirements for <code>Future</code> will expand the applicability of some executor customization points. <em>--end note</em>]</p>
<h3 id="protoallocator-requirements"><span class="header-section-number">2.1.3</span> <code>ProtoAllocator</code> requirements</h3>
<p>A type <code>A</code> meets the <code>ProtoAllocator</code> requirements if <code>A</code> is <code>CopyConstructible</code> (C++Std [copyconstructible]), <code>Destructible</code> (C++Std [destructible]), and <code>allocator_traits&lt;A&gt;::rebind_alloc&lt;U&gt;</code> meets the allocator requirements (C++Std [allocator.requirements]), where <code>U</code> is an object type. [<em>Note:</em> For example, <code>std::allocator&lt;void&gt;</code> meets the proto-allocator requirements but not the allocator requirements. <em>--end note</em>] No comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception.</p>
<h3 id="executioncontext-requirements"><span class="header-section-number">2.1.4</span> <code>ExecutionContext</code> requirements</h3>
<p>A type meets the <code>ExecutionContext</code> requirements if it satisfies the <code>EqualityComparable</code> requirements (C++Std [equalitycomparable]). No comparison operator on these types shall exit via an exception.</p>
<h3 id="requirements-on-execution-functions"><span class="header-section-number">2.1.5</span> Requirements on execution functions</h3>
<p>An execution function is a member function of the form:</p>
<pre><code>x.e(...)</code></pre>
<p>or a free function of the form:</p>
<pre><code>e(x, ...)</code></pre>
<p>where <code>x</code> denotes an executor object, <code>e</code> denotes the function name and <code>...</code> denotes the parameters.</p>
<p>Each execution function is made up from a combination of three properties: its <strong>blocking semantics</strong>, <strong>directionality</strong>, and <strong>cardinality</strong>. The combination of these properties determines the execution function's name, parameters, and semantics.</p>
<h4 id="naming-of-execution-functions"><span class="header-section-number">2.1.5.1</span> Naming of execution functions</h4>
<p>The name of an execution function is determined by the combination of its properties. A word or prefix is associated with each property, and these are concatenated in the order below.</p>
<table style="width:72%;">
<colgroup>
<col width="19%" />
<col width="23%" />
<col width="29%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Cardinality</th>
<th align="left">Directionality</th>
<th align="left">Blocking semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&quot;&quot;</code> or <code>&quot;bulk_&quot;</code></td>
<td align="left"><code>&quot;&quot;</code> or <code>&quot;sync_&quot;</code> or <code>&quot;async_&quot;</code> or <code>&quot;then_&quot;</code></td>
<td align="left"><code>&quot;execute&quot;</code> or <code>&quot;post&quot;</code> or <code>&quot;defer&quot;</code></td>
</tr>
</tbody>
</table>
<h4 id="semantics-of-execution-functions"><span class="header-section-number">2.1.5.2</span> Semantics of execution functions</h4>
<p>The parameters of the execution function and semantics that apply to the the execution function and to the execution agents created by it are determined by the combination of its properties. Parameters and semantics are added to an execution function for each of the properties. Whenever there is a conflict of semantics the presedence is resolved in the order below.</p>
<pre><code>Cardinality &gt; Directionality &gt; Blocking semantics</code></pre>
<h4 id="blocking-semantics"><span class="header-section-number">2.1.5.3</span> Blocking semantics</h4>
<p>The blocking semantics of an execution function may be one of the following:</p>
<ul>
<li><em>Potentially blocking:</em> The execution function may block the caller pending completion of the submitted function objects. Execution functions having potentially blocking semantics are named <code>execute</code>.</li>
<li><em>Non-blocking:</em> The execution function shall not block the caller pending completion of the submitted function objects. Execution functions having non-blocking semantics are named <code>post</code> or <code>defer</code>.</li>
</ul>
<h5 id="requirements-on-execution-functions-having-potentially-blocking-semantics"><span class="header-section-number">2.1.5.3.1</span> Requirements on execution functions having potentially blocking semantics</h5>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code> and <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.execute(f, ...)</code> <br/> <code>execute(x, f, ...)</code></td>
<td align="left">void</td>
<td align="left">Creates an execution agent with forward progress guarantees of <code>executor_execution_mapping_category_t&lt;X&gt;</code> which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> at most once, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>execute</code>. <br/> <br/> May block forward progress of the caller until <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> finishes execution. <br/> <br/> The invocation of <code>execute</code> synchronizes with (C++Std [intro.multithread]) the invocation of <code>f</code>.</td>
</tr>
</tbody>
</table>
<h5 id="requirements-on-execution-functions-having-non-blocking-semantics"><span class="header-section-number">2.1.5.3.2</span> Requirements on execution functions having non-blocking semantics</h5>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code> and <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.post(f, ...)</code> <br/><code>post(x, f, ...)</code></td>
<td align="left">void</td>
<td align="left">Creates an execution agent with forward progress guarantees of <code>executor_execution_mapping_category_t&lt;X&gt;</code> which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> at most once, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>post</code>. <br/> <br/> Shall not block forward progress of the caller until <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> finishes execution. <br/> <br/> The invocation of <code>execute</code> synchronizes with (C++Std [intro.multithread]) the invocation of <code>f</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>x.defer(f, ...)</code> <br/><code>defer(x, f, ...)</code></td>
<td align="left">void</td>
<td align="left">Creates an execution agent with forward progress guarantees of <code>executor_execution_mapping_category_t&lt;X&gt;</code> invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> at most once, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>defer</code>. <br/> <br/> Shall not block forward progress of the caller until <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> finishes execution. <br/> <br/> The invocation of <code>execute</code> synchronizes with (C++Std [intro.multithread]) the invocation of <code>f</code>.</td>
</tr>
</tbody>
</table>
<h4 id="directionality"><span class="header-section-number">2.1.5.4</span> Directionality</h4>
<p>The directionality property of an execution function may be one of the following:</p>
<ul>
<li><em>One-way:</em> The execution function creates execution agents without a channel for awaiting the completion of a submitted function object or for obtaining its result. <em>Note:</em> That is, the executor provides fire-and-forget semantics. <em>--end note</em>] The names of execution functions having one-way directionality do not have an associated prefix.</li>
<li><em>Synchronous two-way:</em> The execution function blocks until execution of the submitted function is complete, and returns the result. The names of execution functions having synchronous two-way directionality have the prefix <code>sync_</code>.</li>
<li><em>Asynchronous two-way:</em> The execution function returns a <code>Future</code> for awaiting the completion of a submitted function object and obtaining its result. The names of execution functions having asynchronous two-way directionality have the prefix <code>async_</code> or <code>then_</code>.</li>
</ul>
<h5 id="requirements-on-execution-functions-of-one-way-directionality"><span class="header-section-number">2.1.5.4.1</span> Requirements on execution functions of one-way directionality</h5>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, <code>'e'</code> denotes an expression from the requirements on blocking semantics and <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.'e'(...)</code> <br/> <code>'e'(x, ...)</code></td>
<td align="left">void</td>
<td align="left">[<em>Note:</em> If <code>f()</code> exits via an exception, the behavior is specific to the executor. <em>--end note.</em>]</td>
</tr>
</tbody>
</table>
<h5 id="requirements-on-execution-functions-of-synchronous-two-way-directionality"><span class="header-section-number">2.1.5.4.2</span> Requirements on execution functions of synchronous two-way directionality</h5>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, <code>'e'</code> denotes an expression from the requirements on blocking semantics and <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.sync_'e'(...)</code> <br/> <code>sync_'e'(x, ...)</code></td>
<td align="left"><code>R</code></td>
<td align="left">Returns the result of <code>f()</code>. <br/><br/> Throws any exception thrown by <code>f()</code>. <br/> <br/> Must block forward progress of the caller until <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> finishes execution.</td>
</tr>
</tbody>
</table>
<h5 id="requirements-on-execution-functions-of-asynchronous-two-way-directionality"><span class="header-section-number">2.1.5.4.3</span> Requirements on execution functions of asynchronous two-way directionality</h5>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, <code>'e'</code> denotes an expression from the requirements on blocking semantics, <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements and <code>pred</code> denotes a <code>Future</code> object whose result is <code>pr</code>.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.async_'e'(...)</code> <br/> <code>async_'e'(x, ...)</code></td>
<td align="left">A type that satisfies the <code>Future</code> requirements for the value type <code>R</code>.</td>
<td align="left">Stores the result of <code>f()</code>, or any exception thrown by <code>f()</code>, in the associated shared state of the resulting <code>Future</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>x.then_'e'(..., pred, ...)</code> <br/> <code>then_'e'(x, ..., pred, ...)</code></td>
<td align="left">A type that satisfies the <code>Future</code> requirements for the value type <code>R</code>.</td>
<td align="left">Stores the result of <code>f(pr)</code>, or any exception thrown by <code>f(pr)</code>, in the associated shared state of the resulting <code>Future</code>.</td>
</tr>
</tbody>
</table>
<h4 id="cardinality"><span class="header-section-number">2.1.5.5</span> Cardinality</h4>
<p>The cardinality property of an execution function may be one of the following:</p>
<ul>
<li><em>Single:</em> The execution function creates a single execution agent. The names of execution functions having single cardinality do not have an associated prefix.</li>
<li><em>Bulk:</em> The execution function creates multiple execution agents from a single invocation, with the number determined at runtime. The names of execution functions having bulk cardinality have the prefix <code>bulk_</code>.</li>
</ul>
<h5 id="requirements-on-execution-functions-of-single-cardinality"><span class="header-section-number">2.1.5.5.1</span> Requirements on execution functions of single cardinality</h5>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, <code>'e'</code> denotes an expression from the requirements on directionality, <code>'ret'</code> denotes the return type of the execution function from previous properties, <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements, and <code>a</code> denotes a (possibly const) value of type <code>A</code> satisfying the <code>ProtoAllocator</code> requirements.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.'e'(...)</code> <br/><code>'e'(x, ...)</code> <br/> <code>x.'e'(..., a)</code> <br/><code>'e'(x, ..., a)</code></td>
<td align="left"><code>'ret'</code></td>
<td align="left">Executor implementations should use the supplied allocator (if any) to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [<em>Note:</em> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <em>--end note</em>]</td>
</tr>
</tbody>
</table>
<h5 id="requirements-on-execution-functions-of-bulk-cardinality"><span class="header-section-number">2.1.5.5.2</span> Requirements on execution functions of bulk cardinality</h5>
<p>In the Table below,</p>
<ul>
<li><code>x</code> denotes a (possibly const) executor object of type <code>X</code>,</li>
<li><code>'e'</code> denotes an expression from the requirements on directionality,</li>
<li><code>'ret'</code> denotes the return type of the execution function from previous properties,</li>
<li><code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))(i, r, s)</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements where
<ul>
<li><code>i</code> denotes an object whose type is <code>executor_index_t&lt;X&gt;</code>,</li>
<li><code>r</code> denotes an object whose type is <code>R</code>,</li>
<li><code>s</code> denotes an object whose type is <code>S</code>,</li>
</ul></li>
<li><code>n</code> denotes a shape object whose type is <code>executor_shape_t&lt;X&gt;</code>,</li>
<li><code>rf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>R</code>,</li>
<li><code>sf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>S</code>,</li>
<li><code>pred</code> denotes a <code>Future</code> object whose result is <code>pr</code>.</li>
</ul>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.bulk_'e'(..., n, ...,[ rf,] sf)</code> <br/> <code>bulk_'e'(x, ..., n, ...,[ rf,] sf)</code></td>
<td align="left"><code>'ret'</code></td>
<td align="left">Creates a group of execution agents of shape <code>n</code> with forward progress guarantees of <code>executor_execution_mapping_category_t&lt;X&gt;</code> which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, r, s)</code> if <code>'ret'</code> is non void otherwise invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, s)</code> , with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>bulk_'e'</code>. <br/> <br/> Parameter <code>rf</code> is only included in the execution function if <code>'ret'</code> is non void. <br/> <br/> The value of type <code>R</code> returned is the result of <code>rf()</code> if <code>'ret'</code> is non void. <br/> <br/> Invokes <code>rf()</code> on an unspecified execution agent. <br/><br/> Invokes <code>sf()</code> on an unspecified execution agent.</td>
</tr>
</tbody>
</table>
<h4 id="execution-function-combinations"><span class="header-section-number">2.1.5.6</span> Execution function combinations</h4>
<p>The table below describes the execution member functions and non-member functions that can be supported by an executor category via various combinations of the execution function requirements.</p>
<table>
<colgroup>
<col width="13%" />
<col width="16%" />
<col width="23%" />
<col width="21%" />
<col width="24%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Cardinality</th>
<th align="left">Directionality</th>
<th align="left">Blocking semantics</th>
<th align="left">Member function</th>
<th align="left">Free function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Single</td>
<td align="left">One-way</td>
<td align="left">Potentially blocking</td>
<td align="left"><code>x.execute(f)</code> <br/> <code>x.execute(f, a)</code></td>
<td align="left"><code>execute(x, f)</code> <br/> <code>execute(x, f, a)</code></td>
</tr>
<tr class="even">
<td align="left">Single</td>
<td align="left">One-way</td>
<td align="left">Non-blocking</td>
<td align="left"><code>x.post(f)</code> <br/> <code>x.post(f, a)</code> <br/> <code>x.defer(f)</code> <br/> <code>x.defer(f, a)</code></td>
<td align="left"><code>post(x, f)</code> <br/> <code>post(x, f, a)</code> <br/> <code>defer(x, f)</code> <br/> <code>defer(x, f, a)</code></td>
</tr>
<tr class="odd">
<td align="left">Single</td>
<td align="left">Two-way synchronous</td>
<td align="left">Potentially blocking</td>
<td align="left"><code>x.sync_execute(f)</code> <br/> <code>x.sync_execute(f, a)</code></td>
<td align="left"><code>sync_execute(x, f)</code> <br/> <code>sync_execute(x, f, a)</code></td>
</tr>
<tr class="even">
<td align="left">Single</td>
<td align="left">Two-way synchronous</td>
<td align="left">Non-blocking</td>
<td align="left">NA</td>
<td align="left">NA</td>
</tr>
<tr class="odd">
<td align="left">Single</td>
<td align="left">Two-way asynchronous</td>
<td align="left">Potentially blocking</td>
<td align="left"><code>x.async_execute(f)</code> <br/> <code>x.async_execute(f, a)</code> <br/> <code>x.then_execute(f, pred)</code> <br/> <code>x.then_execute(f, pred, a)</code></td>
<td align="left"><code>async_execute(x, f)</code> <br/> <code>async_execute(x, f, a)</code> <br/> <code>then_execute(x, f, pred)</code> <br/> <code>then_execute(x, f, pred, a)</code></td>
</tr>
<tr class="even">
<td align="left">Single</td>
<td align="left">Two-way asynchronous</td>
<td align="left">Non-blocking</td>
<td align="left"><code>x.async_post(f)</code> <br/> <code>x.async_post(f, a)</code> <br/> <code>x.async_defer(f)</code> <br/> <code>x.async_defer(f, a)</code></td>
<td align="left"><code>async_post(x, f)</code> <br/> <code>x.async_post(x, f, a)</code> <br/> <code>async_defer(x, f)</code> <br/> <code>x.async_defer(x, f, a)</code></td>
</tr>
<tr class="odd">
<td align="left">Bulk</td>
<td align="left">One-way</td>
<td align="left">Potentially blocking</td>
<td align="left"><code>x.bulk_execute(f, n, sf)</code></td>
<td align="left"><code>bulk_execute(x, f, n, sf)</code></td>
</tr>
<tr class="even">
<td align="left">Bulk</td>
<td align="left">One-way</td>
<td align="left">Non-blocking</td>
<td align="left"><code>x.bulk_post(f, n, sf)</code> <br/> <code>x.bulk_defer(f, n, sf)</code></td>
<td align="left"><code>bulk_post(x, f, n, sf)</code> <br/> <code>bulk_defer(x, f, n, sf)</code></td>
</tr>
<tr class="odd">
<td align="left">Bulk</td>
<td align="left">Two-way synchronous</td>
<td align="left">Potentially blocking</td>
<td align="left"><code>x.bulk_sync_execute(f, n, rf, sf)</code></td>
<td align="left"><code>bulk_sync_execute(x, f, n, rf, sf)</code></td>
</tr>
<tr class="even">
<td align="left">Bulk</td>
<td align="left">Two-way synchronous</td>
<td align="left">Non-blocking</td>
<td align="left">NA</td>
<td align="left">NA</td>
</tr>
<tr class="odd">
<td align="left">Bulk</td>
<td align="left">Two-way asynchronous</td>
<td align="left">Potentially blocking</td>
<td align="left"><code>x.bulk_async_execute(f, n, rf, sf)</code> <br/> <code>x.bulk_then_execute(f, n, pred, rf, sf)</code></td>
<td align="left"><code>bulk_async_execute(x, f, n, rf, sf)</code> <br/> <code>bulk_then_execute(x, f, n, pred, rf, sf)</code></td>
</tr>
<tr class="even">
<td align="left">Bulk</td>
<td align="left">Two-way asynchronous</td>
<td align="left">Non-blocking</td>
<td align="left"><code>x.bulk_async_post(f, n, rf, sf)</code> <br/> <code>x.bulk_async_defer(f, n, rf, sf)</code></td>
<td align="left"><code>bulk_async_post(x, f, n, rf, sf)</code> <br/> <code>bulk_async_defer(x, f, n, rf, sf)</code></td>
</tr>
</tbody>
</table>
<h3 id="baseexecutor-requirements"><span class="header-section-number">2.1.6</span> <code>BaseExecutor</code> requirements</h3>
<p>A type <code>X</code> meets the <code>BaseExecutor</code> requirements if it satisfies the requirements of <code>CopyConstructible</code> (C++Std [copyconstructible]), <code>Destructible</code> (C++Std [destructible]), and <code>EqualityComparable</code> (C++Std [equalitycomparable]), as well as the additional requirements listed below.</p>
<p>No comparison operator, copy operation, move operation, swap operation, or member function <code>context</code> on these types shall exit via an exception.</p>
<p>The executor copy constructor, comparison operators, <code>context</code> member function, associated execution functions, and other member functions defined in refinements (TODO: what should this word be?) of the <code>BaseExecutor</code> requirements shall not introduce data races as a result of concurrent calls to those functions from different threads.</p>
<p>The destructor shall not block pending completion of the submitted function objects. [<em>Note:</em> The ability to wait for completion of submitted function objects may be provided by the associated execution context. <em>--end note</em>]</p>
<p>In the Table  below, <code>x1</code> and <code>x2</code> denote (possibly const) values of type <code>X</code>, <code>mx1</code> denotes an xvalue of type <code>X</code>, and <code>u</code> denotes an identifier.</p>
<table style="width:90%;">
<caption>(Base executor requirements) </caption>
<colgroup>
<col width="20%" />
<col width="18%" />
<col width="51%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Type</th>
<th align="left">Assertion/note/pre-/post-condition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>X u(x1);</code></td>
<td align="left"></td>
<td align="left">Shall not exit via an exception. <br/><br/><em>Post:</em> <code>u == x1</code> and <code>u.context() == x1.context()</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>X u(mx1);</code></td>
<td align="left"></td>
<td align="left">Shall not exit via an exception. <br/><br/><em>Post:</em> <code>u</code> equals the prior value of <code>mx1</code> and <code>u.context()</code> equals the prior value of <code>mx1.context()</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>x1 == x2</code></td>
<td align="left"><code>bool</code></td>
<td align="left">Returns <code>true</code> only if <code>x1</code> and <code>x2</code> can be interchanged with identical effects in any of the expressions defined in these type requirements (TODO and the other executor requirements defined in this Technical Specification). [<em>Note:</em> Returning <code>false</code> does not necessarily imply that the effects are not identical. <em>--end note</em>] <code>operator==</code> shall be reflexive, symmetric, and transitive, and shall not exit via an exception.</td>
</tr>
<tr class="even">
<td align="left"><code>x1 != x2</code></td>
<td align="left"><code>bool</code></td>
<td align="left">Same as <code>!(x1 == x2)</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>x1.context()</code></td>
<td align="left"><code>E&amp;</code> or <code>const E&amp;</code> where <code>E</code> is a type that satisfies the <code>ExecutionContext</code> requirements.</td>
<td align="left">Shall not exit via an exception. The comparison operators and member functions defined in these requirements (TODO and the other executor requirements defined in this Technical Specification) shall not alter the reference returned by this function.</td>
</tr>
</tbody>
</table>
<h3 id="onewayexecutor-requirements"><span class="header-section-number">2.1.7</span> <code>OneWayExecutor</code> requirements</h3>
<p>The <code>OneWayExecutor</code> requirements specify requirements for executors which create execution agents without a channel for awaiting the completion of a submitted function object and obtaining its result. [<em>Note:</em> That is, the executor provides fire-and-forget semantics. <em>--end note</em>]</p>
<p>A type <code>X</code> satisfies the <code>OneWayExecutor</code> requirements if it satisfies the <code>BaseExecutor</code> requirements, and <code>can_execute_v&lt;X&gt;</code> is true.</p>
<h3 id="nonblockingonewayexecutor-requirements"><span class="header-section-number">2.1.8</span> <code>NonBlockingOneWayExecutor</code> requirements</h3>
<p>The <code>NonBlockingOneWayExecutor</code> requirements refine the <code>OneWayExecutor</code> requirements by adding one-way operations that are guaranteed not to block the caller pending completion of submitted function objects.</p>
<p>A type <code>X</code> satisfies the <code>NonBlockingOneWayExecutor</code> requirements if it satisfies the <code>OneWayExecutor</code> requirements, <code>can_post_v&lt;X&gt;</code> is true, and <code>can_defer_v&lt;X&gt;</code> is true.</p>
<h3 id="twowayexecutor-requirements"><span class="header-section-number">2.1.9</span> <code>TwoWayExecutor</code> requirements</h3>
<p>The <code>TwoWayExecutor</code> requirements specify requirements for executors which creating execution agents with a channel for awaiting the completion of a submitted function object and obtaining its result.</p>
<p>A type <code>X</code> satisfies the <code>TwoWayExecutor</code> requirements if it satisfies the <code>BaseExecutor</code> requirements, <code>can_sync_execute_v&lt;X&gt;</code> is true, and <code>can_async_execute_v&lt;X&gt;</code> is true.</p>
<h3 id="bulktwowayexecutor-requirements"><span class="header-section-number">2.1.10</span> <code>BulkTwoWayExecutor</code> requirements</h3>
<p>The <code>BulkTwoWayExecutor</code> requirements specify requirements for executors which create groups of execution agents in bulk from a single execution function with a channel for awaiting the completion of a submitted function object invoked by those execution agents and obtaining its result.</p>
<p>A type <code>X</code> satisfies the <code>BulkTwoWayExecutor</code> requirements if it satisfies the <code>BaseExecutor</code> requirements, <code>can_bulk_sync_execute_v&lt;X&gt;</code> is true, <code>can_bulk_async_execute_v&lt;X&gt;</code> is true, and <code>can_bulk_then_execute_v&lt;X&gt;</code> is true.</p>
<h3 id="executorworktracker-requirements"><span class="header-section-number">2.1.11</span> <code>ExecutorWorkTracker</code> requirements</h3>
<p>The <code>ExecutorWorkTracker</code> requirements defines operations for tracking future work against an executor. These operations are used to advise an executor that function objects may be submitted to it at some point in the future.</p>
<p>A type <code>X</code> satisfies the <code>ExecutorWorkTracker</code> requirements if it satisfies the <code>BaseExecutor</code> requirements, as well as the additional requirements listed below.</p>
<p>No constructor, comparison operator, copy operation, move operation, swap operation, or member functions <code>on_work_started</code> and <code>on_work_finished</code> on these types shall exit via an exception.</p>
<p>The executor copy constructor, comparison operators, and other member functions defined in these requirements shall not introduce data races as a result of concurrent calls to those functions from different threads.</p>
<p>In the Table  below, <code>x</code> denotes an object of type <code>X</code>,</p>
<table>
<caption>(Executor Work Tracker requirements) </caption>
<colgroup>
<col width="29%" />
<col width="19%" />
<col width="51%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Assertion/note/pre-/post-condition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.on_work_started()</code></td>
<td align="left"><code>bool</code></td>
<td align="left">Shall not exit via an exception. <br/>Must be paired with a corresponding subsequent call to <code>on_work_finished</code>. <br/>Returns <code>false</code> if the executor will not execute any further functions submitted to it; otherwise returns <code>true</code>. A return value of <code>true</code> does not guarantee that the executor will execute any further functions submitted to it.</td>
</tr>
<tr class="even">
<td align="left"><code>x.on_work_finished()</code></td>
<td align="left"></td>
<td align="left">Shall not exit via an exception. <br/>Precondition: A corresponding preceding call to <code>on_work_started</code> that returned <code>true</code>.</td>
</tr>
</tbody>
</table>
<h3 id="member-detection-type-traits"><span class="header-section-number">2.1.12</span> Member detection type traits</h3>
<pre><code>template&lt;class T&gt; struct has_execute_member;
template&lt;class T&gt; struct has_post_member;
template&lt;class T&gt; struct has_defer_member;
template&lt;class T&gt; struct has_sync_execute_member;
template&lt;class T&gt; struct has_async_execute_member;
template&lt;class T&gt; struct has_async_post_member;
template&lt;class T&gt; struct has_async_defer_member;
template&lt;class T&gt; struct has_then_execute_member;
template&lt;class T&gt; struct has_bulk_execute_member;
template&lt;class T&gt; struct has_bulk_post_member;
template&lt;class T&gt; struct has_bulk_defer_member;
template&lt;class T&gt; struct has_bulk_sync_execute_member;
template&lt;class T&gt; struct has_bulk_async_execute_member;
template&lt;class T&gt; struct has_bulk_async_post_member;
template&lt;class T&gt; struct has_bulk_async_defer_member;
template&lt;class T&gt; struct has_bulk_then_execute_member;</code></pre>
<p>This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of <code>true_type</code> if the corresponding condition is true, otherwise <code>false_type</code>.</p>
<table style="width:94%;">
<colgroup>
<col width="40%" />
<col width="30%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Template</th>
<th align="left">Condition</th>
<th align="left">Preconditions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>execute</code> that satisfies the syntactic requirements of a one-way, potentially blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_post_member</code></td>
<td align="left"><code>T</code> has a member function named <code>post</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_defer_member</code></td>
<td align="left"><code>T</code> has a member function named <code>defer</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_sync_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>sync_execute</code> that satisfies the syntactic requirements of a synchronous two-way execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_async_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>async_execute</code> that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_async_post_member</code></td>
<td align="left"><code>T</code> has a member function named <code>async_post</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_async_defer_member</code></td>
<td align="left"><code>T</code> has a member function named <code>async_defer</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_then_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>then_execute</code> that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_execute</code> that satisfies the syntactic requirements of a one-way, potentially blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_post_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_post</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_defer_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_defer</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_sync_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_sync_execute</code> that satisfies the syntactic requirements of a synchronous two-way execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_async_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_async_execute</code> that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_async_post_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_async_post</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_async_defer_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_async_defer</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_then_execute_member</code></td>
<td align="left"><code>T</code> has a member function named <code>bulk_then_execute</code> that satisfies the syntactic requirements of an a asynchronous two-way, potentially blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
</tbody>
</table>
<h3 id="free-function-detection-type-traits"><span class="header-section-number">2.1.13</span> Free function detection type traits</h3>
<pre><code>template&lt;class T&gt; struct has_execute_free_function;
template&lt;class T&gt; struct has_post_free_function;
template&lt;class T&gt; struct has_defer_free_function;
template&lt;class T&gt; struct has_sync_execute_free_function;
template&lt;class T&gt; struct has_async_execute_free_function;
template&lt;class T&gt; struct has_async_post_free_function;
template&lt;class T&gt; struct has_async_defer_free_function;
template&lt;class T&gt; struct has_then_execute_free_function;
template&lt;class T&gt; struct has_bulk_execute_free_function;
template&lt;class T&gt; struct has_bulk_post_free_function;
template&lt;class T&gt; struct has_bulk_defer_free_function;
template&lt;class T&gt; struct has_bulk_sync_execute_free_function;
template&lt;class T&gt; struct has_bulk_async_execute_free_function;
template&lt;class T&gt; struct has_bulk_async_post_free_function;
template&lt;class T&gt; struct has_bulk_async_defer_free_function;
template&lt;class T&gt; struct has_bulk_then_execute_free_function;</code></pre>
<p>This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of <code>true_type</code> if the corresponding condition is true, otherwise <code>false_type</code>.</p>
<table style="width:94%;">
<colgroup>
<col width="40%" />
<col width="30%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Template</th>
<th align="left">Condition</th>
<th align="left">Preconditions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_execute_free_function</code></td>
<td align="left">There exists a free function named <code>execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a one-way, potentially blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_post_free_function</code></td>
<td align="left">There exists a free function named <code>post</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_defer_free_function</code></td>
<td align="left">There exists a free function named <code>defer</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_sync_execute_free_function</code></td>
<td align="left">There exists a free function named <code>sync_execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a synchronous two-way execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_async_execute_free_function</code></td>
<td align="left">There exists a free function named <code>async_execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_async_post_free_function</code></td>
<td align="left">There exists a free function named <code>async_post</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_async_defer_free_function</code></td>
<td align="left">There exists a free function named <code>async_defer</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_then_execute_free_function</code></td>
<td align="left">There exists a free function named <code>then_execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_execute_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a one-way, potentially blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_post_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_post</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_defer_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_defer</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_sync_execute_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_sync_execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of a synchronous two-way execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_async_execute_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_async_execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_async_post_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_async_post</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_async_defer_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_async_defer</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct has_bulk_then_execute_free_function</code></td>
<td align="left">There exists a free function named <code>bulk_then_execute</code> taking an executor of type <code>T</code> that satisfies the syntactic requirements of an an asynchronous two-way, potentially blocking execution function of bulk cardinality.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
</tbody>
</table>
<h2 id="executor-customization-points"><span class="header-section-number">2.2</span> Executor customization points</h2>
<p><em>Executor customization points</em> are execution functions which adapt an executor's free and member execution functions to create execution agents. Executor customization points enable uniform use of executors in generic contexts.</p>
<p>When an executor customization point named <em>NAME</em> invokes a free execution function of the same name, overload resolution is performed in a context that includes the declaration <code>void</code> <em>NAME</em><code>(auto&amp;... args) = delete;</code>, where <code>sizeof...(args)</code> is the arity of the free execution function. This context also does not include a declaration of the executor customization point.</p>
<p>[<em>Note:</em> This provision allows executor customization points to call the executor's free, non-member execution function of the same name without recursion. <em>--end note</em>]</p>
<p>Whenever <code>std::experimental::concurrency_v2::execution::</code><em>NAME</em><code>(</code><em>ARGS</em><code>)</code> is a valid expression, that expression satisfies the syntactic requirements for the free execution function named <em>NAME</em> with arity <code>sizeof...(</code><em>ARGS</em><code>)</code> with that free execution function's semantics.</p>
<h3 id="execute"><span class="header-section-number">2.2.1</span> <code>execute</code></h3>
<pre><code>namespace {
  constexpr unspecified execute = unspecified;
}</code></pre>
<p>The name <code>execute</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::execute(E, F, A...)</code> for some expressions <code>E</code> and <code>F</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).execute(F, A...)</code> if <code>has_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>execute(E, F, A...)</code> if <code>has_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::execute(E, F, A...)</code> is ill-formed.</p></li>
</ul>
<h3 id="post"><span class="header-section-number">2.2.2</span> <code>post</code></h3>
<pre><code>namespace {
  constexpr unspecified post = unspecified;
}</code></pre>
<p>The name <code>post</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::post(E, F, A...)</code> for some expressions <code>E</code> and <code>F</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).post(F, A...)</code> if <code>has_post_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>post(E, F, A...)</code> if <code>has_post_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::execute(E, F, A...)</code> if <code>can_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::post(E, F, A...)</code> is ill-formed.</p></li>
</ul>
<h3 id="defer"><span class="header-section-number">2.2.3</span> <code>defer</code></h3>
<pre><code>namespace {
  constexpr unspecified defer = unspecified;
}</code></pre>
<p>The name <code>defer</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::defer(E, F, A...)</code> for some expressions <code>E</code> and <code>F</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).defer(F, A...)</code> if <code>has_defer_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>defer(E, F, A...)</code> if <code>has_defer_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::execute(E, F, A...)</code> if <code>can_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::defer(E, F, A...)</code> is ill-formed.</p></li>
</ul>
<h3 id="sync_execute"><span class="header-section-number">2.2.4</span> <code>sync_execute</code></h3>
<pre><code>namespace {
  constexpr unspecified sync_execute = unspecified;
}</code></pre>
<p>The name <code>sync_execute</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::sync_execute(E, F, A...)</code> for some expressions <code>E</code> and <code>F</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).sync_execute(F, A...)</code> if <code>has_sync_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>sync_execute(E, F, A...)</code> if <code>has_sync_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::async_execute(E, F, A...).get()</code> if <code>can_async_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::sync_execute(E, F, A...)</code> is ill-formed.</p></li>
</ul>
<h3 id="async_execute"><span class="header-section-number">2.2.5</span> <code>async_execute</code></h3>
<pre><code>namespace {
  constexpr unspecified async_execute = unspecified;
}</code></pre>
<p>The name <code>async_execute</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::async_execute(E, F, A...)</code> for some expressions <code>E</code> and <code>F</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).async_execute(F, A...)</code> if <code>has_async_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>async_execute(E, F, A...)</code> if <code>has_async_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, if <code>can_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true, creates an asynchronous provider with an associated shared state (C++Std [futures.state]). Calls <code>std::experimental::concurrency_v2::execution::execute(E, g, A...)</code> where <code>g</code> is a function object of unspecified type that performs <code>DECAY_COPY(F)()</code>, with the call to <code>DECAY_COPY</code> being performed in the thread that called <code>async_execute</code>. On successful completion of <code>DECAY_COPY(F)()</code>, the return value of <code>DECAY_COPY(F)()</code> is atomically stored in the shared state and the shared state is made ready. If <code>DECAY_COPY(F)()</code> exits via an exception, the exception is atomically stored in the shared state and the shared state is made ready. The result of the expression <code>std::experimental::concurrency_v2::execution::async_execute(E, F, A...)</code> is an object of type <code>std::future&lt;result_of_t&lt;decay_t&lt;decltype(F)&gt;&gt;()&gt;</code> that refers to the shared state.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::async_execute(E, F, A...)</code> is ill-formed.</p></li>
</ul>
<h3 id="async_post"><span class="header-section-number">2.2.6</span> <code>async_post</code></h3>
<pre><code>namespace {
  constexpr unspecified async_post = unspecified;
}</code></pre>
<p>The name <code>async_post</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::async_post(E, F, A...)</code> for some expressions <code>E</code> and <code>F</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).async_post(F, A...)</code> if <code>has_async_post_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>async_post(E, F, A...)</code> if <code>has_async_post_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::async_execute(E, F, A...)</code> if <code>can_async_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, if <code>can_post_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true, creates an asynchronous provider with an associated shared state (C++Std [futures.state]). Calls <code>std::experimental::concurrency_v2::execution::execute(E, g, A...)</code> where <code>g</code> is a function object of unspecified type that performs <code>DECAY_COPY(F)()</code>, with the call to <code>DECAY_COPY</code> being performed in the thread that called <code>async_post</code>. On successful completion of <code>DECAY_COPY(F)()</code>, the return value of <code>DECAY_COPY(F)()</code> is atomically stored in the shared state and the shared state is made ready. If <code>DECAY_COPY(F)()</code> exits via an exception, the exception is atomically stored in the shared state and the shared state is made ready. The result of the expression <code>std::experimental::concurrency_v2::execution::async_post(E, F, A...)</code> is an object of type <code>std::future&lt;result_of_t&lt;decay_t&lt;decltype(F)&gt;&gt;()&gt;</code> that refers to the shared state.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::async_post(E, F, A...)</code> is ill-formed.</p></li>
</ul>
<h3 id="async_defer"><span class="header-section-number">2.2.7</span> <code>async_defer</code></h3>
<pre><code>namespace {
  constexpr unspecified async_defer = unspecified;
}</code></pre>
<p>The name <code>async_defer</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::async_defer(E, F, A...)</code> for some expressions <code>E</code> and <code>F</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).async_defer(F, A...)</code> if <code>has_async_defer_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>async_defer(E, F, A...)</code> if <code>has_async_defer_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::async_execute(E, F, A...)</code> if <code>can_async_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, if <code>can_defer_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true, creates an asynchronous provider with an associated shared state (C++Std [futures.state]). Calls <code>std::experimental::concurrency_v2::execution::execute(E, g, A...)</code> where <code>g</code> is a function object of unspecified type that performs <code>DECAY_COPY(F)()</code>, with the call to <code>DECAY_COPY</code> being performed in the thread that called <code>async_defer</code>. On successful completion of <code>DECAY_COPY(F)()</code>, the return value of <code>DECAY_COPY(F)()</code> is atomically stored in the shared state and the shared state is made ready. If <code>DECAY_COPY(F)()</code> exits via an exception, the exception is atomically stored in the shared state and the shared state is made ready. The result of the expression <code>std::experimental::concurrency_v2::execution::async_defer(E, F, A...)</code> is an object of type <code>std::future&lt;result_of_t&lt;decay_t&lt;decltype(F)&gt;&gt;()&gt;</code> that refers to the shared state.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::async_defer(E, F, A...)</code> is ill-formed.</p></li>
</ul>
<h3 id="then_execute"><span class="header-section-number">2.2.8</span> <code>then_execute</code></h3>
<pre><code>namespace {
  constexpr unspecified then_execute = unspecified;
}</code></pre>
<p>The name <code>then_execute</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::then_execute(E, F, P, A...)</code> for some expressions <code>E</code>, <code>F</code>, and <code>P</code>, and where <code>A...</code> represents 0 or 1 expressions, is equivalent to:</p>
<ul>
<li><p><code>(E).then_execute(F, P, A...)</code> if <code>has_then_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>then_execute(E, F, P, A...)</code> if <code>has_then_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, equivalent to</p>
<pre><code>auto __g = [__f = forward&lt;decltype(F)&gt;(F)](decltype(P)&amp; __predecessor_future)
{
  auto __predecessor_result = __predecessor_future.get();
  return __f(__predecessor_result);
}

return (P).then(E, std::move(__g));</code></pre>
<p>when <code>P</code> is a non-<code>void</code> future. Otherwise,</p>
<pre><code>auto __g = [__f = forward&lt;decltype(F)&gt;(F)](decltype(P)&amp;)
{
  return __f();
}

return (P).then(E, std::move(__g));</code></pre></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::then_execute(E, F, P, A...)</code> is ill-formed</p></li>
</ul>
<h3 id="bulk_execute"><span class="header-section-number">2.2.9</span> <code>bulk_execute</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_execute = unspecified;
}</code></pre>
<p>The name <code>bulk_execute</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_execute(F, S, SF)</code> if <code>has_bulk_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_execute(E, F, S, SF)</code> if <code>has_bulk_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)</code> is ill-formed.</p></li>
</ul>
<h3 id="bulk_post"><span class="header-section-number">2.2.10</span> <code>bulk_post</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_post = unspecified;
}</code></pre>
<p>The name <code>bulk_post</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::bulk_post(E, F, S, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_post(F, S, SF)</code> if <code>has_bulk_post_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_post(E, F, S, SF)</code> if <code>has_bulk_post_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)</code> if <code>can_bulk_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_post(E, F, S, SF)</code> is ill-formed.</p></li>
</ul>
<h3 id="bulk_defer"><span class="header-section-number">2.2.11</span> <code>bulk_defer</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_defer = unspecified;
}</code></pre>
<p>The name <code>bulk_defer</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::bulk_defer(E, F, S, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_defer(F, S, SF)</code> if <code>has_bulk_defer_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_defer(E, F, S, SF)</code> if <code>has_bulk_defer_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)</code> if <code>can_bulk_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_defer(E, F, S, SF)</code> is ill-formed.</p></li>
</ul>
<h3 id="bulk_sync_execute"><span class="header-section-number">2.2.12</span> <code>bulk_sync_execute</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_sync_execute = unspecified;
}</code></pre>
<p>The name <code>bulk_sync_execute</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::bulk_sync_execute(E, F, S, RF, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, <code>RF</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_sync_execute(F, S, RF, SF)</code> if <code>has_bulk_sync_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_sync_execute(E, F, S, RF, SF)</code> if <code>has_bulk_sync_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF).get()</code> if <code>can_bulk_async_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_sync_execute(E, F, S, RF, SF)</code> is ill-formed.</p></li>
</ul>
<h3 id="bulk_async_execute"><span class="header-section-number">2.2.13</span> <code>bulk_async_execute</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_async_execute = unspecified;
}</code></pre>
<p>The name <code>bulk_async_execute</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, <code>RF</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_async_execute(F, S, RF, SF)</code> if <code>has_bulk_async_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_async_execute(E, F, S, RF, SF)</code> if <code>has_bulk_async_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_then_execute(E, F, S, std::experimental::make_ready_future(), RF, SF)</code> if <code>can_bulk_then_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)</code> is ill-formed.</p></li>
</ul>
<h3 id="bulk_async_post"><span class="header-section-number">2.2.14</span> <code>bulk_async_post</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_async_post = unspecified;
}</code></pre>
<p>The name <code>bulk_async_post</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::bulk_async_post(E, F, S, RF, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, <code>RF</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_async_post(F, S, RF, SF)</code> if <code>has_bulk_async_post_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_async_post(E, F, S, RF, SF)</code> if <code>has_bulk_async_post_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)</code> if <code>can_bulk_async_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_async_post(E, F)</code> is ill-formed.</p></li>
</ul>
<h3 id="bulk_async_defer"><span class="header-section-number">2.2.15</span> <code>bulk_async_defer</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_async_defer = unspecified;
}</code></pre>
<p>The name <code>bulk_async_defer</code> denotes a customization point. The effect of the expression <code>std::experimental::concurrency_v2::execution::bulk_async_defer(E, F, S, RF, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, <code>RF</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_async_defer(F, S, RF, SF)</code> if <code>has_bulk_async_defer_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_async_defer(E, F, S, RF, SF)</code> if <code>has_bulk_async_defer_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)</code> if <code>can_bulk_async_execute_v&lt;decay_t&lt;decltype(E)&gt;&gt; &amp;&amp; is_same_v&lt;execution_execute_blocking_category_t&lt;decay_t&lt;decltype(E)&gt;&gt;, non_blocking_execution_tag&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_async_defer(E, F)</code> is ill-formed.</p></li>
</ul>
<h3 id="bulk_then_execute"><span class="header-section-number">2.2.16</span> <code>bulk_then_execute</code></h3>
<pre><code>namespace {
  constexpr unspecified bulk_then_execute = unspecified;
}</code></pre>
<p>The name <code>bulk_then_execute</code> denotes a customization point. The effect of the expression <code>std::expression::concurrency_v2::execution::bulk_then_execute(E, F, S, P, RF, SF)</code> for some expressions <code>E</code>, <code>F</code>, <code>S</code>, <code>P</code>, <code>RF</code>, and <code>SF</code> is equivalent to:</p>
<ul>
<li><p><code>(E).bulk_then_execute(F, S, P, RF, SF)</code> if <code>has_bulk_then_execute_member_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, <code>bulk_then_execute(E, F, S, P, RF, SF)</code> if <code>has_bulk_then_execute_free_function_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is true.</p></li>
<li><p>Otherwise, let <code>DE</code> be <code>decay_t&lt;decltype(E)&gt;</code>. If <code>can_then_execute_v&lt;DE&gt; &amp;&amp; (has_bulk_sync_execute_member_v&lt;DE&gt; || has_bulk_sync_execute_free_function_v&lt;DE&gt; || has_bulk_async_execute_member_v&lt;DE&gt; || has_bulk_async_execute_free_function_v&lt;DE&gt;)</code> is true, equivalent to the following:</p>
<pre><code>auto __f = F;

auto __g = [=](auto&amp; __predecessor)
{
  return std::experimental::concurrency_v2::bulk_sync_execute(E, S, RF, SF,
    [=,&amp;__predecessor](auto&amp; __result, auto&amp; __shared)
  {
    __f(__i, __predecessor, __result, __shared);
  });
};

return std::experimental::concurrency_v2::execution::then_execute(E, __g, P);</code></pre>
<p>if <code>P</code> is a non-<code>void</code> future. Otherwise,</p>
<pre><code>auto __f = F;

auto __g = [=]
{
  return std::experimental::concurrency_v2::bulk_sync_execute(E, S, RF, SF,
    [=](auto&amp; __result, auto&amp; __shared)
  {
    __f(__i, __result, __shared);
  });
};

return std::experimental::concurrency_v2::execution::then_execute(E, __g, P);</code></pre>
<p>[<em>Note:</em> The explicit use of execution function detectors for <code>bulk_sync_execute</code> and <code>bulk_async_execute</code> above is intentional to avoid cycles in this code. <em>--end note</em>]</p></li>
<li><p>Otherwise, <code>std::experimental::concurrency_v2::execution::bulk_then_execute(E, F, S, P, RF, SF)</code> is ill-formed.</p></li>
</ul>
<h3 id="customization-point-type-traits"><span class="header-section-number">2.2.17</span> Customization point type traits</h3>
<pre><code>template&lt;class T&gt; struct can_execute;
template&lt;class T&gt; struct can_post;
template&lt;class T&gt; struct can_defer;
template&lt;class T&gt; struct can_sync_execute;
template&lt;class T&gt; struct can_async_execute;
template&lt;class T&gt; struct can_async_post;
template&lt;class T&gt; struct can_async_defer;
template&lt;class T&gt; struct can_then_execute;
template&lt;class T&gt; struct can_bulk_execute;
template&lt;class T&gt; struct can_bulk_post;
template&lt;class T&gt; struct can_bulk_defer;
template&lt;class T&gt; struct can_bulk_sync_execute;
template&lt;class T&gt; struct can_bulk_async_execute;
template&lt;class T&gt; struct can_bulk_async_post;
template&lt;class T&gt; struct can_bulk_async_defer;
template&lt;class T&gt; struct can_bulk_then_execute;</code></pre>
<p>This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of <code>true_type</code> if the corresponding condition is true, otherwise <code>false_type</code>.</p>
<p>In the Table below,</p>
<ul>
<li><code>t</code> denotes a (possibly const) executor object of type <code>T</code>,</li>
<li><code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code>, where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</li>
<li><code>bof</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(bof))(i, s)</code>,
<ul>
<li>where <code>i</code> denotes an object whose type is <code>executor_index_t&lt;X&gt;</code>,</li>
<li>where <code>s</code> denotes an object whose type is <code>S</code> and</li>
<li>where <code>decay_t&lt;F&gt;</code> satisfies the <code>CopyConstructible</code> requirements,</li>
</ul></li>
<li><code>btf</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(btf))(i, r, s)</code>,
<ul>
<li>where <code>i</code> denotes an object whose type is <code>executor_index_t&lt;X&gt;</code>,</li>
<li>where <code>r</code> denotes an object whose type is <code>R</code>,</li>
<li>where <code>s</code> denotes an object whose type is <code>S</code> and</li>
<li>where <code>decay_t&lt;F&gt;</code> satisfies the <code>CopyConstructible</code> requirements,</li>
</ul></li>
<li><code>bcf</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(bcf))(i, p, r, s)</code>,
<ul>
<li>where <code>i</code> denotes an object whose type is <code>executor_index_t&lt;X&gt;</code>,</li>
<li>where <code>p</code> denotes an object whose type is <code>P</code>,</li>
<li>where <code>r</code> denotes an object whose type is <code>R</code>,</li>
<li>where <code>s</code> denotes an object whose type is <code>S</code> and</li>
<li>where <code>decay_t&lt;F&gt;</code> satisfies the <code>CopyConstructible</code> requirements,</li>
</ul></li>
<li><code>rf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>R</code>,</li>
<li><code>sf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>S</code>,</li>
<li><code>pred</code> denotes a <code>Future</code> object whose result type is <code>P</code> and</li>
<li><code>a</code> denotes a (possibly const) value of type <code>A</code> satisfying the <code>ProtoAllocator</code> requirements.</li>
</ul>
<table style="width:94%;">
<colgroup>
<col width="40%" />
<col width="30%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Template</th>
<th align="left">Conditions</th>
<th align="left">Preconditions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/> <code>struct can_execute</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::execute(t, f)</code> and <code>std::experimental::concurrency_v2::execution::execute(t, f, a)</code> are well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_post</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::post(t, f)</code> and <code>std::experimental::concurrency_v2::execution::post(t, f, a)</code> are well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_defer</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::defer(t, f)</code> and <code>std::experimental::concurrency_v2::execution::defer(t, f, a)</code> are well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_sync_execute</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::sync_execute(t, f)</code> and <code>std::experimental::concurrency_v2::execution::sync_execute(t, f, a)</code> are well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_async_execute</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::async_execute(t, f)</code> and <code>std::experimental::concurrency_v2::execution::async_execute(t, f, a)</code> are well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_async_post</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::async_post(t, f)</code> and <code>std::experimental::concurrency_v2::execution::async_post(t, f, a)</code> are well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_async_defer</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::async_defer(t, f)</code> and <code>std::experimental::concurrency_v2::execution::async_defer(t, f, a)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_then_execute</code></td>
<td align="left">The expressions <code>std::experimental::concurrency_v2::execution::then_execute(t, f, pred)</code> and <code>std::experimental::concurrency_v2::execution::then_execute(t, f, pred)</code> are well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_execute</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_execute(t, bof, s, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_post</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_post(t, bof, s, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_defer</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_defer(t, bof, s, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_sync_execute</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_sync_execute(t, btf, s, rf, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_async_execute</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_async_execute(t, btf, s, rf, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_async_post</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_async_post(t, btf, s, rf, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_async_defer</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_async_defer(t, btf, s, rf, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_bulk_then_execute</code></td>
<td align="left">The expression <code>std::experimental::concurrency_v2::execution::bulk_then_execute(t, bcf, s, pred, rf, sf)</code> is well-formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
</tbody>
</table>
<h2 id="executor-type-traits-1"><span class="header-section-number">2.3</span> Executor type traits</h2>
<h3 id="determining-that-a-type-satisfies-executor-category-requirements"><span class="header-section-number">2.3.1</span> Determining that a type satisfies executor category requirements</h3>
<pre><code>template&lt;class T&gt; struct is_one_way_executor;
template&lt;class T&gt; struct is_non_blocking_one_way_executor;
template&lt;class T&gt; struct is_two_way_executor;
template&lt;class T&gt; struct is_bulk_two_way_executor;</code></pre>
<p>This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of <code>true_type</code> if the corresponding condition is true, otherwise <code>false_type</code>.</p>
<table style="width:94%;">
<colgroup>
<col width="40%" />
<col width="30%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Template</th>
<th align="left">Condition</th>
<th align="left">Preconditions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_one_way_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>OneWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_non_blocking_one_way_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>NonBlockingOneWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_two_way_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>TwoWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_bulk_two_way_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>BulkTwoWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
</tbody>
</table>
<h3 id="associated-execution-context-type"><span class="header-section-number">2.3.2</span> Associated execution context type</h3>
<pre><code>template&lt;class Executor&gt;
struct executor_context
{
  using type = std::decay_t&lt;decltype(declval&lt;const Executor&amp;&gt;().context())&gt;; // TODO check this
};</code></pre>
<h3 id="associated-future-type"><span class="header-section-number">2.3.3</span> Associated future type</h3>
<pre><code>template&lt;class Executor, class T&gt;
struct executor_future
{
  using type = see below;
};</code></pre>
<p>The type of <code>executor_future&lt;Executor, T&gt;::type</code> is determined as follows:</p>
<ul>
<li><p>if <code>is_two_way_executor&lt;Executor&gt;</code> is true, <code>decltype(declval&lt;const Executor&amp;&gt;().async_execute( declval&lt;T(*)()&gt;())</code>;</p></li>
<li><p>otherwise, if <code>is_one_way_executor&lt;Executor&gt;</code> is true, <code>std::future&lt;T&gt;</code>;</p></li>
<li><p>otherwise, the program is ill formed.</p></li>
</ul>
<p>[<em>Note:</em> The effect of this specification is that all execute functions of an executor that satisfies the <code>TwoWayExecutor</code>, <code>NonBlockingTwoWayExecutor</code>, or <code>BulkTwoWayExecutor</code> requirements must utilize the same future type, and that this future type is determined by <code>async_execute</code>. Programs may specialize this trait for user-defined <code>Executor</code> types. <em>--end note</em>]</p>
<h3 id="classifying-the-mapping-of-execution-agents"><span class="header-section-number">2.3.4</span> Classifying the mapping of execution agents</h3>
<pre><code>struct other_execution_mapping_tag {};
struct thread_execution_mapping_tag {};
struct unique_thread_execution_mapping_tag {};

template&lt;class Executor&gt;
struct executor_execution_mapping_category
{
  private:
    // exposition only
    template&lt;class T&gt;
    using helper = typename T::execution_mapping_category;

  public:
    using type = std::experimental::detected_or_t&lt;
      thread_execution_mapping_tag, helper, Executor
    &gt;;
};</code></pre>
<p>Components which create execution agents may use <em>execution mapping categories</em> to communicate the mapping of execution agents onto threads of execution. Execution mapping categories encode the characterisitics of that mapping, if it exists.</p>
<p><code>other_execution_mapping_tag</code> indicates that execution agents created by a component may be mapped onto execution resources other than threads of execution.</p>
<p><code>thread_execution_mapping_tag</code> indicates that execution agents created by a component are mapped onto threads of execution.</p>
<p><code>unique_thread_execution_mapping_tag</code> indicates that each execution agent created by a component is mapped onto a new thread of execution.</p>
<p>[<em>Note:</em> A mapping of an execution agent onto a thread of execution implies the agent executes as-if on a <code>std::thread</code>. Therefore, the facilities provided by <code>std::thread</code>, such as thread-local storage, are available. <code>unique_thread_execution_mapping_tag</code> provides stronger guarantees, in particular that thread-local storage will not be shared between execution agents. <em>--end note</em>]</p>
<h3 id="classifying-the-blocking-behavior-of-potentially-blocking-operations"><span class="header-section-number">2.3.5</span> Classifying the blocking behavior of potentially blocking operations</h3>
<pre><code>struct blocking_execution_tag {};
struct possibly_blocking_execution_tag {};
struct non_blocking_execution_tag {};

template&lt;class Executor&gt;
struct executor_execute_blocking_category
{
  private:
    // exposition only
    template&lt;class T&gt;
    using helper = typename T::blocking_category;

  public:
    using type = std::experimental::detected_or_t&lt;
      possibly_blocking_execution_tag, helper, Executor
    &gt;;
};</code></pre>
<p>Components which create possibly blocking execution may use <em>blocking categories</em> to communicate the way in which this execution blocks the progress of its caller.</p>
<p><code>blocking_execution_tag</code> indicates that a component blocks its caller's progress pending the completion of the execution agents created by that component.</p>
<p><code>possibly_blocking_execution_tag</code> indicates that a component may block its caller's progress pending the completion of the execution agents created by that component.</p>
<p><code>non_blocking_execution_tag</code> indicates that a component does not block its caller's progress pending the completion of the execution agents created by that component.</p>
<p>Programs may use <code>executor_execute_blocking_category</code> to query the blocking behavior of executor customization points whose semantics allow the possibility of blocking.</p>
<p>[<em>Note:</em> These customization points which allow the possibility of blocking are <code>execute</code>, <code>async_execute</code>, <code>then_execute</code>, <code>bulk_execute</code>, <code>bulk_async_execute</code>, and <code>bulk_then_execute</code>. <em>--end note</em>]</p>
<h2 id="bulk-executor-traits"><span class="header-section-number">2.4</span> Bulk executor traits</h2>
<h3 id="classifying-forward-progress-guarantees-of-groups-of-execution-agents"><span class="header-section-number">2.4.1</span> Classifying forward progress guarantees of groups of execution agents</h3>
<pre><code>struct sequenced_execution_tag {};
struct parallel_execution_tag {};
struct unsequenced_execution_tag {};

template&lt;class Executor&gt;
struct executor_execution_category
{
  private:
    // exposition only
    template&lt;class T&gt;
    using helper = typename T::execution_category;

  public:
    using type = std::experimental::detected_or_t&lt;
      unsequenced_execution_tag, helper, Executor
    &gt;;
};</code></pre>
<p>Components which create groups of execution agents may use <em>execution categories</em> to communicate the forward progress and ordering guarantees of these execution agents with respect to other agents within the same group.</p>
<p>TODO: <em>The meanings and relative &quot;strength&quot; of these categores are to be defined. Most of the wording for <code>sequenced_execution_tag</code>, <code>parallel_execution_tag</code>, and <code>unsequenced_execution_tag</code> can be migrated from S 25.2.3 p2, p3, and p4, respectively.</em></p>
<h3 id="associated-shape-type"><span class="header-section-number">2.4.2</span> Associated shape type</h3>
<pre><code>template&lt;class Executor&gt;
struct executor_shape
{
  private:
    // exposition only
    template&lt;class T&gt;
    using helper = typename T::shape_type;

  public:
    using type = std::experimental::detected_or_t&lt;
      size_t, helper, Executor
    &gt;;

    // exposition only
    static_assert(std::is_integral_v&lt;type&gt;, &quot;shape type must be an integral type&quot;);
};</code></pre>
<h3 id="associated-index-type"><span class="header-section-number">2.4.3</span> Associated index type</h3>
<pre><code>template&lt;class Executor&gt;
struct executor_index
{
  private:
    // exposition only
    template&lt;class T&gt;
    using helper = typename T::index_type;

  public:
    using type = std::experimental::detected_or_t&lt;
      executor_shape_t&lt;Executor&gt;, helper, Executor
    &gt;;

    // exposition only
    static_assert(std::is_integral_v&lt;type&gt;, &quot;index type must be an integral type&quot;);
};</code></pre>
<h2 id="executor-work-guard"><span class="header-section-number">2.5</span> Executor work guard</h2>
<pre><code>template&lt;class Executor&gt;
class executor_work_guard
{
public:
  // types:

  typedef Executor executor_type;

  // construct / copy / destroy:

  explicit executor_work_guard(const executor_type&amp; ex) noexcept;
  executor_work_guard(const executor_work_guard&amp; other) noexcept;
  executor_work_guard(executor_work_guard&amp;&amp; other) noexcept;

  executor_work_guard&amp; operator=(const executor_work_guard&amp;) = delete;

  ~executor_work_guard();

  // executor work guard observers:

  executor_type get_executor() const noexcept;
  bool owns_work() const noexcept;

  // executor work guard modifiers:

  void reset() noexcept;

private:
  Executor ex_; // exposition only
  bool owns_; // exposition only
};</code></pre>
<h3 id="members"><span class="header-section-number">2.5.1</span> Members</h3>
<pre><code>explicit executor_work_guard(const executor_type&amp; ex) noexcept;</code></pre>
<p><em>Effects:</em> Initializes <code>ex_</code> with <code>ex</code>, and <code>owns_</code> with the result of <code>ex_.on_work_started()</code>.</p>
<p><em>Postconditions:</em> <code>ex_ == ex</code>.</p>
<pre><code>executor_work_guard(const executor_work_guard&amp; other) noexcept;</code></pre>
<p><em>Effects:</em> Initializes <code>ex_</code> with <code>other.ex_</code>. If <code>other.owns_ == true</code>, initializes <code>owns_</code> with the result of <code>ex_.on_work_started()</code>; otherwise, sets <code>owns_</code> to false.</p>
<p><em>Postconditions:</em> <code>ex_ == other.ex_</code>.</p>
<pre><code>executor_work_guard(executor_work_guard&amp;&amp; other) noexcept;</code></pre>
<p><em>Effects:</em> Initializes <code>ex_</code> with <code>std::move(other.ex_)</code> and <code>owns_</code> with <code>other.owns_</code>, and sets <code>other.owns_</code> to <code>false</code>.</p>
<pre><code>~executor_work_guard();</code></pre>
<p><em>Effects:</em> If <code>owns_</code> is <code>true</code>, performs <code>ex_.on_work_finished()</code>.</p>
<pre><code>executor_type get_executor() const noexcept;</code></pre>
<p><em>Returns:</em> <code>ex_</code>.</p>
<pre><code>bool owns_work() const noexcept;</code></pre>
<p><em>Returns:</em> <code>owns_</code>.</p>
<pre><code>void reset() noexcept;</code></pre>
<p><em>Effects:</em> If <code>owns_</code> is <code>true</code>, performs <code>ex_.on_work_finished()</code>.</p>
<p><em>Postconditions:</em> <code>owns_ == false</code>.</p>
<h2 id="polymorphic-executor-wrappers"><span class="header-section-number">2.6</span> Polymorphic executor wrappers</h2>
<h3 id="general-requirements-on-polymorphic-executor-wrappers"><span class="header-section-number">2.6.1</span> General requirements on polymorphic executor wrappers</h3>
<p>Polymorphic executors defined in this Technical Specification satisfy the <code>BaseExecutor</code>, <code>DefaultConstructible</code> (C++Std [defaultconstructible]), and <code>CopyAssignable</code> (C++Std [copyassignable]) requirements, and are defined as follows.</p>
<pre><code>class C
{
public:
  class context_type; // TODO define this

  // construct / copy / destroy:

  C() noexcept;
  C(nullptr_t) noexcept;
  C(const executor&amp; e) noexcept;
  C(executor&amp;&amp; e) noexcept;
  template&lt;class Executor&gt; C(Executor e);
  template&lt;class Executor, class ProtoAllocator&gt;
    C(allocator_arg_t, const ProtoAllocator&amp; a, Executor e);

  C&amp; operator=(const C&amp; e) noexcept;
  C&amp; operator=(C&amp;&amp; e) noexcept;
  C&amp; operator=(nullptr_t) noexcept;
  template&lt;class Executor&gt; C&amp; operator=(Executor e);

  ~C();

  // polymorphic executor modifiers:

  void swap(C&amp; other) noexcept;
  template&lt;class Executor, class ProtoAllocator&gt;
    void assign(Executor e, const ProtoAllocator&amp; a);

  // C operations:

  context_type context() const noexcept;

  // polymorphic executor capacity:

  explicit operator bool() const noexcept;

  // polymorphic executor target access:

  const type_info&amp; target_type() const noexcept;
  template&lt;class Executor&gt; Executor* target() noexcept;
  template&lt;class Executor&gt; const Executor* target() const noexcept;
};

// polymorphic executor comparisons:

bool operator==(const C&amp; a, const C&amp; b) noexcept;
bool operator==(const C&amp; e, nullptr_t) noexcept;
bool operator==(nullptr_t, const C&amp; e) noexcept;
bool operator!=(const C&amp; a, const C&amp; b) noexcept;
bool operator!=(const C&amp; e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const C&amp; e) noexcept;

// executor specialized algorithms:

void swap(C&amp; a, C&amp; b) noexcept;

// in namespace std:

template&lt;class Allocator&gt;
  struct uses_allocator&lt;C, Allocator&gt;
    : true_type {};</code></pre>
<p>[<em>Note:</em> To meet the <code>noexcept</code> requirements for executor copy constructors and move constructors, implementations may share a target between two or more <code>executor</code> objects. <em>--end note</em>]</p>
<p>The <em>target</em> is the executor object that is held by the wrapper.</p>
<h4 id="polymorphic-executor-constructors"><span class="header-section-number">2.6.1.1</span> Polymorphic executor constructors</h4>
<pre><code>C() noexcept;</code></pre>
<p><em>Postconditions:</em> <code>!*this</code>.</p>
<pre><code>C(nullptr_t) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>!*this</code>.</p>
<pre><code>C(const C&amp; e) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>!*this</code> if <code>!e</code>; otherwise, <code>*this</code> targets <code>e.target()</code> or a copy of <code>e.target()</code>.</p>
<pre><code>C(C&amp;&amp; e) noexcept;</code></pre>
<p><em>Effects:</em> If <code>!e</code>, <code>*this</code> has no target; otherwise, moves <code>e.target()</code> or move-constructs the target of <code>e</code> into the target of <code>*this</code>, leaving <code>e</code> in a valid state with an unspecified value.</p>
<pre><code>template&lt;class Executor&gt; C(Executor e);</code></pre>
<p><em>Effects:</em> <code>*this</code> targets a copy of <code>e</code> initialized with <code>std::move(e)</code>.</p>
<pre><code>template&lt;class Executor, class ProtoAllocator&gt;
  C(allocator_arg_t, const ProtoAllocator&amp; a, Executor e);</code></pre>
<p><em>Effects:</em> <code>*this</code> targets a copy of <code>e</code> initialized with <code>std::move(e)</code>.</p>
<p>A copy of the allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed <code>C</code> object.</p>
<h4 id="polymorphic-executor-assignment"><span class="header-section-number">2.6.1.2</span> Polymorphic executor assignment</h4>
<pre><code>C&amp; operator=(const C&amp; e) noexcept;</code></pre>
<p><em>Effects:</em> <code>C(e).swap(*this)</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>C&amp; operator=(C&amp;&amp; e) noexcept;</code></pre>
<p><em>Effects:</em> Replaces the target of <code>*this</code> with the target of <code>e</code>, leaving <code>e</code> in a valid state with an unspecified value.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>C&amp; operator=(nullptr_t) noexcept;</code></pre>
<p><em>Effects:</em> <code>C(nullptr).swap(*this)</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>template&lt;class Executor&gt; C&amp; operator=(Executor e);</code></pre>
<p><em>Effects:</em> <code>C(std::move(e)).swap(*this)</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<h4 id="polymorphic-executor-destructor"><span class="header-section-number">2.6.1.3</span> Polymorphic executor destructor</h4>
<pre><code>~C();</code></pre>
<p><em>Effects:</em> If <code>*this != nullptr</code>, releases shared ownership of, or destroys, the target of <code>*this</code>.</p>
<h4 id="polymorphic-executor-modifiers"><span class="header-section-number">2.6.1.4</span> Polymorphic executor modifiers</h4>
<pre><code>void swap(C&amp; other) noexcept;</code></pre>
<p><em>Effects:</em> Interchanges the targets of <code>*this</code> and <code>other</code>.</p>
<pre><code>template&lt;class Executor, class ProtoAllocator&gt;
  void assign(Executor e, const ProtoAllocator&amp; a);</code></pre>
<p><em>Effects:</em> <code>C(allocator_arg, a, std::move(e)).swap(*this)</code>.</p>
<h4 id="polymorphic-executor-operations"><span class="header-section-number">2.6.1.5</span> Polymorphic executor operations</h4>
<pre><code>context_type context() const noexcept;</code></pre>
<p><em>Requires:</em> <code>*this != nullptr</code>.</p>
<p><em>Returns:</em> A polymorphic wrapper for <code>e.context()</code>, where <code>e</code> is the target object of <code>*this</code>.</p>
<h4 id="polymorphic-executor-capacity"><span class="header-section-number">2.6.1.6</span> Polymorphic executor capacity</h4>
<pre><code>explicit operator bool() const noexcept;</code></pre>
<p><em>Returns:</em> <code>true</code> if <code>*this</code> has a target, otherwise <code>false</code>.</p>
<h4 id="polymorphic-executor-target-access"><span class="header-section-number">2.6.1.7</span> Polymorphic executor target access</h4>
<pre><code>const type_info&amp; target_type() const noexcept;</code></pre>
<p><em>Returns:</em> If <code>*this</code> has a target of type <code>T</code>, <code>typeid(T)</code>; otherwise, <code>typeid(void)</code>.</p>
<pre><code>template&lt;class Executor&gt; Executor* target() noexcept;
template&lt;class Executor&gt; const Executor* target() const noexcept;</code></pre>
<p><em>Returns:</em> If <code>target_type() == typeid(Executor)</code> a pointer to the stored executor target; otherwise a null pointer value.</p>
<h4 id="polymorphic-executor-comparisons"><span class="header-section-number">2.6.1.8</span> Polymorphic executor comparisons</h4>
<pre><code>bool operator==(const C&amp; a, const C&amp; b) noexcept;</code></pre>
<p><em>Returns:</em></p>
<ul>
<li><code>true</code> if <code>!a</code> and <code>!b</code>;</li>
<li><code>true</code> if <code>a</code> and <code>b</code> share a target;</li>
<li><code>true</code> if <code>e</code> and <code>f</code> are the same type and <code>e == f</code>, where <code>e</code> is the target of <code>a</code> and <code>f</code> is the target of <code>b</code>;</li>
<li>otherwise <code>false</code>.</li>
</ul>
<pre><code>bool operator==(const C&amp; e, nullptr_t) noexcept;
bool operator==(nullptr_t, const C&amp; e) noexcept;</code></pre>
<p><em>Returns:</em> <code>!e</code>.</p>
<pre><code>bool operator!=(const C&amp; a, const C&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>!(a == b)</code>.</p>
<pre><code>bool operator!=(const C&amp; e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const C&amp; e) noexcept;</code></pre>
<p><em>Returns:</em> <code>(bool) e</code>.</p>
<h4 id="polymorphic-executor-specialized-algorithms"><span class="header-section-number">2.6.1.9</span> Polymorphic executor specialized algorithms</h4>
<pre><code>void swap(C&amp; a, C&amp; b) noexcept;</code></pre>
<p><em>Effects:</em> <code>a.swap(b)</code>.</p>
<h3 id="class-one_way_executor"><span class="header-section-number">2.6.2</span> Class <code>one_way_executor</code></h3>
<p>Class <code>one_way_executor</code> satisfies the general requirements on polymorphic executor wrappers, with the additional definitions below.</p>
<pre><code>class one_way_executor
{
public:
  // execution agent creation
  template&lt;class Function, class ProtoAllocator = std::allocator&lt;void&gt;&gt;
    void execute(Function&amp;&amp; f, const ProtoAllocator&amp; a = ProtoAllocator()) const;
};</code></pre>
<p>Class <code>one_way_executor</code> satisfies the <code>OneWayExecutor</code> requirements. The target object shall satisfy the <code>OneWayExecutor</code> requirements.</p>
<pre><code>template&lt;class Function, class ProtoAllocator&gt;
  void execute(Function&amp;&amp; f, const ProtoAllocator&amp; a) const;</code></pre>
<p>Let <code>e</code> be the target object of <code>*this</code>. Let <code>a1</code> be the allocator that was specified when the target was set. Let <code>fd</code> be the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>.</p>
<p><em>Effects:</em> Performs <code>e.execute(g, a1)</code>, where <code>g</code> is a function object of unspecified type that, when called as <code>g()</code>, performs <code>fd()</code>. The allocator <code>a</code> is used to allocate any memory required to implement <code>g</code>.</p>
<h3 id="class-non_blocking_one_way_executor"><span class="header-section-number">2.6.3</span> Class <code>non_blocking_one_way_executor</code></h3>
<p>Class <code>non_blocking_one_way_executor</code> satisfies the general requirements on polymorphic executor wrappers, with the additional definitions below.</p>
<pre><code>class non_blocking_one_way_executor
{
public:
  // execution agent creation
  template&lt;class Function, class ProtoAllocator = std::allocator&lt;void&gt;&gt;
    void execute(Function&amp;&amp; f, const ProtoAllocator&amp; a = ProtoAllocator()) const;
  template&lt;class Function, class ProtoAllocator = std::allocator&lt;void&gt;&gt;
    void post(Function&amp;&amp; f, const ProtoAllocator&amp; a = ProtoAllocator()) const;
  template&lt;class Function, class ProtoAllocator = std::allocator&lt;void&gt;&gt;
    void defer(Function&amp;&amp; f, const ProtoAllocator&amp; a = ProtoAllocator()) const;
};</code></pre>
<p>Class <code>non_blocking_one_way_executor</code> satisfies the <code>NonBlockingOneWayExecutor</code> requirements. The target object shall satisfy the <code>NonBlockingOneWayExecutor</code> requirements.</p>
<pre><code>template&lt;class Function, class ProtoAllocator&gt;
  void execute(Function&amp;&amp; f, const ProtoAllocator&amp; a) const;</code></pre>
<p>Let <code>e</code> be the target object of <code>*this</code>. Let <code>a1</code> be the allocator that was specified when the target was set. Let <code>fd</code> be the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>.</p>
<p><em>Effects:</em> Performs <code>e.execute(g, a1)</code>, where <code>g</code> is a function object of unspecified type that, when called as <code>g()</code>, performs <code>fd()</code>. The allocator <code>a</code> is used to allocate any memory required to implement <code>g</code>.</p>
<pre><code>template&lt;class Function, class ProtoAllocator&gt;
  void post(Function&amp;&amp; f, const ProtoAllocator&amp; a) const;</code></pre>
<p>Let <code>e</code> be the target object of <code>*this</code>. Let <code>a1</code> be the allocator that was specified when the target was set. Let <code>fd</code> be the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>.</p>
<p><em>Effects:</em> Performs <code>e.post(g, a1)</code>, where <code>g</code> is a function object of unspecified type that, when called as <code>g()</code>, performs <code>fd()</code>. The allocator <code>a</code> is used to allocate any memory required to implement <code>g</code>.</p>
<pre><code>template&lt;class Function, class ProtoAllocator&gt;
  void defer(Function&amp;&amp; f, const ProtoAllocator&amp; a) const;</code></pre>
<p>Let <code>e</code> be the target object of <code>*this</code>. Let <code>a1</code> be the allocator that was specified when the target was set. Let <code>fd</code> be the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>.</p>
<p><em>Effects:</em> Performs <code>e.defer(g, a1)</code>, where <code>g</code> is a function object of unspecified type that, when called as <code>g()</code>, performs <code>fd()</code>. The allocator <code>a</code> is used to allocate any memory required to implement <code>g</code>.</p>
<h3 id="class-two_way_executor"><span class="header-section-number">2.6.4</span> Class <code>two_way_executor</code></h3>
<p>Class <code>two_way_executor</code> satisfies the general requirements on polymorphic executor wrappers, with the additional definitions below.</p>
<pre><code>class two_way_executor
{
public:
  // execution agent creation
  template&lt;class Function, class ProtoAllocator = std::allocator&lt;void&gt;&gt;
    result_of_t&lt;decay_t&lt;Function&gt;()&gt;
      sync_execute(Function&amp;&amp; f, const ProtoAllocator&amp; a = ProtoAllocator()) const;
  template&lt;class Function, class ProtoAllocator = std::allocator&lt;void&gt;&gt;
    std::future&lt;result_of_t&lt;decay_t&lt;Function&gt;()&gt;&gt;
      async_execute(Function&amp;&amp; f, const ProtoAllocator&amp; a = ProtoAllocator()) const;
};</code></pre>
<p>Class <code>two_way_executor</code> satisfies the <code>TwoWayExecutor</code> requirements. The target object shall satisfy the <code>TwoWayExecutor</code> requirements.</p>
<pre><code>template&lt;class Function, class ProtoAllocator&gt;
  result_of_t&lt;decay_t&lt;Function&gt;()&gt;
    sync_execute(Function&amp;&amp; f, const ProtoAllocator&amp; a);</code></pre>
<p>Let <code>e</code> be the target object of <code>*this</code>. Let <code>a1</code> be the allocator that was specified when the target was set. Let <code>fd</code> be the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>.</p>
<p><em>Effects:</em> Performs <code>e.sync_execute(g, a1)</code>, where <code>g</code> is a function object of unspecified type that, when called as <code>g()</code>, performs <code>fd()</code>. The allocator <code>a</code> is used to allocate any memory required to implement <code>g</code>.</p>
<p><em>Returns:</em> The return value of <code>fd()</code>.</p>
<pre><code>template&lt;class Function, class ProtoAllocator&gt;
  std::future&lt;result_of_t&lt;decay_t&lt;Function&gt;()&gt;&gt;
    async_execute(Function&amp;&amp; f, const ProtoAllocator&amp; a) const;</code></pre>
<p>Let <code>e</code> be the target object of <code>*this</code>. Let <code>a1</code> be the allocator that was specified when the target was set. Let <code>fd</code> be the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>.</p>
<p><em>Effects:</em> Performs <code>e.async_execute(g, a1)</code>, where <code>g</code> is a function object of unspecified type that, when called as <code>g()</code>, performs <code>fd()</code>. The allocator <code>a</code> is used to allocate any memory required to implement <code>g</code>.</p>
<p><em>Returns:</em> A future with an associated shared state that will contain the result of <code>fd()</code>. [<em>Note:</em> <code>e.async_execute(g)</code> may return any future type that satisfies the Future requirements, and not necessarily <code>std::future</code>. One possible implementation approach is for the polymorphic wrapper to attach a continuation to the inner future via that object's <code>then()</code> member function. When invoked, this continuation stores the result in the outer future's associated shared and makes that shared state ready. <em>--end note</em>]</p>
<h2 id="thread-pools"><span class="header-section-number">2.7</span> Thread pools</h2>
<p>Thread pools create execution agents which execute on threads without incurring the overhead of thread creation and destruction whenever such agents are needed.</p>
<h3 id="header-thread_pool-synopsis"><span class="header-section-number">2.7.1</span> Header <code>&lt;thread_pool&gt;</code> synopsis</h3>
<pre><code>namespace std {
namespace experimental {
inline namespace concurrency_v2 {

  class static_thread_pool;

} // inline namespace concurrency_v2
} // namespace experimental
} // namespace std</code></pre>
<h3 id="class-static_thread_pool"><span class="header-section-number">2.7.2</span> Class <code>static_thread_pool</code></h3>
<p><code>static_thread_pool</code> is a statically-sized thread pool which may be explicitly grown via thread attachment. However, <code>static_thread_pool</code> does not automatically change size.</p>
<p><code>static_thread_pool</code> presents an effectively unbounded input queue and the execution functions of <code>static_thread_pool</code>'s associated executors do not block on this input queue.</p>
<p>[<em>Note:</em> Because <code>static_thread_pool</code> provides parallel execution agents, situations which require concurrent execution properties are not guaranteed correctness. <em>--end note.</em>]</p>
<pre><code>class static_thread_pool
{
  public:
    class executor_type;
    
    // construction/destruction
    explicit static_thread_pool(std::size_t num_threads);
    
    // nocopy
    static_thread_pool(const static_thread_pool&amp;) = delete;
    static_thread_pool&amp; operator=(const static_thread_pool&amp;) = delete;

    // stop accepting incoming work and wait for work to drain
    ~static_thread_pool();

    // attach current thread to the thread pools list of worker threads
    void attach();

    // signal all work to complete
    void stop();

    // wait for all threads in the thread pool to complete
    void wait();

    // placeholder for a general approach to getting executors from 
    // standard contexts.
    executor_type executor() noexcept;
};

bool operator==(const static_thread_pool&amp; a, const static_thread_pool&amp; b) noexcept;
bool operator!=(const static_thread_pool&amp; a, const static_thread_pool&amp; b) noexcept;</code></pre>
<p>The class <code>static_thread_pool</code> satisfies the <code>ExecutionContext</code> requirements.</p>
<p>For an object of type <code>static_thread_pool</code>, <em>outstanding work</em> is defined as the sum of:</p>
<ul>
<li><p>the total number of calls to the <code>on_work_started</code> function that returned <code>true</code>, less the total number of calls to the <code>on_work_finished</code> function, on any executor associated with the <code>static_thread_pool</code>.</p></li>
<li><p>the number of function objects that have been added to the <code>static_thread_pool</code> via the <code>static_thread_pool</code> executor, but not yet executed; and</p></li>
<li><p>the number of function objects that are currently being executed by the <code>static_thread_pool</code>.</p></li>
</ul>
<p>The <code>static_thread_pool</code> member functions <code>executor</code>, <code>attach</code>, <code>wait</code>, and <code>stop</code>, and the <code>static_thread_pool::executor_type</code> copy constructors and member functions, do not introduce data races as a result of concurrent calls to those functions from different threads of execution.</p>
<h4 id="construction-and-destruction"><span class="header-section-number">2.7.2.1</span> Construction and destruction</h4>
<pre><code>static_thread_pool(std::size_t num_threads);</code></pre>
<p><em>Effects:</em> Constructs a <code>static_thread_pool</code> object with <code>num_threads</code> threads of execution, as if by creating objects of type <code>std::thread</code>.</p>
<pre><code>~static_thread_pool();</code></pre>
<p><em>Effects:</em> Destroys an object of class <code>static_thread_pool</code>. Performs <code>stop()</code> followed by <code>wait()</code>.</p>
<h4 id="worker-management"><span class="header-section-number">2.7.2.2</span> Worker Management</h4>
<pre><code>void attach();</code></pre>
<p><em>Effects:</em> adds the calling thread to the pool of workers. Blocks the calling thread until signalled to complete by <code>stop()</code> or <code>wait()</code>, and then blocks until all the threads created during <code>static_thread_pool</code> object construction have completed. (Note: The implementation is required to use the attached thread to execute submitted function objects. RATIONALE: implementations in terms of the Windows thread pool cannot utilise user-provided threads. --end note) (NAMING: a possible alternate name for this function is <code>join()</code>.)</p>
<pre><code>void stop();</code></pre>
<p><em>Effects:</em> Signals the threads in the pool to complete as soon as possible. If a thread is currently executing a function object, the thread will exit only after completion of that function object. The call to <code>stop()</code> returns without waiting for the threads to complete. Subsequent calls to attach complete immediately.</p>
<pre><code>void wait();</code></pre>
<p><em>Effects:</em> If not already stopped, signals the threads in the pool to complete once the outstanding work is <code>0</code>. Blocks the calling thread (C++Std [defns.block]) until all threads in the pool have completed, without executing submitted function objects in the calling thread. Subsequent calls to attach complete immediately.</p>
<p><em>Synchronization:</em> The completion of each thread in the pool synchronizes with (C++Std [intro.multithread]) the corresponding successful <code>wait()</code> return.</p>
<h4 id="executor-creation"><span class="header-section-number">2.7.2.3</span> Executor Creation</h4>
<pre><code>executor_type executor() noexcept;</code></pre>
<p><em>Returns:</em> An executor that may be used to submit function objects to the thread pool.</p>
<h4 id="comparisons"><span class="header-section-number">2.7.2.4</span> Comparisons</h4>
<pre><code>bool operator==(const static_thread_pool&amp; a, const static_thread_pool&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>std::addressof(a) == std::addressof(b)</code>.</p>
<pre><code>bool operator!=(const static_thread_pool&amp; a, const static_thread_pool&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>!(a == b)</code>.</p>
<h3 id="class-static_thread_poolexecutor_type"><span class="header-section-number">2.7.3</span> Class <code>static_thread_pool::executor_type</code></h3>
<pre><code>class static_thread_pool::executor_type
{
  public:
    // types:

    typedef parallel_execution_tag execution_category;
    typedef possibly_blocking_execution_tag blocking_category;
    typedef std::size_t shape_type;
    typedef std::size_t index_type;

    // construct / copy / destroy:

    executor_type(const executor_type&amp; other) noexcept;
    executor_type(executor_type&amp;&amp; other) noexcept;

    executor_type&amp; operator=(const executor_type&amp; other) noexcept;
    executor_type&amp; operator=(executor_type&amp;&amp; other) noexcept;

    // executor operations:

    bool running_in_this_thread() const noexcept;

    static_thread_pool&amp; context() const noexcept;

    bool on_work_started() const noexcept;
    void on_work_finished() const noexcept;
};

bool operator==(const static_thread_pool::executor_type&amp; a,
                const static_thread_pool::executor_type&amp; b) noexcept;
bool operator!=(const static_thread_pool::executor_type&amp; a,
                const static_thread_pool::executor_type&amp; b) noexcept;</code></pre>
<p><code>static_thread_pool::executor_type</code> is a type satisfying the <code>BaseExecutor</code> and <code>ExecutorWorkTracker</code> requirements. Objects of type <code>static_thread_pool::executor</code> are associated with a <code>static_thread_pool</code>.</p>
<p>The customization points <code>execute</code>, <code>post</code>, <code>defer</code>, <code>sync_execute</code>, <code>async_execute</code>, <code>async_post</code>, <code>async_defer</code>, <code>then_execute</code>, <code>bulk_execute</code>, <code>bulk_post</code>, <code>bulk_defer</code>, <code>bulk_sync_execute</code>, <code>bulk_async_execute</code>, <code>bulk_async_post</code>, <code>bulk_async_defer</code>, and <code>bulk_then_execute</code> are well-formed for this executor. Function objects submitted using these customization points will be executed by the <code>static_thread_pool</code>.</p>
<p>For the customization points <code>execute</code>, <code>sync_execute</code>, <code>async_execute</code>, <code>bulk_execute</code>, <code>bulk_sync_execute</code>, and <code>bulk_async_execute</code>, if <code>running_in_this_thread()</code> is <code>true</code>, calls at least one of the submitted function objects in the current thread prior to returning from the customization point. [<em>Note:</em> If this function object exits via an exception, the exception propagates to the caller. <em>--end note</em>]</p>
<h4 id="constructors"><span class="header-section-number">2.7.3.1</span> Constructors</h4>
<pre><code>executor_type(const executor_type&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this == other</code>.</p>
<pre><code>executor_type(executor_type&amp;&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this</code> is equal to the prior value of <code>other</code>.</p>
<h4 id="assignment"><span class="header-section-number">2.7.3.2</span> Assignment</h4>
<pre><code>executor_type&amp; operator=(const executor_type&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this == other</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>executor_type&amp; operator=(executor_type&amp;&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this</code> is equal to the prior value of <code>other</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<h4 id="operations"><span class="header-section-number">2.7.3.3</span> Operations</h4>
<pre><code>bool running_in_this_thread() const noexcept;</code></pre>
<p><em>Returns:</em> <code>true</code> if the current thread of execution is a thread that was created by or attached to the associated <code>static_thread_pool</code> object.</p>
<pre><code>static_thread_pool&amp; context() const noexcept;</code></pre>
<p><em>Returns:</em> A reference to the associated <code>static_thread_pool</code> object.</p>
<pre><code>bool on_work_started() const noexcept;</code></pre>
<p><em>Effects:</em> Increments the count of outstanding work associated with the <code>static_thread_pool</code>.</p>
<p><em>Returns:</em> <code>false</code> if there was a prior call to the <code>stop()</code> member function of the associated <code>static_thread_pool</code> object; otherwise <code>true</code>.</p>
<pre><code>void on_work_finished() const noexcept;</code></pre>
<p><em>Effects:</em> Decrements the count of outstanding work associated with the <code>static_thread_pool</code>.</p>
<h4 id="comparisons-1"><span class="header-section-number">2.7.3.4</span> Comparisons</h4>
<pre><code>bool operator==(const static_thread_pool::executor_type&amp; a,
                const static_thread_pool::executor_type&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>a.context() == b.context()</code>.</p>
<pre><code>bool operator!=(const static_thread_pool::executor_type&amp; a,
                const static_thread_pool::executor_type&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>!(a == b)</code>.</p>
<h2 id="interoperation-with-existing-facilities"><span class="header-section-number">2.8</span> Interoperation with existing facilities</h2>
<h3 id="execution-policy-interoperation"><span class="header-section-number">2.8.1</span> Execution policy interoperation</h3>
<pre><code>class parallel_execution_policy
{
  public:
    // types:
    using execution_category = parallel_execution_tag;
    using executor_type = implementation-defined;

    // executor access
    const executor_type&amp; executor() const noexcept;

    // execution policy factory
    template&lt;class Executor&gt;
    see-below on(Executor&amp;&amp; exec) const;
};

class sequenced_execution_tag { by-analogy-to-parallel_execution_policy };
class parallel_unsequenced_execution_tag { by-analogy-to-parallel_execution_policy };</code></pre>
<h4 id="associated-executor"><span class="header-section-number">2.8.1.1</span> Associated executor</h4>
<p>Each execution policy is associated with an executor, and this executor is called its <em>associated executor</em>.</p>
<p>The type of an execution policy's associated executor shall satisfy the requirements of <code>BulkTwoWayExecutor</code>.</p>
<p>When an execution policy is used as a parameter to a parallel algorithm, the execution agents that invoke element access functions are created by the execution policy's associated executor.</p>
<p>The type of an execution policy's associated executor is the member type <code>executor_type</code>.</p>
<h4 id="execution-category"><span class="header-section-number">2.8.1.2</span> Execution category</h4>
<p>Each execution policy is categorized by an <em>execution category</em>.</p>
<p>When an execution policy is used as a parameter to a parallel algorithm, the execution agents it creates are guaranteed to make forward progress and execute invocations of element access functions as ordered by its execution category.</p>
<p>An execution policy's execution category is given by the member type <code>execution_category</code>.</p>
<p>The execution category of an execution policy's associated executor shall not be weaker than the execution policy's execution category.</p>
<h4 id="associated-executor-access"><span class="header-section-number">2.8.1.3</span> Associated executor access</h4>
<pre><code>const executor_type&amp; executor() const noexcept;</code></pre>
<p><em>Returns:</em> The execution policy's associated executor.</p>
<h4 id="execution-policy-factory"><span class="header-section-number">2.8.1.4</span> Execution policy factory</h4>
<pre><code>template&lt;class Executor&gt;
see-below on(Executor&amp;&amp; exec) const;</code></pre>
<p>Let <code>T</code> be <code>decay_t&lt;Executor&gt;</code>.</p>
<p><em>Returns:</em> An execution policy whose execution category is <code>execution_category</code>. If <code>T</code> satisfies the requirements of <code>BulkTwoWayExecutor</code>, the returned execution policy's associated executor is equal to <code>exec</code>. Otherwise, the returned execution policy's associated executor fulfills the <code>BulkTwoWayExecutor</code> requirements which creates execution agents using a copy of <code>exec</code>.</p>
<p><em>Remarks:</em> This member function shall not participate in overload resolution unless <code>is_executor_v&lt;T&gt;</code> is <code>true</code> and <code>executor_execution_category_t&lt;T&gt;</code> is as strong as <code>execution_category</code>.</p>
<h3 id="control-structure-interoperation"><span class="header-section-number">2.8.2</span> Control structure interoperation</h3>
<h4 id="function-template-async"><span class="header-section-number">2.8.2.1</span> Function template <code>async</code></h4>
<p>The function template <code>async</code> provides a mechanism to invoke a function in a new execution agent created by an executor and provides the result of the function in the future object with which it shares a state.</p>
<pre><code>template&lt;class Executor, class Function, class... Args&gt;
executor_future_t&lt;Executor, result_of_t&lt;decay_t&lt;Function&gt;(decay_t&lt;Args&gt;...)&gt;&gt;
async(const Executor&amp; exec, Function&amp;&amp; f, Args&amp;&amp;... args);</code></pre>
<p><em>Returns:</em> Equivalent to:</p>
<pre><code>auto __g = bind(std::forward&lt;Function&gt;(f), std::forward&lt;Args&gt;(args)...);
return execution::async_post(exec, [__g = move(__g)]{ return INVOKE(__g); });</code></pre>
<h4 id="stdexperimentalfuturethen"><span class="header-section-number">2.8.2.2</span> <code>std::experimental::future::then()</code></h4>
<p>The member function template <code>then</code> provides a mechanism for attaching a <em>continuation</em> to a <code>std::future</code> object, which will be executed on a new execution agent created by an executor.</p>
<pre><code>template&lt;class T&gt;
template&lt;class Executor, class Function&gt;
executor_future_t&lt;Executor, see-below&gt;
future&lt;T&gt;::then(const Executor&amp; exec, Function&amp;&amp; f);</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>TODO: Concrete specification</li>
</ol>
<p>The general idea of this overload of <code>.then()</code> is that it accepts a particular type of <code>OneWayExecutor</code> that cannot block in <code>.execute()</code>. <code>.then()</code> stores <code>f</code> as the next continuation in the future state, and when the future is ready, creates an execution agent using a copy of <code>exec</code>.</p>
<p>One approach is for <code>.then()</code> to require a <code>NonBlockingOneWayExecutor</code>, and to specify that <code>.then()</code> submits the continuation using <code>exec.post()</code> if the future is already ready at the time when <code>.then()</code> is called, and to submit using <code>exec.execute()</code> otherwise.</p>
<h4 id="stdexperimentalshared_futurethen"><span class="header-section-number">2.8.2.3</span> <code>std::experimental::shared_future::then()</code></h4>
<p>The member function template <code>then</code> provides a mechanism for attaching a <em>continuation</em> to a <code>std::shared_future</code> object, which will be executed on a new execution agent created by an executor.</p>
<pre><code>template&lt;class T&gt;
template&lt;class Executor, class Function&gt;
executor_future_t&lt;Executor, see-below&gt;
shared_future&lt;T&gt;::then(const Executor&amp; exec, Function&amp;&amp; f);</code></pre>
<p>TODO: Concrete specification</p>
<p>The general idea of this overload of <code>.then()</code> is that it accepts a particular type of <code>OneWayExecutor</code> that cannot block in <code>.execute()</code>. <code>.then()</code> stores <code>f</code> as the next continuation in the underlying future state, and when the underlying future is ready, creates an execution agent using a copy of <code>exec</code>.</p>
<p>One approach is for <code>.then()</code> to require a <code>NonBlockingOneWayExecutor</code>, and to specify that <code>.then()</code> submits the continuation using <code>exec.post()</code> if the future is already ready at the time when <code>.then()</code> is called, and to submit using <code>exec.execute()</code> otherwise.</p>
<h4 id="function-template-invoke"><span class="header-section-number">2.8.2.4</span> Function template <code>invoke</code></h4>
<p>The function template <code>invoke</code> provides a mechanism to invoke a function in a new execution agent created by an executor and return result of the function.</p>
<pre><code>template&lt;class Executor, class Function, class... Args&gt;
result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;
invoke(const Executor&amp; exec, Function&amp;&amp; f, Args&amp;&amp;... args);</code></pre>
<p><em>Returns:</em> Equivalent to:</p>
<p><code>return execution::sync_execute(exec, [&amp;]{ return INVOKE(f, args...); });</code></p>
<h4 id="task-block"><span class="header-section-number">2.8.2.5</span> Task block</h4>
<h5 id="function-template-define_task_block_restore_thread"><span class="header-section-number">2.8.2.5.1</span> Function template <code>define_task_block_restore_thread()</code></h5>
<pre><code>template&lt;class Executor, class F&gt;
void define_task_block_restore_thread(const Executor&amp; exec, F&amp;&amp; f);</code></pre>
<p><em>Requires:</em> Given an lvalue <code>tb</code> of type <code>task_block</code>, the expression <code>f(tb)</code> shall be well-formed.</p>
<p><em>Effects:</em> Constructs a <code>task_block tb</code>, creates a new execution agent, and calls <code>f(tb)</code> on that execution agent.</p>
<p><em>Throws:</em> <code>exception_list</code>, as specified in version two of the Paralellism TS.</p>
<p><em>Postconditions:</em> All tasks spawned from <code>f</code> have finished execution.</p>
<p><em>Remarks:</em> Unlike <code>define_task_block</code>, <code>define_task_block_restore_thread</code> always returns on the same thread as the one on which it was called.</p>
<h5 id="task_block-member-function-template-run"><span class="header-section-number">2.8.2.5.2</span> <code>task_block</code> member function template <code>run</code></h5>
<pre><code>template&lt;class Executor, class F&gt;
void run(const Executor&amp; exec, F&amp;&amp; f);</code></pre>
<p><em>Requires:</em> <code>F</code> shall be <code>MoveConstructible</code>. <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> shall be a valid expression.</p>
<p><em>Preconditions:</em> <code>*this</code> shall be an active <code>task_block</code>.</p>
<p><em>Effects:</em> Evaluates <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code>, where <code>DECAY_COPY(std::forward&lt;F&gt;(f))</code> is evaluated synchronously within the current thread. The call to the resulting copy of the function object is permitted to run on an execution agent created by <code>exec</code> in an unordered fashion relative to the sequence of operations following the call to <code>run(exec, f)</code> (the continuation), or indeterminately-sequenced within the same thread as the continuation. The call to <code>run</code> synchronizes with the next invocation of <code>wait</code> on the same <code>task_block</code> or completion of the nearest enclosing <code>task_block</code> (i.e., the <code>define_task_block</code> or <code>define_task_block_restore_thread</code> that created this <code>task_block</code>.</p>
<p><em>Throws:</em> <code>task_cancelled_exception</code>, as described in version 2 of the Parallelism TS.</p>
<h1 id="relationship-to-other-proposals-and-specifications"><span class="header-section-number">3</span> Relationship to other proposals and specifications</h1>
<h2 id="networking-ts"><span class="header-section-number">3.1</span> Networking TS</h2>
<p>Executors in the Networking TS may be defined as refinements of the type requirements in this proposal, as illustrated below. In addition to these requirements, some minor changes would be required to member function names and parameters used in the Networking TS, to conform to the requirements defined in this proposal.</p>
<h3 id="networkingexecutor-requirements"><span class="header-section-number">3.1.1</span> <code>NetworkingExecutor</code> requirements</h3>
<p>A type <code>X</code> satisfies the <code>NetworkingExecutor</code> requirements if it satisfies the <code>NonBlockingOneWayExecutor</code> requirements, the <code>ExecutorWorkTracker</code> requirements, and satisfies the additional requirements listed below.</p>
<p>In the Table  below, <code>x</code> denotes a (possibly const) value of type <code>X</code>.</p>
<table style="width:94%;">
<colgroup>
<col width="22%" />
<col width="40%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">expression</th>
<th align="left">return type</th>
<th align="left">assertion/note pre/post-condition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.context()</code></td>
<td align="left"><code>net::execution_context&amp;</code>, or <code>E&amp;</code> where <code>E</code> is a type that satisfies the <code>NetworkingExecutionContext</code> requirements.</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h3 id="networkingexecutioncontext-requirements"><span class="header-section-number">3.1.2</span> <code>NetworkingExecutionContext</code> requirements</h3>
<p>A type <code>X</code> satisfies the <code>NetworkingExecutionContext</code> requirements if it satisfies the <code>ExecutionContext</code> requirements, is publicly and unambiguously derived from <code>net::execution_context</code>, and satisfies the additional requirements listed below.</p>
<p>In the Table  below, <code>x</code> denotes a value of type <code>X</code>.</p>
<table style="width:94%;">
<caption>(NetworkingExecutionContext requirements) </caption>
<colgroup>
<col width="22%" />
<col width="40%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">expression</th>
<th align="left">return type</th>
<th align="left">assertion/note pre/post-condition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>X::executor_type</code></td>
<td align="left">type meeting <code>NetworkingExecutor</code> requirements</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>x.~X()</code></td>
<td align="left"></td>
<td align="left">Destroys all unexecuted function objects that were submitted via an executor object that is associated with the execution context.</td>
</tr>
<tr class="odd">
<td align="left"><code>x.get_executor()</code></td>
<td align="left"><code>X::executor_type</code></td>
<td align="left">Returns an executor object that is associated with the execution context.</td>
</tr>
</tbody>
</table>
<h1 id="appendix"><span class="header-section-number">4</span> Appendix</h1>
<h2 id="code-examples"><span class="header-section-number">4.1</span> Code Examples</h2>
<p>These short code examples demonstrate how we expect programmers to use executors to create execution in different use cases.</p>
<h3 id="simple-use-of-an-executor"><span class="header-section-number">4.1.1</span> Simple use of an executor</h3>
<p>A programmer may create an asynchronous task via <code>async()</code> by providing an executor obtained from a thread pool:</p>
<pre><code>using namespace std::experimental::concurrency_v2;

// create a thread pool object
static_thread_pool pool(4);

// obtain an executor from the thread pool
auto exec = pool.executor()

auto my_task = ...

// compose the thread pool&#39;s executor with async:
async(exec, my_task);</code></pre>
<p>In this example, the executor parameter provides <code>std::async()</code> with explicit requirements concerning how to create the work responsible for executing the task.</p>
<p>Similarly, a programmer may require that the work created by a parallel algorithm happen &quot;on&quot; an executor:</p>
<pre><code>using namespace std::experimental::concurrency_v2;

// create a thread pool object
static_thread_pool pool(4);

// obtain an executor from the thread pool
auto exec = pool.executor()

auto my_task = ...

// compose the thread pool&#39;s executor with the par execution policy using .on():
for_each(execution::par.on(exec), vec.begin(), vec.end(), my_task);</code></pre>
<p>In this example, the executor parameter composes with <code>par</code> to create a new execution policy associated with the thread pool's executor.</p>
<h3 id="use-of-an-executor-in-a-generic-context"><span class="header-section-number">4.1.2</span> Use of an executor in a generic context</h3>
<p>Functions may receive executors as generic template parameters. Our proposal provides tools for working in generic contexts while retaining the ability to manipulate executors uniformly. For example, consider this implementation of a hypothetical math library's parallel <code>dot()</code> product function:</p>
<pre><code>template&lt;class BulkTwoWayExecutor&gt;
float dot(const BulkTwoWayExecutor&amp; exec, const float* data1, const float* data2, size_t n)
{
  auto zipped = zip_with(std::multiplies&lt;&gt;(), data1, data2);
  return std::reduce(std::execution::par.on(exec), zipped, zipped + n, 0.f, std::plus&lt;&gt;());
}</code></pre>
<p>Because it is a template, the <code>dot()</code> function has no concrete information about <code>exec</code>, besides the fact that the executor satisfies the requirements of our <code>BulkTwoWayExecutor</code> concept. However, this is all the information necessary to compose <code>exec</code> correctly with <code>par</code> and <code>std::reduce</code>.</p>
<p>Programmers may work at a lower level yet retain generality by manipulating an executor through customization points. For example, consider this hypothetical implementation of <code>async()</code>:</p>
<pre><code>template&lt;class Executor, class Function, class... Args&gt;
auto async(const Executor&amp; exec, Function&amp;&amp; f, Args&amp;&amp;... args)
{
  // bind f and args together
  auto g = bind(f, args...);

  using namespace std::experimental::concurrency_v2;

  // use the customization point execution::async_execute() to asynchronously invoke g and return a future
  return execution::async_execute(exec, g);
}</code></pre>
<p>Even if the executor in this example does not natively support the <code>async_execute()</code> operation through a member or free function, the executor may still be used as if it does support this operation. If native support does not exist, the customization point applies an adaptation to whatever native operations do exist to create the desired operation.</p>
<h3 id="defining-executors"><span class="header-section-number">4.1.3</span> Defining executors</h3>
<p>A programmer creates an executor by defining a type with one or more execution functions defined as members or free functions as well as other members related to executor identity.</p>
<p>For example, an executor which creates a new thread for each execution agent may define the <code>execute()</code> method:</p>
<pre><code>struct per_thread_executor
{
  template&lt;class Function&gt;
  void execute(Function&amp;&amp; f) const
  {
    std::thread new_thread(std::forward&lt;Function&gt;(f));

    new_thread.detach();
  }

  const per_thread_executor&amp; context() const noexcept
  {
    return *this;
  }

  bool operator==(const per_thread_executor&amp;) const noexcept
  {
    return true;
  }

  bool operator!=(const per_thread_executor&amp;) const noexcept
  {
    return false;
  }
};</code></pre>
<p>An executor which executes work immediately within the calling thread may define the <code>sync_execute()</code> method:</p>
<pre><code>struct inline_executor
{
  template&lt;class Function&gt;
  auto sync_execute(Function&amp;&amp; f) const
  {
    return std::forward&lt;Function&gt;(f)();
  }

  const inline_executor&amp; context() const noexcept
  {
    return *this;
  }

  bool operator==(const inline_executor&amp;) const noexcept
  {
    return true;
  }

  bool operator!=(const inline_executor&amp;) const noexcept
  {
    return false;
  }
};</code></pre>
<p>An executor which executes parallel work in bulk using OpenMP may define the <code>bulk_sync_execute()</code> method:</p>
<pre><code>struct openmp_executor
{
  using execution_category = parallel_execution_tag;

  template&lt;class Function, class ResultFactory, class SharedFactory&gt;
  auto bulk_sync_execute(Function f, size_t n, ResultFactory result_factory, SharedFactory shared_factory) const
  {
    auto result = result_factory();
    auto shared = shared_factory();

    #pragma omp parallel for
    for(size_t i = 0; i &lt; n; ++i)
    {
      f(i, result, shared);
    }

    return result;
  }

  const openmp_executor&amp; context() const noexcept
  {
    return *this;
  }

  bool operator==(const openmp_executor&amp;) const noexcept
  {
    return true;
  }

  bool operator!=(const openmp_executor&amp;) const noexcept
  { 
    return false;
  }
};</code></pre>
