<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues Resolved Directly In Kona</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues Resolved Directly In Kona</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">P0625R0</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2017-03-03 at 22:03:08 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Immediate Issues</h2>
<hr>
<h3><a name="2788" href="p0625r0.html#2788">2788.</a> <tt>basic_string</tt> range mutators unintentionally require a default constructible allocator</h3>
<p><b>Section:</b> 21.3.2.6.2 [string.append], 21.3.2.6.3 [string.assign], 21.3.2.6.4 [string.insert], 21.3.2.6.6 [string.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2016-10-25 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Email discussion occurred on the <a href="http://lists.isocpp.org/lib/2016/10/1154.php">lib reflector</a>.
<p/>
<tt>basic_string</tt>'s mutation functions show construction of temporary <tt>basic_string</tt> instances, 
without passing an allocator parameter. This says that <tt>basic_string</tt> needs to use a default-initialized 
allocator, which is clearly unintentional. The temporary needs to use the same allocator the current 
<tt>basic_string</tt> instance uses, if an implmentation needs to create a temporary at all.
<p/>
libc++ already does this; I believe libstdc++ does as well (due to the bug report we got from a user that brought 
this to our attention), but have not verified there. I implemented this in MSVC++'s STL and this change is scheduled 
to ship in VS "15" RTW.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: Priority 2</p>
<p>Alisdair to investigate and (possibly) provide an alternate P/R</p>

<p><i>[2017-02-13 Alisdair responds:]</i></p>

<p>Looks good to me - no suggested alternative</p>

<p><i>[Kona 2017-02-28]</i></p>

<p>Accepted as Immediate.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.2.6.2 [string.append], add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  basic_string&amp; append(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-19- <i>Requires:</i> <tt>[first, last)</tt> is a valid range.
<p/>
-20- <i>Effects:</i> Equivalent to <tt>append(basic_string(first, last<ins>, get_allocator()</ins>))</tt>.
<p/>
-21- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.2.6.3 [string.assign], add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  basic_string&amp; assign(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> Equivalent to <tt>assign(basic_string(first, last<ins>, get_allocator()</ins>))</tt>.
<p/>
-24- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.2.6.4 [string.insert], add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  iterator insert(const_iterator p, InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-23- <i>Requires:</i> <tt>p</tt> is a valid iterator on <tt>*this</tt>. <tt>[first, last)</tt> is a valid range.
<p/>
-24- <i>Effects:</i> Equivalent to <tt>insert(p - begin(), basic_string(first, last<ins>, get_allocator()</ins>))</tt>.
<p/>
-25- <i>Returns:</i> An iterator which refers to the copy of the first inserted character, or <tt>p</tt> if <tt>first == last</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.2.6.6 [string.replace], add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  basic_string&amp; replace(const_iterator i1, const_iterator i2,
                        InputIterator j1, InputIterator j2);
</pre>
<blockquote>
<p>
-32- <i>Requires:</i> <tt>[begin(), i1)</tt>, <tt>[i1, i2)</tt> and <tt>[j1, j2)</tt> are valid ranges.
<p/>
-33- <i>Effects:</i> Calls <tt>replace(i1 - begin(), i2 - i1, basic_string(j1, j2<ins>, get_allocator()</ins>))</tt>.
<p/>
-34- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2801" href="p0625r0.html#2801">2801.</a> Default-constructibility of <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.11.1.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#unique.ptr.single.ctor">active issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 122</b>
<p/>
<tt>unique_ptr</tt> should not satisfy <tt>is_constructible_v&lt;unique_ptr&lt;T, D&gt;&gt;</tt> 
unless <tt>D</tt> is <tt>DefaultConstructible</tt> and not a pointer type. This is 
important for interactions with <tt>pair</tt>, <tt>tuple</tt>, and <tt>variant</tt>
constructors that rely on the <tt>is_default_constructible</tt> trait.
</p>
<p>
Suggested resolution:
<p/>
Add a <i>Remarks:</i> clause to constrain the default 
constructor to not exist unless the <i>Requires</i> clause is 
satisfied.
</p>
<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2; Howard and Ville to provide wording.</p>

<p><i>[2016-12-24: Howard and Ville provided wording.]</i></p>


<p><i>[2017-03-02, Kona, STL comments and tweaks the wording]</i></p>

<p>
LWG discussed this issue, and we liked it, but we wanted to tweak the PR. I ran this past Ville 
(who drafted the PR with Howard), and he was in favor of tweaking this.
</p>

<p><i>[Kona 2017-03-02]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Modify the synopsis in  20.11.1.2 [unique.ptr.single] as follows:
</p>
<blockquote>
<pre>
[&hellip;]
constexpr unique_ptr(nullptr_t) noexcept<ins>;</ins>
    <del>: unique_ptr() { }</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>
Modify 20.11.1.2.1 [unique.ptr.single.ctor] as follows:
</p>
<blockquote>

<pre>
constexpr unique_ptr() noexcept;
<ins>constexpr unique_ptr(nullptr_t) noexcept;</ins>
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>D</tt> shall satisfy the requirements of <tt>DefaultConstructible</tt> (Table 22), and that construction
shall not throw an exception.
<p/>
-2- <i>Effects:</i> Constructs a <tt>unique_ptr</tt> object that owns nothing, value-initializing the stored pointer and
the stored deleter.
<p/>
-3- <i>Postconditions:</i> <tt>get() == nullptr</tt>. <tt>get_deleter()</tt> returns a reference to the stored deleter.
<p/>
-4- <i>Remarks:</i> <del>If this constructor is instantiated with a
pointer type or reference type for the template argument <tt>D</tt>,
the program is ill-formed.</del> <ins>If <tt>is_pointer_v&lt;deleter_type&gt;</tt> is <tt>true</tt> or
<tt>is_default_constructible_v&lt;deleter_type&gt;</tt> is
<tt>false</tt>, this constructor shall not participate in overload
resolution.</ins>
</p>
</blockquote>

<pre>
explicit unique_ptr(pointer p) noexcept;
</pre>
<blockquote>
<p>[&hellip;]</p>
<p>
-8- <i>Remarks:</i> <del>If this constructor is instantiated with a
pointer type or reference type for the template argument <tt>D</tt>,
the program is ill-formed.</del> <ins>If <tt>is_pointer_v&lt;deleter_type&gt;</tt> is <tt>true</tt> or
<tt>is_default_constructible_v&lt;deleter_type&gt;</tt> is
<tt>false</tt>, this constructor shall not participate in overload
resolution.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify the synopsis in  20.11.1.3 [unique.ptr.runtime] as follows:
</p>
<blockquote>
<pre>
[&hellip;]
constexpr unique_ptr(nullptr_t) noexcept<ins>;</ins><del> : unique_ptr() { }</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>
Modify 20.11.1.3.1 [unique.ptr.runtime.ctor] as follows:
</p>
<blockquote>

<pre>
template &lt;class U&gt; explicit unique_ptr(U p) noexcept;
</pre>
<blockquote>
<p><ins>
This constructor behaves the same as the constructor that takes a
pointer parameter in the primary template except that the following
constraints are added for it to participate in overload resolution
</ins></p>
<ul>
<li><p><ins>
<tt>U</tt> is the same type as <tt>pointer</tt>, or
</ins></p></li>
<li><p><ins>
<tt>pointer</tt> is the same type as <tt>element_type*</tt>,
<tt>U</tt> is a pointer type <tt>V*</tt>, and <tt>V(*)[]</tt> is
convertible to <tt>element_type(*)[]</tt>.
</ins></p></li>
</ul>
</blockquote>
<pre>
template &lt;class U&gt; unique_ptr(U p, <i>see below</i> d) noexcept;
template &lt;class U&gt; unique_ptr(U p, <i>see below</i> d) noexcept;
</pre>
<blockquote>
<p>
1 These constructors behave the same as the constructors that take a
pointer parameter in the primary template except that they shall not
participate in overload resolution unless either
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2802" href="p0625r0.html#2802">2802.</a> <tt>shared_ptr</tt> constructor requirements for a deleter</h3>
<p><b>Section:</b> 20.11.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 127</b>
<p/>
It should suffice for the deleter <tt>D</tt> to be nothrow move-constructible.
However, to avoid potentially leaking the pointer <tt>p</tt> if <tt>D</tt> is also 
copy-constructible when copying the argument by-value, we should continue 
to require the copy constructor does not throw if <tt>D</tt> 
is <tt>CopyConstructible</tt>.
</p>
<p>
Proposed change:
<p/>
Relax the requirement the <tt>D</tt> be <tt>CopyConstructible</tt> 
to simply require that <tt>D</tt> be <tt>MoveConstructible</tt>.  
Clarify the requirement that construction of any of the arguments 
passed by-value shall not throw exceptions. Note that we have library-wide 
wording in clause 17 that says any type supported by the 
library, not just this delete, shall not throw exceptions from its destructor, 
so that wording could be editorially removed. Similarly, the requirements 
that <tt>A</tt> shall be an allocator satisfy that neither 
constructor nor destructor for <tt>A</tt> can throw.
</p>

<p><i>[2016-12-16, Issues Telecon]</i></p>

<p>Priority 3; Jonathan to provide wording.</p>

<p><i>[2017-02-23, Jonathan comments and suggests wording]</i></p>

<p>
I don't think the Clause 17 wording in [res.on.functions] is
sufficient to require that the delete expression is well-formed. A
class-specific deallocation function ([class.free]) would not be
covered by [res.on.functions] and so could throw:
</p>
<blockquote><pre>
struct Y { void operator delete(void*) noexcept(false) { throw 1; } };
</pre></blockquote>

<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 [util.smartptr.shared.const] as indicated:</p>
<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> <tt>D</tt> shall be <tt><del>Copy</del><ins>Move</ins>Constructible</tt> and <del>such</del> 
construction <ins>of <tt>d</tt> and a deleter of type <tt>D</tt> initialized with <tt>std::move(d)</tt></ins> shall 
not throw exceptions. <del>The destructor of <tt>D</tt> shall not throw exceptions.</del> The expression <tt>d(p)</tt> 
shall be well formed, shall have well<del> </del><ins>-</ins>defined behavior, and shall not throw exceptions. <tt>A</tt> 
shall be an allocator (17.5.3.5). <del>The copy constructor and destructor of <tt>A</tt> shall not throw exceptions.</del> 
When <tt>T</tt> is [&hellip;].
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2806" href="p0625r0.html#2806">2806.</a> Base class of <tt>bad_optional_access</tt></h3>
<p><b>Section:</b> 20.6.5 [optional.bad.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses GB 49</b>
</p>
<p>
<a href="https://issues.isocpp.org/show_bug.cgi?id=72">LEWG 72</a> suggests 
changing the base class of <tt>std::bad_optional_access</tt>, but the issue 
appears to have been forgotten.
</p>
<p>
Proposed change:
<p/>
Address LEWG issue 72, either changing it for C++17 or closing the issue.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 1; Marshall provides wording</p>
<p>Not the most important bug in the world, but we can't change it after we ship C++17, hence the P1.</p>

<p><i>[Kona 2017-03-01]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>Changes are relative to N4604.</p>
<p>In the class synopsis in 20.6.5 [optional.bad_optional_access] change:</p>
<blockquote>
<pre>
    class bad_optional_access : public <ins>exception</ins><del>logic_error</del> {
</pre>
</blockquote>





<hr>
<h3><a name="2807" href="p0625r0.html#2807">2807.</a> <tt>std::invoke</tt> should use <tt>std::is_nothrow_callable</tt></h3>
<p><b>Section:</b> 20.14.4 [func.invoke] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#func.invoke">active issues</a> in [func.invoke].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#func.invoke">issues</a> in [func.invoke].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses GB 53</b>
</p>
<p>
<tt>std::invoke</tt> can be made trivially <tt>noexcept</tt> 
using the new <tt>std::is_nothrow_callable</tt> trait:
</p>
<p>
Proposed change:
<p/>
Add the exception specifier <tt>noexcept(is_nothrow_callable_v&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;)</tt> 
to <tt>std::invoke</tt>.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3</p>

<p><i>[2017-02-28, Daniel comments and provides wording]</i></p>

<p>
The following wording <em>assumes</em> that D0604R0 would be accepted, therefore uses <tt>is_nothrow_invocable_v</tt>
instead of the suggested current trait <tt>is_nothrow_callable_v</tt>
</p>

<p><i>[Kona 2017-03-01]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change 20.14.1 [functional.syn], header <tt>&lt;functional&gt;</tt> synopsis, as indicated:</p>

<blockquote><pre>
<i>// 20.14.4, invoke</i>
template &lt;class F, class... Args&gt;
  <ins>invoke_result_t&lt;F, Args...&gt;</ins><del>result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;</del> invoke(F&amp;&amp; f, Args&amp;&amp;... args) <ins>noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;)</ins>;
</pre></blockquote>
</li>

<li><p>Change 20.14.4 [func.invoke] as indicated:</p>

<blockquote><pre>
template &lt;class F, class... Args&gt;
  <ins>invoke_result_t&lt;F, Args...&gt;</ins><del>result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;</del> invoke(F&amp;&amp; f, Args&amp;&amp;... args) <ins>noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;)</ins>;</pre></blockquote>
</li>

</ol>





<hr>
<h3><a name="2857" href="p0625r0.html#2857">2857.</a> <tt>{variant,optional,any}::emplace</tt> should return the constructed value</h3>
<p><b>Section:</b> 20.6 [optional], 20.7 [variant], 20.8 [any] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2017-01-25 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#optional">issues</a> in [optional].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When you want to continue operate on the new contained object constructed by <tt>emplace</tt>, you probably 
don't want to go through the type-safe machinery again.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 1; send to LEWG.</p>

<p><i>[Kona 2017-03-02]</i></p>

<p>Accepted as Immediate because P1.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Update the following signatures in 20.6.3 [optional.optional], class template <tt>optional</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.6.3.3 [optional.assign], assignment</i>
[&hellip;]
template &lt;class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;...);
template &lt;class U, class... Args&gt;
  <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.6.3.3 [optional.assign] as indicated:</p>
<blockquote>
<pre>
template &lt;class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-27- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-28- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
</p>
</blockquote>
<pre>
template &lt;class U, class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-31- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-32- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify the following signatures in 20.7.3 [variant.variant], class template <tt>variant</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.7.3.4 [variant.mod], modifiers</i>
template &lt;class T, class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;...);
template &lt;class T, class U, class... Args&gt;
  <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
template &lt;size_t I, class... Args&gt; <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(Args&amp;&amp;...);
template &lt;size_t I, class U, class... Args&gt;
  <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.7.3.4 [variant.mod] as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt><ins>return</ins> emplace&lt;<i>I</i>&gt;(std::forward&lt;Args&gt;(args)...)<ins>;</ins></tt> 
where <tt><i>I</i></tt> is the zero-based index of <tt>T</tt> in <tt>Types...</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class U, class... Args&gt;
  <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to <tt><ins>return</ins> emplace&lt;<i>I</i>&gt;(il, std::forward&lt;Args&gt;(args)...)<ins>;</ins></tt> 
where <tt><i>I</i></tt> is the zero-based index of <tt>T</tt> in <tt>Types...</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;size_t I, class... Args&gt; <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Postconditions:</i> <tt>index()</tt> is <tt>I</tt>.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-8- <i>Throws:</i> Any exception thrown during the initialization of the contained value.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;size_t I, class U, class... Args&gt;
  <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-12- <i>Postconditions:</i> <tt>index()</tt> is <tt>I</tt>.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-13- <i>Throws:</i> Any exception thrown during the initialization of the contained value.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify the following signatures in 20.8.3 [any.class], class <tt>any</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>// 20.8.3.3 [any.modifiers], modifiers</i>
template &lt;class ValueType, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(Args&amp;&amp; ...);
template &lt;class ValueType, class U, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.8.3.3 [any.modifiers] as indicated:</p>
<blockquote>
<pre>
template &lt;class ValueType, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-5- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class ValueType, class U, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-11- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2861" href="p0625r0.html#2861">2861.</a> <tt>basic_string</tt> should require that <tt>charT</tt> match <tt>traits::char_type</tt></h3>
<p><b>Section:</b> 21.3.2.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-02 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#string.require">active issues</a> in [string.require].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 145</b></p>

<p>There is no requirement that <tt>traits::char_type</tt> is <tt>charT</tt>, although there is a requirement that 
<tt>allocator::value_type</tt> is <tt>charT</tt>. This means that it might be difficult to honour both methods returning reference 
(such as <tt>operator[]</tt>) and <tt>charT&amp;</tt> (like <tt>front</tt>/<tt>back</tt>) when traits has a surprising 
<tt>char_type</tt>. It seems that the allocator should <em>not</em> rebind in such cases, making the reference-returning 
signatures the problematic ones.</p>

<p>Suggested resolution: Add a requirement that <tt>is_same_v&lt;typename traits::char_type, charT&gt;</tt> is true, and simplify so that value_type is just an alias for <tt>charT</tt>.</p>

<p><i>[2017-02-02 Marshall adds]</i></p>

<p>In [string.require]/3, there's already a note that the types shall be the same. In [string.view.template]/1, it says "In every specialization <tt>basic_string_view&lt;charT, traits, Allocator&gt;</tt>, the type <tt>traits</tt> shall satisfy the character traits requirements (21.2), and the type <tt>traits::char_type</tt> shall name the same type as <tt>charT</tt>".</p>

<p><i>[Kona 2017-02-28]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>Changes are based off of <a href="http://wg21.link/n4618">N4618</a></p>

<ol>
<li><p>Modify [basic.string] as indicated (in the synopsis):</p>
<blockquote><pre>
class basic_string {
public:
// <i>types:</i>
  using traits_type      = traits;
  using value_type       = <ins>charT</ins><del>typename traits::char_type</del>;
  using allocator_type   = Allocator
</pre></blockquote>
</li>

<li>
<p>Change [string.require]/3 as indicated:</p>
<p>-3- In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, the type <tt>allocator_traits&lt;Allocator&gt;::value_type</tt> shall name the same type as <tt>charT</tt>. Every object of type <tt>basic_string&lt;charT, traits, Allocator&gt;</tt> shall use an object of type <tt>Allocator</tt> to allocate and free storage for the contained <tt>charT</tt> objects as needed. The <tt>Allocator</tt> object used shall be obtained as described in 23.2.1. <del>[ Note: </del>In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, <ins>the type <tt>traits</tt> shall satisfy the character traits requirements (21.2), and </ins> the type <tt>traits::char_type</tt> shall <ins>name</ins><del>be</del> the same type as <tt>charT</tt><del>; see 21.2. — end note ]</del>
</p>
</li>
</ol>






<hr>
<h3><a name="2866" href="p0625r0.html#2866">2866.</a> Incorrect derived classes constraints</h3>
<p><b>Section:</b> 17.5.5.11 [derivation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB 36</b></p>

<p>For bullet (3.2), no base classes are described as non-virtual. Rather, base 
classes are not specified as virtual, a subtly different negative.</p>

<p>
Proposed change:
</p>
<p>
Rewrite bullet 3.2:
</p>
<blockquote>
<p>
Every base class not specified as virtual shall not be virtual;
</p>
</blockquote>

<p><i>[Kona 2017-03-01]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>

<li><p>Modify 17.5.5.11 [derivation] paragraph 3.2 as indicated:</p>
<blockquote>
<del>Every base class described as non-<tt>virtual</tt> shall not be virtual;</del>
<ins>Every base class not specified as <tt>virtual</tt> shall not be virtual;</ins>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2868" href="p0625r0.html#2868">2868.</a> Missing specification of <tt>bad_any_cast::what()</tt></h3>
<p><b>Section:</b> 20.8.2 [any.bad_any_cast] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB 54</b></p>

<p>There is no specification for <tt>bad_any_cast.what</tt>.</p>

<p>
Proposed change:
</p>
<p>
Add a paragraphs:
</p>
<blockquote><pre>
const char* what() const noexcept override;
</pre>
<blockquote>
<p>
<i>Returns:</i> An implementation-defined NTBS. 
<p/>
<i>Remarks:</i> The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion and 
display as a <tt>wstring</tt> (21.3, 22.4.1.4).
</p>
</blockquote>
</blockquote>

<p><i>[Kona 2017-03-01]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Insert the following series of paragraphs to 20.8.2 [any.bad_any_cast] as indicated:</p>

<blockquote><pre>
<ins>const char* what() const noexcept override;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns:</i> An implementation-defined NTBS.</ins> 
<p/>
<ins>-?- <i>Remarks:</i> The message may be a null-terminated multibyte string (17.4.2.1.5.2 [multibyte.strings]), 
suitable for conversion and display as a <tt>wstring</tt> (21.3 [string.classes], 
22.4.1.4 [locale.codecvt]).</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2872" href="p0625r0.html#2872">2872.</a> Add definition for direct-non-list-initialization</h3>
<p><b>Section:</b> 17.3 [definitions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 107</b></p>

<p>The term 'direct non-list initialization' needs to be 
incorporated from the Library Fundamentals TS, as 
several components added to C++17 rely on this 
definition.</p>

<p>
Proposed change:
</p>
<p>
Add:
</p>
<blockquote>
<p>
17.3.X direct-non-list-initialization [defns.direct-non-list-init]
<p/>
A direct-initialization that is not list-initialization.
</p>
</blockquote>

<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Add the following to 17.3 [definitions] as indicated:</p>
<blockquote>
<p>
<ins><b>17.3.? direct-non-list-initialization [defns.direct-non-list-init]</b></ins>
<p/>
<ins>A direct-initialization that is not list-initialization.</ins>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2873" href="p0625r0.html#2873">2873.</a> Add <tt>noexcept</tt> to several <tt>shared_ptr</tt> related functions</h3>
<p><b>Section:</b> 20.11.2.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 124</b></p>

<p>Several <tt>shared_ptr</tt> related functions have wide 
contracts and cannot throw, so should be marked 
unconditionally <tt>noexcept</tt>.</p>

<p>
Proposed change:
</p>
<p>
Add <tt>noexcept</tt> to:
</p>
<blockquote>
<pre>
template&lt;class U&gt; 
bool 
shared_ptr::owner_before(shared_ptr&lt;U&gt; const&amp; b) const <ins>noexcept</ins>;
 
template&lt;class U&gt; 
bool 
shared_ptr::owner_before(weak_ptr&lt;U&gt; const&amp; b) const <ins>noexcept</ins>;

template&lt;class U&gt; 
bool  
weak_ptr::owner_before(shared_ptr&lt;U&gt; const&amp; b) const <ins>noexcept</ins>; 

template&lt;class U&gt; 
bool
weak_ptr::owner_before(weak_ptr&lt;U&gt; const&amp; b) const <ins>noexcept</ins>;
 
bool owner_less::operator()(A,B) const <ins>noexcept</ins>; <i>// all versions</i>
</pre>
</blockquote>

<p><i>[2017-02-20, Marshall adds wording]</i></p>


<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>

<li><p>Modify 20.11.2.2 [util.smartptr.shared] as indicated:</p>
<blockquote>
<pre>
  template&lt;class U&gt; bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
  template&lt;class U&gt; bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Modify 20.11.2.2.5 [util.smartptr.shared.obs] as indicated: </p>
<blockquote>
<pre>
template&lt;class U&gt; bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
template&lt;class U&gt; bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Modify 20.11.2.4 [util.smartptr.ownerless] as indicated:</p>
<blockquote>
<pre>
template&lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt; {
   bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
};

template&lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt; {
   bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
};

template&lt;&gt; struct owner_less&lt;void&gt; {
   template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   using is_transparent = <i>unspecified</i>;
};
</pre>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2874" href="p0625r0.html#2874">2874.</a> Constructor <tt>shared_ptr::shared_ptr(Y*)</tt> should be constrained</h3>
<p><b>Section:</b> 20.11.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 125</b></p>

<p>Paragraph 4: This constructor should not participate in overload 
resolution unless the <i>Requires</i> clause is satisfied. Note that this would 
therefore apply to some assignment operator and <tt>reset</tt> overloads, via 
<i>Effects:</i> equivalent to some code wording.</p>

<p>
Proposed change:
</p>
<p>
Add a <i>Remarks:</i> clause to constrain this constructor 
not to participate in overload resolution unless the <i>Requires</i>
clause is satisfied.
</p>

<p><i>[2017-02-23, Jonathan provides wording]</i></p>

 
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 [util.smartptr.shared.const] as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note:</i> This also adds a hyphen to "well defined"]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> <tt>Y</tt> shall be a complete type. The expression <tt>delete[] p</tt>, when <tt>T</tt> 
is an array type, or <tt>delete p</tt>, when <tt>T</tt> is not an array type, <del>shall be well formed,</del> shall 
have well<del> </del><ins>-</ins>defined behavior, and shall not throw exceptions. <del>When <tt>T</tt> is <tt>U[N]</tt>, 
<tt>Y(*)[N]</tt> shall be convertible to <tt>T*</tt>; when <tt>T</tt> is <tt>U[]</tt>, <tt>Y(*)[]</tt> shall be convertible to 
<tt>T*</tt>; otherwise, <tt>Y*</tt> shall be convertible to <tt>T*</tt>.</del>
<p/>
-5- <i>Effects:</i> [&hellip;]
<p/>
-6- <i>Postconditions:</i> [&hellip;]
<p/>
-7- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> When <tt>T</tt> is an array type, this constructor shall not
participate in overload resolution unless the expression <tt>delete[] p</tt> is
well-formed and either <tt>T</tt> is <tt>U[N]</tt> and <tt>Y(*)[N]</tt> is convertible to <tt>T*</tt>, or
<tt>Y(*)[]</tt> is convertible to <tt>T*</tt>. When <tt>T</tt> is not an array type, this
constructor shall not participate in overload resolution unless the
expression <tt>delete p</tt> is well-formed and <tt>Y*</tt> is convertible to <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>

<p><i>[Kona 2017-02-27: Jonathan updates wording after LWG review]</i></p>


<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 [util.smartptr.shared.const] as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note:</i> This also adds a hyphen to "well defined"]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> <tt>Y</tt> shall be a complete type. The expression <tt>delete[] p</tt>, when <tt>T</tt> 
is an array type, or <tt>delete p</tt>, when <tt>T</tt> is not an array type, <del>shall be well formed,</del> shall 
have well<del> </del><ins>-</ins>defined behavior, and shall not throw exceptions. <del>When <tt>T</tt> is <tt>U[N]</tt>, 
<tt>Y(*)[N]</tt> shall be convertible to <tt>T*</tt>; when <tt>T</tt> is <tt>U[]</tt>, <tt>Y(*)[]</tt> shall be convertible to 
<tt>T*</tt>; otherwise, <tt>Y*</tt> shall be convertible to <tt>T*</tt>.</del>
<p/>
-5- <i>Effects:</i> [&hellip;]
<p/>
-6- <i>Postconditions:</i> [&hellip;]
<p/>
-7- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> When <tt>T</tt> is an array type, this constructor shall not
participate in overload resolution unless the expression <tt>delete[] p</tt> is
well-formed and either <tt>T</tt> is <tt>U[N]</tt> and <tt>Y(*)[N]</tt> is convertible to <tt>T*</tt>, or
<tt>T</tt> is <tt>U[]</tt> and <tt>Y(*)[]</tt> is convertible to <tt>T*</tt>. When <tt>T</tt> is not an array type, this
constructor shall not participate in overload resolution unless the
expression <tt>delete p</tt> is well-formed and <tt>Y*</tt> is convertible to <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2875" href="p0625r0.html#2875">2875.</a> <tt>shared_ptr::shared_ptr(Y*, D, [&hellip;])</tt> constructors should be constrained</h3>
<p><b>Section:</b> 20.11.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 126</b></p>

<p>Paragraph 8: This constructor should not participate in overload 
resolution unless the <i>Requires</i> clause is satisfied.
Note that this would therefore apply to some assignment operator and 
<tt>reset</tt> overloads, via <i>Effects:</i> equivalent to some code wording.</p>

<p>
Proposed change:
</p>
<p>
Add a <i>Remarks:</i> clause to constrain this constructor 
not to participate in overload resolution unless the <i>Requires</i>
clause is satisfied.
</p>

<p><i>[2017-02 pre-Kona]</i></p>

<p>
See US 125: LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#2874">2874</a>.
</p>

<p><i>[2017-02-23, Jonathan provides wording]</i></p>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 [util.smartptr.shared.const] as indicated:</p>

<ol style="list-style-type:upper-alpha">
<li><p>If the proposed resolution of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#2802">2802</a> <em>has been accepted</em> modify p8 as shown:</p>

<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> <del><tt>D</tt> shall be <tt>MoveConstructible</tt> and c</del><ins>C</ins>onstruction of 
<tt>d</tt> and a deleter of type 
<tt>D</tt> initialized with <tt>std::move(d)</tt> shall not throw exceptions. The expression <tt>d(p)</tt> 
<del>shall be well formed,</del> shall have well-defined behavior, and shall not throw exceptions. <tt>A</tt> 
shall be an allocator (17.5.3.5). <del>When <tt>T</tt> is <tt>U[N]</tt>, <tt>Y(*)[N]</tt> shall be convertible to <tt>T*</tt>;
when <tt>T</tt> is <tt>U[]</tt>, <tt>Y(*)[]</tt> shall be convertible to <tt>T*</tt>; otherwise, <tt>Y*</tt> shall 
be convertible to <tt>T*</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>If the proposed resolution of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#2802">2802</a> <em>has not been accepted</em> modify p8 as shown:</p>

<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> <del><tt>D</tt> shall be <tt>CopyConstructible</tt> and such 
c</del><ins>C</ins>onstruction <ins>of <tt>d</tt> and a copy of <tt>d</tt></ins> shall not throw exceptions. 
The destructor of <tt>D</tt> shall not throw exceptions. The expression <tt>d(p)</tt> 
<del>shall be well formed,</del> shall have well defined behavior, and shall not throw exceptions. <tt>A</tt> 
shall be an allocator (17.5.3.5). The copy constructor and destructor of <tt>A</tt> shall not throw exceptions. 
<del>When <tt>T</tt> is <tt>U[N]</tt>, <tt>Y(*)[N]</tt> shall be convertible to <tt>T*</tt>;
when <tt>T</tt> is <tt>U[]</tt>, <tt>Y(*)[]</tt> shall be convertible to <tt>T*</tt>; otherwise, <tt>Y*</tt> shall 
be convertible to <tt>T*</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>
</ol>

<ol>
<li><p>In either case, add a <i>Remarks</i> paragraph after p11:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> If LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#2802">2802</a> is <em>not</em> accepted, replace
<tt>is_move_constructible_v</tt> with <tt>is_copy_constructible_v</tt>.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-11- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> When <tt>T</tt> is an array type, this constructor shall not
participate in overload resolution unless <tt>is_move_constructible_v&lt;D&gt;</tt>
is <tt>true</tt>, the expression <tt>d(p)</tt> is well-formed, and either <tt>T</tt> 
is <tt>U[N]</tt> and <tt>Y(*)[N]</tt> is convertible to <tt>T*</tt>, or
<tt>Y(*)[]</tt> is convertible to <tt>T*</tt>. When <tt>T</tt> is not an array type, this
constructor shall not participate in overload resolution unless
<tt>is_move_constructible_v&lt;D&gt;</tt> is <tt>true</tt>, the
expression <tt>d(p)</tt> is well-formed, and <tt>Y*</tt> is convertible to <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>

<p><i>[Kona 2017-02-27: Jonathan updates wording after LWG review]</i></p>


<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>
as modified by the proposed resolution of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#2802">2802</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 [util.smartptr.shared.const] as indicated:</p>

<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> <del><tt>D</tt> shall be <tt>MoveConstructible</tt> and c</del><ins>C</ins>onstruction of 
<tt>d</tt> and a deleter of type 
<tt>D</tt> initialized with <tt>std::move(d)</tt> shall not throw exceptions. The expression <tt>d(p)</tt> 
<del>shall be well formed,</del> shall have well-defined behavior, and shall not throw exceptions. <tt>A</tt> 
shall be an allocator (17.5.3.5). <del>When <tt>T</tt> is <tt>U[N]</tt>, <tt>Y(*)[N]</tt> shall be convertible to <tt>T*</tt>;
when <tt>T</tt> is <tt>U[]</tt>, <tt>Y(*)[]</tt> shall be convertible to <tt>T*</tt>; otherwise, <tt>Y*</tt> shall 
be convertible to <tt>T*</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Add a <i>Remarks</i> paragraph after p11:</p>

<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-11- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> When <tt>T</tt> is an array type, this constructor shall not
participate in overload resolution unless <tt>is_move_constructible_v&lt;D&gt;</tt>
is <tt>true</tt>, the expression <tt>d(p)</tt> is well-formed, and either <tt>T</tt> 
is <tt>U[N]</tt> and <tt>Y(*)[N]</tt> is convertible to <tt>T*</tt>, or <tt>T</tt> 
is <tt>U[]</tt> and <tt>Y(*)[]</tt> is convertible to <tt>T*</tt>. When <tt>T</tt> is not an array type, this
constructor shall not participate in overload resolution unless
<tt>is_move_constructible_v&lt;D&gt;</tt> is <tt>true</tt>, the
expression <tt>d(p)</tt> is well-formed, and <tt>Y*</tt> is convertible to <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="2876" href="p0625r0.html#2876">2876.</a> <tt>shared_ptr::shared_ptr(const weak_ptr&lt;Y&gt;&amp;)</tt> constructor should be constrained</h3>
<p><b>Section:</b> 20.11.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 129</b></p>

<p>Paragraph 22: This constructor should not participate in overload 
resolution unless the requirements are satisfied, in 
order to give correct results from the <tt>is_constructible</tt> trait.</p>

<p>
Proposed change:
</p>
<p>
Add a <i>Remarks:</i> clause to constrain this constructor 
not to participate in overload resolution unless the 
<i>Requires</i> clause is satisfied.
</p>

<p><i>[2017-02-23, Jonathan provides wording]</i></p>


<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 [util.smartptr.shared.const] as indicated:</p>
<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>Y*</tt> shall be compatible with <tt>T*</tt>.</del>
<p/>
[&hellip;]
<p/>
-25- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>Y*</tt> is compatible with <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2878" href="p0625r0.html#2878">2878.</a> Missing <tt>DefaultConstructible</tt> requirement for <tt>istream_iterator</tt> default constructor</h3>
<p><b>Section:</b> 24.6.1.1 [istream.iterator.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#istream.iterator.cons">active issues</a> in [istream.iterator.cons].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#istream.iterator.cons">issues</a> in [istream.iterator.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 153</b></p>

<p><tt>istream_iterator</tt> default constructor requires a <tt>DefaultConstructible T</tt>.</p>

<p>
Proposed change:
</p>
<p>
Add a new p1:
</p>
<blockquote><p>
<i>Requires:</i> <tt>T</tt> is <tt>DefaultConstructible</tt>.
</p></blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 24.6.1.1 [istream.iterator.cons] as indicated:</p>
<blockquote>
<pre>
<i>see below</i> istream_iterator();
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <tt>T</tt> is <tt>DefaultConstructible</tt>.</ins>
<p/>
-1- <i>Effects:</i> Constructs the end-of-stream iterator. If <tt>is_trivially_default_constructible_v&lt;T&gt;</tt> is
<tt>true</tt>, then this constructor is a <tt>constexpr</tt> constructor.
<p/>
-2- <i>Postconditions:</i> <tt>in_stream == 0</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>

<p><i>[Kona 2017-02-28: Jonathan provides updated wording as requested by LWG.]</i></p>


<p><i>[Kona 2017-03-02]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 24.6.1 [istream.iterator] as indicated:</p>
<blockquote>
<p>
-1- 
The class template <code>istream_iterator</code> is an input iterator (24.2.3)
that reads (using <code>operator>></code>) successive elements from the input
stream for which it was constructed. After it is constructed, and every time
<code>++</code> is used, the iterator reads and stores a value of
<code>T</code>. If the iterator fails to read and store a value of
<code>T</code> (<code>fail()</code> on the stream returns <code>true</code>),
the iterator becomes equal to the end-of-stream iterator value. The constructor
with no arguments <code>istream_iterator()</code> always constructs an
end-of-stream input iterator object, which is the only legitimate iterator to
be used for the end condition. The result of <code>operator*</code> on an
end-of-stream iterator is not defined. For any other iterator value a
<code>const T&amp;</code> is returned. The result of <code>operator-&gt;</code>
on an end-of-stream iterator is not defined. For any other iterator value a
<code>const T*</code> is returned. The behavior of a program that applies
<code>operator++()</code> to an end-of-stream iterator is undefined. It is
impossible to store things into istream iterators.
<ins>The type <code>T</code> shall meet the <code>DefaultConstructible</code>,
<code>CopyConstructible</code>, and <code>CopyAssignable</code> requirements.</ins>
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2890" href="p0625r0.html#2890">2890.</a> The definition of 'object state' applies only to class types</h3>
<p><b>Section:</b> 17.3.16 [defns.obj.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#defns.obj.state">issues</a> in [defns.obj.state].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 30</b>

<p>The definition of 'object state' applies only to class types, implying that fundamental types and arrays do not have this 
property.</p>
<p>Proposed change: Replacing "an object state" with "a value of an object" in 17.3.25 [defns.valid] and dropping the 
definition of "object state" in 17.3.16 [defns.obj.state].</p>

<p><i>[2017-02-26, Scott Schurr provides wording]</i></p>


<p><i>[Kona 2017-03-01]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>
<ol>
<li><p>Modify 17.3.16 [defns.obj.state] as indicated:</p>

<blockquote>
<p>
<del><b>17.3.16 [defns.obj.state]</b></del>
<p/>
<del><b>object state</b></del>
<p/>
<del>the current value of all non-static class members of an object (9.2)
[<i>Note:</i> The state of an object can be obtained by using one or more observer functions. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

<li><p>Modify 17.3.25 [defns.valid] as indicated:</p>

<blockquote>
<p>
<b>17.3.25 [defns.valid]</b>
<p/>
<b>valid but unspecified state</b>
<p/>
<del>an object state</del><ins>a value of an object</ins> that is not specified except that the object's invariants are 
met and operations on the object behave as specified for its type
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2894" href="p0625r0.html#2894">2894.</a> The function template <tt>std::apply()</tt> is required to be <tt>constexpr</tt>, but <tt>std::invoke()</tt> isn't</h3>
<p><b>Section:</b> 20.14.4 [func.invoke] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#func.invoke">active issues</a> in [func.invoke].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#func.invoke">issues</a> in [func.invoke].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 51</b>

<p>The function template <tt>std::apply()</tt> in 20.5.3.5 [tuple.apply] is required to be <tt>constexpr</tt>, 
but <tt>std::invoke()</tt> in 20.14.4 [func.invoke] isn't. The most sensible implementation of <tt>apply_impl()</tt> 
is exactly equivalent to <tt>std::invoke()</tt>, so this requires implementations to have a <tt>constexpr</tt> version of 
<tt>invoke()</tt> for internal use, and the public API <tt>std::invoke</tt>, which must not be <tt>constexpr</tt> even 
though it is probably implemented in terms of the internal version.</p>
<p>Proposed change: Add <tt>constexpr</tt> to <tt>std::invoke</tt>.</p>

<p><i>[2017-02-20, Marshall adds wording]</i></p>


<p><i>[Kona 2017-03-01]</i></p>

<p>We think this needs CWG 1581 to work; accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 20.14.4 [func.invoke] as indicated:</p>
<blockquote>
<pre>
template &lt;class F, class... Args&gt;
     <ins>constexpr</ins> result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2900" href="p0625r0.html#2900">2900.</a> The copy and move constructors of <tt>optional</tt> are not <tt>constexpr</tt></h3>
<p><b>Section:</b> 20.6.3 [optional.optional] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#optional.optional">active issues</a> in [optional.optional].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#optional.optional">issues</a> in [optional.optional].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 111</b>

<p>The copy and move constructors of <tt>optional</tt> are not <tt>constexpr</tt>. However, the constructors taking a 
<tt>const T&amp;</tt> or <tt>T&amp;&amp;</tt> are <tt>constexpr</tt>, and there is a precedent for having a <tt>constexpr</tt> 
copy constructor in 26.5.2 [complex]. The defaulted copy and move constructors of <tt>pair</tt> and <tt>tuple</tt> 
are also conditionally <tt>constexpr</tt> (see 20.4.2 [pairs.pair] p2 and 20.5.2.1 [tuple.cnstr] p2).</p>
<p>A strong motivating use-case is <tt>constexpr</tt> functions returning optional values. This issue was discovered while 
working on a library making heavy use of such.</p>

<p>Proposed change: Add constexpr to: </p>
<blockquote><pre>
optional(const optional &amp;);
optional(optional &amp;&amp;) noexcept(<i>see below</i>);
</pre></blockquote>

<p><i>[2017-02-23, Casey comments and suggests wording]</i></p>

<p>
This issue corresponds to NB comment US 111, which requests that the move and copy constructors of 
<tt>std::optional</tt> be declared <tt>constexpr</tt>. The PR simply suggests adding the <tt>constexpr</tt> 
specifier to the declarations of the constructors. The PR fails to specify the most important thing &mdash; 
and this has been a failing of Library in general &mdash; under what conditions is the thing that we've 
declared constexpr actually expected to be usable in constant expression context? (I think the proper 
standardese here is "under what conditions is the full expression of an initialization that would invoke 
these constructors a constant subexpression?")
<p/>
It is, I believe, well-known that conforming implementations of <tt>optional&lt;T&gt;</tt> must store a <tt>T</tt> 
in a union to provide constexpr constructors that either do [<tt>optional(T const&amp;)</tt>] or do not 
[<tt>optional()</tt>] initialize the contained <tt>T</tt>. A general implementation of <tt>optional</tt>'s 
copy/move constructors must statically choose which union member, if any, to activate in each constructor. 
Since there is no way to change the active member of a union in a constant expression, and a constructor must 
<em>statically</em> choose a union member to activate (i.e., without being affected by the runtime state of the 
copy/move constructor's argument) it's not possible to implement a <em>general</em> constexpr copy/move constructor 
for <tt>optional</tt>.
<p/>
It is, however, possible to copy/move construct a trivially copy constructible/trivially move constructible union 
in <tt>constexpr</tt> context, which effectively copies the union's object representation, resulting in a union 
whose active member is the same as the source union's. Indeed, at least two major implementations of <tt>optional</tt> 
(MSVC and libc++) already provide that behavior as a conforming optimization when <tt>T</tt> is a trivially 
copyable type. If we are to declare <tt>optional&lt;T&gt;</tt>'s copy and move constructors <tt>constexpr</tt>, 
we should additionally specify that those constructors are only required to have the "constexpr mojo" when <tt>T</tt> 
is trivially copyable. (Note that I suggest "trivially copyable" here rather than "trivially copy constructible or 
trivially move constructible" since the simpler requirement is simpler to implement, and I don't believe the more 
complicated requirement provides any additional benefit: I've never seen a trivially copy constructible or 
trivially move constructible type outside of a test suite that was not also trivially copyable.)
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/N4618">N4618</a>.</p>
<ol>
<li><p>Edit 20.6.3 [optional.optional] as indicated:</p>
<blockquote><pre>
	<tt><ins>constexpr</ins> optional(const optional &amp;);</tt>
	<tt><ins>constexpr</ins> optional(optional &amp;&amp;) noexcept(<i>see below</i>);</tt>
</pre></blockquote>
</li>

<li><p>Edit 20.6.3.1 [optional.ctor] paragraph as indicated:</p>
<blockquote><pre>
	<tt><ins>constexpr</ins> optional(const optional &amp;);</tt>
</pre></blockquote>

<p>and </p>

<blockquote><pre>
	<tt><ins>constexpr</ins> optional(optional &amp;&amp;) noexcept(<i>see below</i>);</tt>
</pre></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-02-23, Marshall comments]</i></p>

<p>
This is related to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-defects.html#2745">2745</a>.
</p>

<p><i>[2017-02-28, Kona, Casey comments and improves wording]</i></p>

<p>
Amended PR per LWG discussion in Kona: replace the "is trivially copyable" requirement with the more specific 
<tt>is_trivially_copy/move_constructible&lt;T&gt;</tt>. LWG was concerned that <tt>tuple</tt> is a counter-example 
to the assumption that all three traits are equivalent for real-world types.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change the synopsis of class template <tt>optional</tt> in 20.6.3 [optional.optional] as follows:</p>

<blockquote><pre>
[&hellip;]
// 20.6.3.1, constructors
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
<ins>constexpr</ins> optional(const optional&amp;);
<ins>constexpr</ins> optional(optional&amp;&amp;) noexcept(<i>see below</i>);
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 20.6.3.1 [optional.ctor] as indicated:</p>
<blockquote><pre>
<ins>constexpr</ins> optional(const optional&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks:</i> This constructor shall be defined as deleted unless <tt>is_copy_constructible_v&lt;T&gt;</tt> 
is <tt>true</tt>. <ins>If <tt>T</tt> is a trivially copyable type, this constructor shall be a <tt>constexpr</tt> constructor.</ins>
</p>
</blockquote>
<pre>
<ins>constexpr</ins> optional(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>.
This constructor shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is
<tt>true</tt>. <ins>If <tt>T</tt> is a trivially copyable type, this constructor shall be a <tt>constexpr</tt> constructor.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>

</blockquote>
<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change the synopsis of class template <tt>optional</tt> in 20.6.3 [optional.optional] as follows:</p>

<blockquote><pre>
[&hellip;]
// 20.6.3.1, constructors
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
<ins>constexpr</ins> optional(const optional&amp;);
<ins>constexpr</ins> optional(optional&amp;&amp;) noexcept(<i>see below</i>);
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 20.6.3.1 [optional.ctor] as indicated:</p>
<blockquote><pre>
<ins>constexpr</ins> optional(const optional&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks:</i> This constructor shall be defined as deleted unless <tt>is_copy_constructible_v&lt;T&gt;</tt> 
is <tt>true</tt>. <ins>If <tt>is_trivially_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>, this constructor 
shall be a <tt>constexpr</tt> constructor.</ins>
</p>
</blockquote>
<pre>
<ins>constexpr</ins> optional(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>.
This constructor shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is
<tt>true</tt>. <ins>If <tt>is_trivially_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>, this constructor shall 
be a <tt>constexpr</tt> constructor.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>








<hr>
<h3><a name="2903" href="p0625r0.html#2903">2903.</a> The form of initialization for the emplace-constructors is not specified</h3>
<p><b>Section:</b> 20.7.3.1 [variant.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#variant.ctor">active issues</a> in [variant.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#variant.ctor">issues</a> in [variant.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 118</b>

<p>The form of initialization for the emplace-constructors is not specified. We are very clear to mandate "as if by direct 
non-list initialization" for each constructor in <tt>optional</tt>, so there is no ambiguity regarding parens vs. braces. 
That wording idiom should be followed by <tt>variant</tt>.</p>

<p>Proposed change: Insert the phrase "as if direct-non-list-initializing" at appropriate locations in paragraphs 19, 23, 27, and 31</p>

<p><i>[2017-02-20, Marshall adds wording]</i></p>

<p><i>[2017-02-27, Marshall adds wording to cover two more cases]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 19 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value <ins>as if direct-non-list-initializing an object</ins> of type 
<tt>T</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 23 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>T</tt> with the arguments <tt>il, std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 27 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>TI</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 31 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>TI</tt> with the arguments <tt>il, std::forward(args)...</tt>.
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[Kona 2017-02-28]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 19 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value <ins>as if direct-non-list-initializing an object</ins> of type 
<tt>T</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 23 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>T</tt> with the arguments <tt>il, std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 27 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>TI</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 [variant.ctor] paragraph 31 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>TI</tt> with the arguments <tt>il, std::forward(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.4 [variant.mod] paragraph 6 as indicated:</p>
<blockquote>
<i>Effects:</i> Destroys the currently contained value if <tt>valueless_by_exception()</tt> is false. 
Then <del>direct-</del>initializes the contained value as if 
<ins>direct-non-list-initializing</ins><del>constructing</del> a value of type <tt>TI</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.4 [variant.mod] paragraph 11 as indicated:</p>
<blockquote>
<i>Effects:</i> Destroys the currently contained value if <tt>valueless_by_exception()</tt> is false. 
Then <del>direct-</del>initializes the contained value as if 
<ins>direct-non-list-initializing</ins><del>constructing</del> a value of type <tt>TI</tt> with the arguments <tt>il, std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2904" href="p0625r0.html#2904">2904.</a> Make <tt>variant</tt> move-assignment more exception safe</h3>
<p><b>Section:</b> 20.7.3.3 [variant.assign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 119 and CH 7</b>

<p>The copy-assignment operator is very careful to not destroy the contained element until after a temporary has been constructed, 
which can be safely moved from. </p>
<p>This makes the <tt>valueless_by_exception</tt> state extremely rare, by design.</p>
<p>However, the same care and attention is not paid to the move-assignment operator, nor the assignment-from-deduced-value 
assignment template. This concern should be similarly important in these cases, especially the latter.</p>

<p>Proposed change: &mdash;</p>

<p><i>[2017-03-02, Kona, Casey comments and suggests wording]</i></p>

<p>
The wording below has been developed with <em>much</em> input from Tomasz.
</p>

<p><i>[Kona 2017-03-02]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>
<ol>
<li><p>Modify 20.7.3.3 [variant.assign] as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Presentation of para 9 immediately below has been split into individual bullets.]
</p>
</blockquote>

<blockquote>
<pre>
variant&amp; operator=(const variant&amp; rhs);
</pre>
<blockquote>
<p>
<ins><ins>Let <tt><i>j</i></tt> be <tt>rhs.index()</tt>.</ins></ins>
<p/>
-1- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If neither <tt>*this</tt> nor <tt>rhs</tt> holds a value, there is no effect. Otherwise,</p></li>
<li><p>(1.2) &mdash; if <tt>*this</tt> holds a value but <tt>rhs</tt> does not, destroys the value contained in 
<tt>*this</tt> and sets <tt>*this</tt> to not hold a value. Otherwise,</p></li>
<li><p>(1.3) &mdash; if <tt>index() == <ins><i>j</i></ins><del>rhs.index()</del></tt>, assigns the value contained in <tt>rhs</tt> to the value contained in 
<tt>*this</tt>. Otherwise,</p></li>
<li><p><ins>(1.?) &mdash; if <tt>is_nothrow_copy_constructible_v&lt;T<sub><i>j</i></sub>&gt; || 
!is_nothrow_move_constructible_v&lt;T<sub><i>j</i></sub>&gt;</tt> is <tt>true</tt>, equivalent to 
<tt>emplace&lt;<i>j</i>&gt;(get&lt;<i>j</i>&gt;(rhs))</tt>. Otherwise,</ins></p></li>
<li><p>(1.4) &mdash; <ins>equivalent to <tt>operator=(variant(rhs))</tt></ins><del>copies the value contained in <tt>rhs</tt> to 
a temporary, then destroys any value contained in 
<tt>*this</tt>. Sets <tt>*this</tt> to hold the same alternative index as <tt>rhs</tt> and initializes the value contained in 
<tt>*this</tt> as if direct-non-list-initializing an object of type <tt>T<sub><i>j</i></sub></tt> with 
<tt>std::forward&lt;T<sub><i>j</i></sub>&gt;(TMP)</tt>, with <tt>TMP</tt> being the temporary and <tt>j</tt> being 
<tt>rhs.index()</tt></del>.</p></li>
</ol>
<p>
-2- <i>Returns:</i> <tt>*this.</tt>
<p/>
-3- <i>Postconditions:</i> <tt>index() == rhs.index()</tt>.
<p/>
-4- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_copy_constructible_v&lt;T<sub><i>i</i></sub>&gt; <del>&amp;&amp; is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt;</del> 
&amp;&amp; is_copy_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
</p>
<ol style="list-style-type: none">
<li><p><del>(4.1) &mdash; If an exception is thrown during the call [&hellip;]</del></p></li>
<li><p><del>(4.2) &mdash; If an exception is thrown during the call [&hellip;]</del></p></li>
<li><p><del>(4.3) &mdash; If an exception is thrown during the call [&hellip;]</del></p></li>
</ol>

</blockquote>
<pre>
variant&amp; operator=(variant&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<ins><ins>Let <tt><i>j</i></tt> be <tt>rhs.index()</tt>.</ins></ins>
<p/>
-5- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; If neither <tt>*this</tt> nor <tt>rhs</tt> holds a value, there is no effect. Otherwise,</p></li>
<li><p>(5.2) &mdash; if <tt>*this</tt> holds a value but <tt>rhs</tt> does not, destroys the value contained in 
<tt>*this</tt> and sets <tt>*this</tt> to not hold a value. Otherwise,</p></li>
<li><p>(5.3) &mdash; if <tt>index() == <ins><i>j</i></ins><del>rhs.index()</del></tt>, assigns <tt>get&lt;<i>j</i>&gt;(std::move(rhs))</tt> 
to the value contained in <tt>*this</tt><del>, with <tt><i>j</i></tt> being <tt>index()</tt></del>. Otherwise,</p></li>
<li><p>(5.4) &mdash; <ins>equivalent to <tt>emplace&lt;<i>j</i>&gt;(get&lt;<i>j</i>&gt;(std::move(rhs)))</tt></ins><del>destroys any value contained in 
<tt>*this</tt>. Sets <tt>*this</tt> to hold the same alternative index as <tt>rhs</tt> and initializes the value contained 
in <tt>*this</tt> as if direct-non-list-initializing an object of type <tt>T<sub><i>j</i></sub></tt> with
<tt>get&lt;<i>j</i>&gt;(std::move(rhs))</tt> with <tt><i>j</i></tt> being <tt>rhs.index()</tt></del>.</p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class T&gt; variant&amp; operator=(T&amp;&amp; t) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-8- [&hellip;]
<p/>
-9- <i>Effects:</i> 
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If *this holds a <tt>T<sub><i>j</i></sub></tt>, assigns <tt>std::forward&lt;T&gt;(t)</tt> to the value 
contained in <tt>*this</tt>. Otherwise,</p></li>
<li><p><ins>(9.?) &mdash; if <tt>is_nothrow_constructible_v&lt;T<sub><i>j</i></sub>, T&gt; || 
!is_nothrow_move_constructible_v&lt;T<sub><i>j</i></sub>&gt;</tt> is <tt>true</tt>, equivalent to 
<tt>emplace&lt;<i>j</i>&gt;(std::forward&lt;T&gt;(t))</tt>. Otherwise,</ins></p></li>
<li><p>(9.3) &mdash; <ins>equivalent to <tt>operator=(variant(std::forward&lt;T&gt;(t)))</tt></ins><del>destroys any value contained in <tt>*this</tt>, sets <tt>*this</tt> to hold the alternative type 
<tt>T<sub><i>j</i></sub></tt> as selected by the imaginary function overload resolution described above, and direct-initializes 
the contained value as if direct-non-list-initializing it with <tt>std::forward&lt;T&gt;(t)</tt></del>.</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2905" href="p0625r0.html#2905">2905.</a> <tt>is_constructible_v&lt;unique_ptr&lt;P, D&gt;, P, D const &amp;&gt;</tt> should be false when 
<tt>D</tt> is not copy constructible</h3>
<p><b>Section:</b> 20.11.1.2.1 [unique.ptr.single.ctor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#unique.ptr.single.ctor">active issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 123</b>

<p><tt>is_constructible_v&lt;unique_ptr&lt;P, D&gt;, P, D const &amp;&gt;</tt> should be false when <tt>D</tt> is not 
copy constructible, and similarly for <tt>D&amp;&amp;</tt> when <tt>D</tt> is not move constructible. This could be 
achieved by the traditional 'does not participate in overload resolution' wording, or similar.</p>

<p>Proposed change: Add a <i>Remarks:</i> clause to constrain the appropriate constructors.</p>

<p><i>[2017-02-28, Jonathan comments and provides concrete wording]</i></p>


<p>
As well as addressing the NB comment, this attempts to make some further improvements to the current wording, which is a little strange.
It incorrectly uses "<code>d</code>" to mean the constructor argument that initializes the parameter <code>d</code>, and unnecessarily explains how overload resolution works for lvalues and rvalues.
It refers to the copy/move constructor of <code>D</code>, but the constructor that is selected to perform the initialization may not be a copy/move constructor (e.g. initializing a deleter object from an rvalue might use a copy constructor if there is no move constructor).
The condition "<code>d</code> shall be reference compatible with one of the constructors" is bogus: reference compatible is a property of two types, not a value and a constructor, and again is trying to talk about the argument not the parameter.
</p>

<p>
Note that we could replace the "see below" in the signatures and paragraphs 9, 10 and 11 by declaring the constructors as:
</p>

<blockquote><pre>
unique_ptr(pointer p, const D&amp; d) noexcept;
unique_ptr(pointer p, remove_reference_t&lt;D&gt;&amp;&amp; d) noexcept;
</pre></blockquote>

<p>
I think this produces the same signatures in all cases. I haven't proposed that here, it could be changed separately if desired.
</p>

<p><i>[Kona 2017-02-27]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>

<p>Modify [unique.ptr.single.ctor] paragraphs 9-11 as shown:</p>

<blockquote>
<pre>
unique_ptr(pointer p, <em>see belo</em>w d1) noexcept;
unique_ptr(pointer p, <em>see below</em> d2) noexcept;
</pre>

<p>-9- The signature of these constructors depends upon whether <code>D</code> is a reference type. If <code>D</code> is a non-reference
type <code>A</code>, then the signatures are</p>

<pre><code>  unique_ptr(pointer p, const A&amp; d) <ins>noexcept</ins>;
  unique_ptr(pointer p, A&amp;&amp; d) <ins>noexcept</ins>;
</code></pre>

<p>-10- If <code>D</code> is an lvalue reference type <code>A&amp;</code>, then the signatures are:</p>

<pre><code>  unique_ptr(pointer p, A&amp; d) <ins>noexcept</ins>;
  unique_ptr(pointer p, A&amp;&amp; d) <ins>= delete</ins>;
</code></pre>

<p>-11- If <code>D</code> is an lvalue reference type <code>const A&amp;</code>, then the signatures are:</p>

<pre><code>  unique_ptr(pointer p, const A&amp; d) <ins>noexcept</ins>;
  unique_ptr(pointer p, const A&amp;&amp; d) <ins>= delete</ins>;
</code></pre>
</blockquote>

<p>Remove paragraph 12 entirely:</p>

<blockquote>
<p> <del>-12- <em>Requires:</em></del> </p>
<ul>
<li><del>If <code>D</code> is not an lvalue reference type then</del>
<ul>
<li>
<del>
If <code>d</code> is an lvalue or const rvalue then the first constructor of this pair will be selected. <code>D</code> shall satisfy the requirements of <code>CopyConstructible</code> (Table 24), and the copy constructor of <code>D</code> shall not throw an exception. This <code>unique_ptr</code> will hold a copy of <code>d</code>.
</del>
</li>
<li>
<del>
Otherwise, <code>d</code> is a non-const rvalue and the second constructor of this pair will be selected. <code>D</code> shall satisfy the requirements of <code>MoveConstructible</code> (Table 23), and the move constructor of <code>D</code> shall not throw an exception. This <code>unique_ptr</code> will hold a value move constructed from <code>d</code>.
</del>
</li>
</ul>
</li>
<li>
<del>
Otherwise <code>D</code> is an lvalue reference type. <code>d</code> shall be reference-compatible with one of the constructors.
If <code>d</code> is an rvalue, it will bind to the second constructor of this pair and the program is ill-formed.
[<em>Note:</em> The diagnostic could be implemented using a static_assert which assures that <code>D</code> is not
a reference type. <em>— end note</em>] Else <code>d</code> is an lvalue and will bind to the first constructor of this
pair. The type which <code>D</code> references need not be <code>CopyConstructible</code> nor <code>MoveConstructible</code>. This
<code>unique_ptr</code> will hold a <code>D</code> which refers to the lvalue <code>d</code>. [<em>Note:</em> <code>D</code> may not be an rvalue reference
type. <em>— end note</em>]
</del>
</li>
</ul>
</blockquote>

<p>Modify paragraph 13 as shown:</p>

<blockquote>
<p>-13- <em>Effects:</em>
Constructs a <code>unique_ptr</code> object which owns <code>p</code>, initializing the stored pointer with <code>p</code> and
initializing the deleter <del>as described above</del> <ins>from <code>std::forward&lt;decltype(d)&gt;(d)</code></ins>.</p>
</blockquote>

<p>Add a new paragraph after paragraph 14 (Postconditions):</p>

<blockquote>
<p><ins>-?- <em>Remarks:</em> These constructors shall not participate in overload resolution unless <code>is_constructible_v&lt;D, decltype(d)&gt;</code> is <code>true</code>.</ins></p>
</blockquote>






<hr>
<h3><a name="2908" href="p0625r0.html#2908">2908.</a> The less-than operator for shared pointers could do more</h3>
<p><b>Section:</b> 20.11.2.2.7 [util.smartptr.shared.cmp] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#util.smartptr.shared.cmp">issues</a> in [util.smartptr.shared.cmp].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 135</b>

<p>The less-than operator for shared pointers compares only those combinations that can form a composite pointer type. 
With the C++17 wording for the diamond functor, <tt>less&lt;&gt;</tt>, we should be able to support comparison of a wider 
range of shared pointers, such that <tt>less&lt;&gt;::operator(shared_ptr&lt;A&gt;, shared_ptr&lt;B&gt;)</tt> is consistent 
with <tt>less&lt;&gt;::operator(A *, B *)</tt>.</p>

<p>Proposed change: Replace <tt>less&lt;V&gt;</tt> with just <tt>less&lt;&gt;</tt>, and drop the reference to composite 
pointer types.</p>

<p><i>[2017-03-02, Kona, STL comments and provides wording]</i></p>

<p>
We talked about this in LWG, and I talked to Alisdair. The status quo is already maximally general (operator less-than in 
Core always forms a composite pointer type), but we can use diamond-less to significantly simplify the specification.  
(We can't use less-than directly, due to the total ordering issue, which diamond-less was recently "upgraded" to handle.)
</p>

<p><i>[Kona 2017-03-02]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change 20.11.2.2.7 [util.smartptr.shared.cmp] as depicted:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt;
bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <tt>less&lt;<del>V</del>&gt;()(a.get(), b.get())</tt><del>, where <tt>V</tt> is the composite pointer type (Clause 5) of 
<tt>shared_ptr&lt;T&gt;::element_type*</tt> and <tt>shared_ptr&lt;U&gt;::element_type*</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2911" href="p0625r0.html#2911">2911.</a> An <tt>is_aggregate</tt> type trait is needed</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 143</b>

<p>An <tt>is_aggregate</tt> type trait is needed. The emplace idiom is now common throughout the library, but typically relies 
on direct non-list initalization, which does not work for aggregates. With a suitable type trait, we could extend direct non-list-initlaization to perform aggregate-initalization on aggregate types.</p>
<p>Proposed change:</p>
<p>
Add a new row to Table 38:
</p>
<blockquote>
<pre>
template &lt;class T&gt;
struct is_aggregate;
</pre>
<p>
<tt>T</tt> is an aggregate type ([dcl.init.aggr])
<p/>
<tt>remove_all_extents_t&lt;T&gt;</tt> shall be a complete type, 
an array type, or (possibly <i>cv</i>-qualified) <tt>void</tt>.
</p>
</blockquote>

<p><i>[2017-02-26, Daniel comments and completes wording]</i></p>

<p>
The proposed wording is incomplete, since it doesn't update the <tt>&lt;type_traits&gt;</tt> header synopsis, also
ensuring that the corresponding <tt>is_aggregate_v</tt> variable template is defined.
</p>

<p><i>[2017-03-01, Daniel comments and adjusts wording]</i></p>

<p>
There is only one minor change performed, namely to mark the constant in the <tt>is_aggregate_v</tt> variable 
template as <tt>inline</tt> following the LWG preferences for "full inline" bullet list (B2) from
<a href="http://wg21.link/p0607r0">P0607R0</a>.
</p>

<p><i>[2017-03-03, Kona, LEWG]</i></p>

<p>
No interest in doing the is-list-initializable <em>instead</em>. No objection to getting that proposal also.
<p/>
Want this for C++17?
<p/>
SF | F | N | A | SA
<p/>
2  | 8 | 1 | 3 | 0
<p/>
Want this for C++20?
<p/>
SF | F | N | A | SA
<p/>
6  | 5 | 2 | 0 | 0
<p/>
Remember to correct the wording to: "<tt>remove_all_extents_t&lt;T&gt;</tt> shall be a complete type or <i>cv</i>-<tt>void</tt>."
</p>

<p><i>[2017-03-03, Daniel updates wording]</i></p>

<p>
In sync with existing writing, this was changed to "<tt>remove_all_extents_t&lt;T&gt;</tt> shall be a complete type or <i>cv</i> <tt>void</tt>"
</p>
<p><i>[Kona 2017-03-02]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>
<p>This will require a new complier intrinsic; Alisdair checked with Core and they're OK with that</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>
<li><p>Modify 20.15.2 [meta.type.synop], <tt>&lt;type_traits&gt;</tt> header synopsis, as indicated:</p>

<blockquote><pre>
<i>// 20.15.4.3, type properties</i>
[&hellip;]
template &lt;class T&gt; struct is_final;
<ins>template &lt;class T&gt; struct is_aggregate;</ins>

[&hellip;]
<i>// 20.15.4.3, type properties</i>
[&hellip;]
template &lt;class T&gt; constexpr bool is_final_v
  = is_final&lt;T&gt;::value;
<ins>template &lt;class T&gt; inline constexpr bool is_aggregate_v
  = is_aggregate&lt;T&gt;::value;</ins>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Add a new row to Table 42 &mdash; "Type property predicates":</p>
<blockquote><pre>
<ins>template &lt;class T&gt; struct is_aggregate;</ins>
</pre>
<p>
<ins><tt>T</tt> is an aggregate type (8.6.1 [dcl.init.aggr])</ins>
<p/>
<ins><tt>remove_all_extents_t&lt;T&gt;</tt> shall be a complete type or <i>cv</i> <tt>void</tt>.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2921" href="p0625r0.html#2921">2921.</a> <tt>packaged_task</tt> and type-erased allocators</h3>
<p><b>Section:</b> 30.6.10 [futures.task] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 165</b>

<p>The constructor that type-erases an allocator has all of the problems of the similar function constructor that was removed 
for this CD. This constructor from <tt>packaged_task</tt> should similarly be removed as well. If we prefer to keep this 
constructor, the current wording is underspecified, as the <tt>Allocator</tt> argument is not required to be type satisfying 
the Allocator requirements, nor is <tt>allocator_traits</tt> used.</p>

<p>Proposed change: </p>
<p>Strike</p>
<blockquote><pre>
<del>template &lt;class F, class Allocator&gt;
packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);</del>
</pre></blockquote>
<p>
from the class definition in p2, and from <b>30.6.9.1 [futures.task.members]</b> p2.
Strike the last sentence of 30.6.9.1p4. In p3, revise "These constructors" to "This constructor"
</p>

<p><i>[Kona 2017-03-02]</i></p>

<p>Accepted as Immediate to resolve NB comment.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Modify 30.6.10 [futures.task] as follows:</p>
<p>Strike</p>
<blockquote><pre><del>
template &lt;class F, class Allocator&gt;
packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</del></pre></blockquote>
<p>from the class definition in p2, and from [futures.task.members] p2.</p>
</li>

<li>
<p>Modify 30.6.10.1 [futures.task.members]/3:</p>
<blockquote>
<i>Remarks:</i> <del>These constructors</del><ins>This constructor</ins> shall not participate in overload resolution if 
<tt>decay_t&lt;F&gt;</tt> is the same type as <tt>packaged_task&lt;R(ArgTypes...)&gt;</tt>.
</blockquote>
</li>

<li>
<p>Strike the last sentence of 30.6.10.1 [futures.task.members]/4:</p>
<blockquote><del>
The constructors that take an <tt>Allocator</tt> argument use it to allocate memory needed to store the internal data structures.
</del></blockquote>
</li>


</ol>





<hr>
<h3><a name="2934" href="p0625r0.html#2934">2934.</a> <tt>optional&lt;const T&gt;</tt> doesn't compare with <tt>T</tt></h3>
<p><b>Section:</b> 20.6.8 [optional.comp_with_t] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2017-02-17 <b>Last modified:</b> 2017-03-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote><pre>
optional&lt;const int&gt; x = 42;
int y = 666;
x == y; // ill-formed
</pre></blockquote>
<p>
The comparison is ill-formed, because in [optional.comp_with_t]/1,
</p>
<pre>
template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const T&amp; v);
</pre>
<p>
the <tt>T</tt> is deduced to be both <tt>const int</tt> and <tt>int</tt>, which is ill-formed.
</p>
<p>
Since it became apparent that the root cause of this issue is also causing difficulties with e.g. 
comparing <tt>optional&lt;string&gt;</tt> with literals etc., here's a p/r that
</p>
<ol>
<li><p>adds requirements for <tt>optional</tt>'s comparisons with <tt>T</tt></p></li>
<li><p>turns <tt>optional</tt>-<tt>optional</tt> comparisons into two-template-parameter
templates, allowing comparing mixed optionals</p></li>
<li><p>turns <tt>optional</tt>-<tt>T</tt> comparisons into two-template-parameter templates,
allowing comparing optionals with <tt>T</tt> and types comparable with <tt>T</tt></p></li>
</ol>

<p><i>[Kona 2017-02-28]</i></p>

<p>Accepted as Immediate to avoid having break ABI later.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 20.6.2 [optional.syn], header <tt>&lt;optional&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]

<i>// 20.6.6 [optional.relops], relational operators</i>
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator!=(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);

[&hellip;]

<i>// 20.6.8 [optional.comp_with_t], comparison with T</i>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
</pre>
</blockquote>
</li>

<li><p>Modify 20.6.6 [optional.relops] as indicated:</p>
<blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.6.8 [optional.comp_with_t] as indicated:</p>
<blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x == v</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.
 [<i>Note:</i> <tt>T</tt> need not be <tt>EqualityComparable</tt>. &mdash; <i>end note</i>]</ins>
<p/>
-1- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x == v : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v == *x</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.</ins>
<p/>
-2- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v == *x : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x != v</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.</ins>
<p/>
-3- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x != v : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v != *x</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.</ins>
<p/>
-4- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v != *x : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &lt; v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-5- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &lt; v : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &lt; *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-6- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &lt; *x : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &lt;= v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-7- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &lt;= v : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &lt;= *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-8- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &lt;= *x : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &gt; v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-9- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &gt; v : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &gt; *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-10- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &gt; *x : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &gt;= v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-11- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &gt;= v : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &gt;= *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-12- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &gt;= *x : true;</tt>
</p>
</blockquote>
<pre>

</pre>
</blockquote>
</li>
</ol>






</body>
</html>
