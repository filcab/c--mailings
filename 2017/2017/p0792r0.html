<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link href="data:text/css;charset=utf-8,pre%2EsourceCode%7Bborder%3A1px%20solid%20%23444%3Bpadding%3A12px%3Bborder%2Dradius%3A6px%7Dhtml%7Bfont%2Dsize%3A100%25%3Boverflow%2Dy%3Ascroll%3B%2Dwebkit%2Dtext%2Dsize%2Dadjust%3A100%25%3B%2Dms%2Dtext%2Dsize%2Dadjust%3A100%25%7Dbody%7Bcolor%3A%23444%3Bfont%2Dfamily%3Ageorgia%2Cpalatino%2Cpalatino%20linotype%2Ctimes%2Ctimes%20new%20roman%2Cserif%3Bfont%2Dsize%3A12px%3Bline%2Dheight%3A1%2E7%3Bpadding%3A1em%3Bmargin%3Aauto%3Bmax%2Dwidth%3A54em%3Bbackground%3A%23fefefe%7Da%7Bcolor%3A%230645ad%3Btext%2Ddecoration%3Anone%7Da%3Avisited%7Bcolor%3A%230b0080%7Da%3Ahover%7Bcolor%3A%2306e%7Da%3Aactive%7Bcolor%3A%23faa700%7Da%3Afocus%7Boutline%3Athin%20dotted%7D%2A%3A%3A%2Dmoz%2Dselection%7Bbackground%3Argba%28255%2C255%2C0%2C%2E3%29%3Bcolor%3A%23000%7D%2A%3A%3Aselection%7Bbackground%3Argba%28255%2C255%2C0%2C%2E3%29%3Bcolor%3A%23000%7Da%3A%3A%2Dmoz%2Dselection%7Bbackground%3Argba%28255%2C255%2C0%2C%2E3%29%3Bcolor%3A%230645ad%7Da%3A%3Aselection%7Bbackground%3Argba%28255%2C255%2C0%2C%2E3%29%3Bcolor%3A%230645ad%7Dp%7Bmargin%3A1em%200%7Dimg%7Bmax%2Dwidth%3A100%25%7Dh1%2Ch2%2Ch3%2Ch4%2Ch5%2Ch6%7Bcolor%3A%23111%3Bline%2Dheight%3A125%25%3Bmargin%2Dtop%3A2em%3Bfont%2Dweight%3A400%7Dh4%2Ch5%2Ch6%7Bfont%2Dweight%3A700%7Dh1%7Bfont%2Dsize%3A2%2E5em%7Dh2%7Bfont%2Dsize%3A2em%7Dh3%7Bfont%2Dsize%3A1%2E5em%7Dh4%7Bfont%2Dsize%3A1%2E2em%7Dh5%7Bfont%2Dsize%3A1em%7Dh6%7Bfont%2Dsize%3A%2E9em%7Dblockquote%7Bcolor%3A%23666%3Bmargin%3A0%3Bpadding%2Dleft%3A3em%3Bborder%2Dleft%3A%2E5em%20%23eee%20solid%7Dhr%7Bdisplay%3Ablock%3Bheight%3A2px%3Bborder%3A0%3Bborder%2Dtop%3A1px%20solid%20%23aaa%3Bborder%2Dbottom%3A1px%20solid%20%23eee%3Bmargin%3A1em%200%3Bpadding%3A0%7Dpre%2Ccode%2Ckbd%2Csamp%7Bcolor%3A%23000%3Bfont%2Dfamily%3Amonospace%2Cmonospace%3B%5Ffont%2Dfamily%3A%27courier%20new%27%2Cmonospace%3Bfont%2Dsize%3A%2E98em%7Dpre%7Bwhite%2Dspace%3Apre%3Bwhite%2Dspace%3Apre%2Dwrap%3Bword%2Dwrap%3Abreak%2Dword%7Db%2Cstrong%7Bfont%2Dweight%3A700%7Ddfn%7Bfont%2Dstyle%3Aitalic%7Dins%7Bbackground%3A%23ff9%3Bcolor%3A%23000%3Btext%2Ddecoration%3Anone%7Dmark%7Bbackground%3A%23ff0%3Bcolor%3A%23000%3Bfont%2Dstyle%3Aitalic%3Bfont%2Dweight%3A700%7Dsub%2Csup%7Bfont%2Dsize%3A75%25%3Bline%2Dheight%3A0%3Bposition%3Arelative%3Bvertical%2Dalign%3Abaseline%7Dsup%7Btop%3A%2D%2E5em%7Dsub%7Bbottom%3A%2D%2E25em%7Dul%2Col%7Bmargin%3A1em%200%3Bpadding%3A0%200%200%202em%7Dli%20p%3Alast%2Dchild%7Bmargin%2Dbottom%3A0%7Dul%20ul%2Col%20ol%7Bmargin%3A%2E3em%200%7Ddl%7Bmargin%2Dbottom%3A1em%7Ddt%7Bfont%2Dweight%3A700%3Bmargin%2Dbottom%3A%2E8em%7Ddd%7Bmargin%3A0%200%20%2E8em%202em%7Ddd%3Alast%2Dchild%7Bmargin%2Dbottom%3A0%7Dimg%7Bborder%3A0%3B%2Dms%2Dinterpolation%2Dmode%3Abicubic%3Bvertical%2Dalign%3Amiddle%7Dfigure%7Bdisplay%3Ablock%3Btext%2Dalign%3Acenter%3Bmargin%3A1em%200%7Dfigure%20img%7Bborder%3A0%3Bmargin%3A0%20auto%7Dfigcaption%7Bfont%2Dsize%3A%2E8em%3Bfont%2Dstyle%3Aitalic%3Bmargin%3A0%200%20%2E8em%7Dtable%7Bmargin%2Dbottom%3A2em%3Bborder%2Dbottom%3A1px%20solid%20%23ddd%3Bborder%2Dright%3A1px%20solid%20%23ddd%3Bborder%2Dspacing%3A0%3Bborder%2Dcollapse%3Acollapse%7Dtable%20th%7Bpadding%3A%2E2em%201em%3Bbackground%2Dcolor%3A%23eee%3Bborder%2Dtop%3A1px%20solid%20%23ddd%3Bborder%2Dleft%3A1px%20solid%20%23ddd%7Dtable%20td%7Bpadding%3A%2E2em%201em%3Bborder%2Dtop%3A1px%20solid%20%23ddd%3Bborder%2Dleft%3A1px%20solid%20%23ddd%3Bvertical%2Dalign%3Atop%7D%2Eauthor%7Bfont%2Dsize%3A1%2E2em%3Btext%2Dalign%3Acenter%7D%40media%20only%20screen%20and%20%28min%2Dwidth%3A480px%29%7Bbody%7Bfont%2Dsize%3A14px%7D%7D%40media%20only%20screen%20and%20%28min%2Dwidth%3A768px%29%7Bbody%7Bfont%2Dsize%3A16px%7D%7D%40media%20print%7B%2A%7Bbackground%3Atransparent%21important%3Bcolor%3A%23000%21important%3Bfilter%3Anone%21important%3B%2Dms%2Dfilter%3Anone%21important%7Dbody%7Bfont%2Dsize%3A12pt%3Bmax%2Dwidth%3A100%25%7Da%2Ca%3Avisited%7Btext%2Ddecoration%3Aunderline%7Dhr%7Bheight%3A1px%3Bborder%3A0%3Bborder%2Dbottom%3A1px%20solid%20%23000%7Da%5Bhref%5D%3Aafter%7Bcontent%3A%22%20%28%22%20attr%28href%29%20%22%29%22%7Dabbr%5Btitle%5D%3Aafter%7Bcontent%3A%22%20%28%22%20attr%28title%29%20%22%29%22%7D%2Eir%20a%3Aafter%2Ca%5Bhref%5E%3D%22javascript%3A%22%5D%3Aafter%2Ca%5Bhref%5E%3D%22%23%22%5D%3Aafter%7Bcontent%3A%22%22%7Dpre%2Cblockquote%7Bborder%3A1px%20solid%20%23999%3Bpadding%2Dright%3A1em%3Bpage%2Dbreak%2Dinside%3Aavoid%7Dtr%2Cimg%7Bpage%2Dbreak%2Dinside%3Aavoid%7Dimg%7Bmax%2Dwidth%3A100%25%21important%7D%40page%3Aleft%7Bmargin%3A15mm%2020mm%2015mm%2010mm%7D%40page%3Aright%7Bmargin%3A15mm%2010mm%2015mm%2020mm%7Dp%2Ch2%2Ch3%7Borphans%3A3%3Bwidows%3A3%7Dh2%2Ch3%7Bpage%2Dbreak%2Dafter%3Aavoid%7D%7D" rel="stylesheet" type="text/css" />
</head>
<body>
<table>
<tbody>
<tr class="odd">
<td>Document number</td>
<td>P0792R0</td>
</tr>
<tr class="even">
<td>Date</td>
<td>2017-10-10</td>
</tr>
<tr class="odd">
<td>Reply-to</td>
<td>Vittorio Romeo &lt;<a href="mailto:vittorio.romeo@outlook.com">vittorio.romeo@outlook.com</a>&gt;</td>
</tr>
<tr class="even">
<td>Audience</td>
<td>Library Evolution Working Group</td>
</tr>
<tr class="odd">
<td>Project</td>
<td>ISO JTC1/SC22/WG21: Programming Language C++</td>
</tr>
</tbody>
</table>
<h1 id="function_ref-a-non-owning-reference-to-a-callable"><code>function_ref</code>: a non-owning reference to a <code>Callable</code></h1>
<style>
.inline-link
{
    font-size: small;
    margin-top: -2.1em;
    text-align: right;
    font-weight: bold;
}

code
{
    font-family: "Fira Code", monospace !important;
    font-size: 0.87em;
}

.sourceCode
{
    font-size: 0.95em;
}

a code
{
    color: #0645ad;
}
</style>
<h2 id="abstract">Abstract</h2>
<p>This paper proposes the addition of <code>function_ref&lt;R(Args...)&gt;</code> to the Standard Library, a <em>&quot;vocabulary type&quot;</em> for non-owning references to <code>Callable</code> objects.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="p0792r0.html#overview">Overview</a></li>
<li><a href="p0792r0.html#motivating-example">Motivating example</a></li>
<li><a href="p0792r0.html#impact-on-the-standard">Impact on the Standard</a></li>
<li><a href="p0792r0.html#alternatives">Alternatives</a></li>
<li><a href="p0792r0.html#synopsis">Synopsis</a></li>
<li><a href="p0792r0.html#specification">Specification</a></li>
<li><a href="p0792r0.html#existing-practice">Existing practice</a></li>
<li><a href="p0792r0.html#possible-issues">Possible issues</a></li>
<li><a href="p0792r0.html#open-questions">Open questions</a></li>
<li><a href="p0792r0.html#bikeshedding">Bikeshedding</a></li>
<li><a href="p0792r0.html#acknowledgments">Acknowledgments</a></li>
<li><a href="p0792r0.html#references">References</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>Since the advent of C++11 writing more functional code has become easier: functional programming patterns and idioms have become powerful additions to the C++ developer's toolbox. <strong>&quot;Higher-order functions&quot;</strong> are one of the key ideas of the functional paradigm - in short, they are functions that take functions as arguments and/or return functions as results.</p>
<p>The need of referring to an existing <code>Callable</code> object comes up often when writing functional C++ code, but the Standard Library unfortunately doesn't provide a flexible facility that allows to do so. Let's consider the existing utilities:</p>
<ul>
<li><p><strong>Pointers to functions</strong> are only useful when the entity they refer to is stateless <em>(i.e. a non-member function or a capture-less lambda)</em>, but they are cumbersome to use otherwise. Fully supporting the <code>Callable</code> concept requires also explicitly dealing with <strong>pointers to member functions</strong> and <strong>pointers to data members</strong>.</p></li>
<li><p><strong><code>std::function</code></strong> seamlessly works with <code>Callable</code> objects, but it's a <em>&quot;general-purpose polymorphic function wrapper&quot;</em> that may introduce unnecessary overhead and that <strong>owns</strong> the <code>Callable</code> it stores. <code>std::function</code> is a great choice when an owning type-erased wrapper is required, but it's often abused when its ownership semantics and its flexibility are not required.</p>
<ul>
<li><p>Note that when <code>std::function</code> is constructed/assigned with a <code>std::reference_wrapper</code> to a <code>Callable</code>, it has reference semantics.</p></li>
<li><p>Another limitation of <code>std::function</code> is the fact that the stored <code>Callable</code> must be <code>CopyConstructible</code>.</p></li>
</ul></li>
<li><p><strong>Templates</strong> can be used to avoid unnecessary costs and to uniformly handle any <code>Callable</code> object, but they are hard to constrain to a particular signature and force code to be defined in headers.</p></li>
</ul>
<p>This paper proposes the introduction of a new <code>function_ref</code> class template, which is akin to <code>std::string_view</code>. This paper describes <code>function_ref</code> as a <strong>non-owning lightweight wrapper</strong> over any <code>Callable</code> object.</p>
<h2 id="motivating-example">Motivating example</h2>
<p>Here's one example use case that benefits from <em>higher-order functions</em>: a <code>retry(n, f)</code> function that attempts to synchronously call <code>f</code> up to <code>n</code> times until success. This example might model the real-world scenario of repeatedly querying a flaky web service.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> payload { <span class="co">/* ... */</span> };

<span class="co">// Repeatedly invokes `action` up to `times` repetitions.</span>
<span class="co">// Immediately returns if `action` returns a valid `payload`.</span>
<span class="co">// Returns `std::nullopt` otherwise.</span>
<span class="bu">std::</span>optional&lt;payload&gt; retry(<span class="bu">std::</span>size_t times, <span class="co">/* ????? */</span> action);</code></pre></div>
<p>The passed-in <code>action</code> should be a <code>Callable</code> which takes no arguments and returns <code>std::optional&lt;payload&gt;</code>. Let's see how <code>retry</code> can be implemented with various techniques:</p>
<ul>
<li><p>Using <em>pointers to functions</em>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;payload&gt; retry(<span class="bu">std::</span>size_t times,
                             <span class="bu">std::</span>optional&lt;payload&gt;(*action)())
{
    <span class="co">/* ... */</span>
}</code></pre></div>
<div class="inline-link">
<p><a href="https://godbolt.org/g/UQbZYp"><em>(on godbolt.org)</em></a></p>
</div>
<ul>
<li><p><strong>Advantages</strong>:</p>
<ul>
<li><p>Easy to implement: no need to use a <code>template</code> or any explicit constraint <em>(e.g. <code>std::enable_if_t&lt;...&gt;</code>)</em>. The type of the pointer specifies exactly which functions can be passed, no extra constraints are required.</p></li>
<li><p>Minimal overhead: no allocations, no exceptions, and <code>action</code> is as big as a pointer.</p>
<ul>
<li>Modern compilers are able to completely inline the call to <code>action</code>, producing optimal assembly.</li>
</ul></li>
</ul></li>
<li><p><strong>Drawbacks</strong>:</p>
<ul>
<li>This technique doesn't support stateful <code>Callable</code> objects.</li>
</ul></li>
</ul></li>
<li><p>Using a <code>template</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;
<span class="kw">auto</span> retry(<span class="bu">std::</span>size_t times, F&amp;&amp; action)
    -&gt; <span class="bu">std::</span>enable_if_t&lt;<span class="bu">std::</span>is_invocable_r_v&lt;<span class="bu">std::</span>optional&lt;payload&gt;, F&amp;&amp;&gt;,
                        <span class="bu">std::</span>optional&lt;payload&gt;&gt;
{
    <span class="co">/* ... */</span>
}</code></pre></div>
<div class="inline-link">
<p><a href="https://godbolt.org/g/AGikkz"><em>(on godbolt.org)</em></a></p>
</div>
<ul>
<li><p><strong>Advantages</strong>:</p>
<ul>
<li><p>Supports arbitrary <code>Callable</code> objects, such as stateful closures.</p></li>
<li><p>Zero-overhead: no allocations, no exceptions, no indirections.</p></li>
</ul></li>
<li><p><strong>Drawbacks</strong>:</p>
<ul>
<li><p>Harder to implement and less readable: users must use <code>std::enable_if_t</code> and <code>std::invocable_r_v</code> to ensure that <code>action</code>'s signature is properly constrained.</p></li>
<li><p><code>retry</code> must be defined in a header file. This might be undesiderable when trying to minimize compilation times.</p></li>
</ul></li>
</ul></li>
<li><p>Using <code>std::function</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;payload&gt; retry(<span class="bu">std::</span>size_t times,
                             <span class="bu">std::</span>function&lt;<span class="bu">std::</span>optional&lt;payload&gt;()&gt; action)
{
    <span class="co">/* ... */</span>
}</code></pre></div>
<div class="inline-link">
<p><a href="https://godbolt.org/g/t9FH9b"><em>(on godbolt.org)</em></a></p>
</div>
<ul>
<li><p><strong>Advantages</strong>:</p>
<ul>
<li><p>Supports arbitrary <code>Callable</code> objects, such as stateful closures.</p></li>
<li><p>Easy to implement: no need to use a <code>template</code> or any explicit constraint. The type fully constrains what can be passed.</p></li>
</ul></li>
<li><p><strong>Drawbacks</strong>:</p>
<ul>
<li><p>Unclear ownership semantics: <code>action</code> might either own the the stored <code>Callable</code>, or just refer to an existing <code>Callable</code> if initialized with a <code>std::reference_wrapper</code>.</p></li>
<li><p>Can potentially have significant overhead:</p>
<ul>
<li><p>Even though the implementation makes use of SBO <em>(small buffer optimization)</em>, <code>std::function</code> might allocate if the stored object is large enough. This requires one extra branch on construction/assignment, one potential dynamic allocation, and makes <code>action</code> as big as the size of the internal buffer.</p></li>
<li><p>If the implementation doesn't make use of SBO, <code>std::function</code> will always allocate on construction/assignment.</p></li>
<li><p>Modern compilers are not able to inline <code>std::function</code>, often resulting in very poor assembly compared to the previously mentioned techniques.</p></li>
</ul></li>
<li><p>Mandatory use of exceptions: <code>std::function</code> might throw if an allocation fails, and throws <code>std::bad_function_call</code> if it's invoked while unset.</p></li>
</ul></li>
</ul></li>
<li><p>Using the proposed <code>function_ref</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;payload&gt; retry(<span class="bu">std::</span>size_t times,
                             function_ref&lt;<span class="bu">std::</span>optional&lt;payload&gt;()&gt; action)
{
    <span class="co">/* ... */</span>
}</code></pre></div>
<div class="inline-link">
<p><a href="https://godbolt.org/g/DvWKVH"><em>(on godbolt.org)</em></a></p>
</div>
<ul>
<li><p><strong>Advantages</strong>:</p>
<ul>
<li><p>Supports arbitrary <code>Callable</code> objects, such as stateful closures.</p></li>
<li><p>Easy to implement: no need to use a <code>template</code> or any constraint. The type fully constrains what can be passed.</p></li>
<li><p>Clear ownership semantics: <code>action</code> is a <strong>non-owning</strong> reference to an existing <code>Callable</code>.</p></li>
<li><p>Small overhead: no allocations, no exceptions, and <code>action</code> is as big as two pointers.</p>
<ul>
<li>Modern compilers are able to completely inline the call to <code>action</code>, producing optimal assembly.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="impact-on-the-standard">Impact on the Standard</h2>
<p>This proposal is a pure library extension. It does not require changes to any existing part of the Standard.</p>
<h2 id="alternatives">Alternatives</h2>
<p>The only existing viable alternative to <code>function_ref</code> currently is <code>std::function</code> + <code>std::reference_wrapper</code>. The Standard guarantees that when a <code>std::reference_wrapper</code> is used to construct/assign to a <code>std::function</code> no allocations will occur and no exceptions will be thrown.</p>
<p>Using <code>std::function</code> for non-owning references is suboptimal for various reasons.</p>
<ol style="list-style-type: decimal">
<li><p>The ownership semantics of a <code>std::function</code> are unclear - they change depending on whether or not the <code>std::function</code> was constructed/assigned with a <code>std::reference_wrapper</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(<span class="bu">std::</span>function&lt;<span class="dt">void</span>()&gt; f);
<span class="co">// `f` could be referring to an existing Callable, or could own one.</span>

<span class="dt">void</span> bar(function_ref&lt;<span class="dt">void</span>()&gt; f);
<span class="co">// `f` unambiguously is a non-owning reference to an existing Callable.</span></code></pre></div></li>
<li><p>This technique doesn't work with temporaries. This is a huge drawback as it prevents stateful temporary lambdas from being passed as callbacks.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(<span class="bu">std::</span>function&lt;<span class="dt">void</span>()&gt; f);

<span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span>;
    foo(<span class="bu">std::</span>ref([&amp;x]{ ++x; }); <span class="co">// does not compile</span>
}</code></pre></div>
<div class="inline-link">
<p><a href="https://godbolt.org/g/DPQ7ku"><em>(on godbolt.org)</em></a></p>
</div>
<p>The code above doesn't compile, as <code>std::ref</code> only accepts non-<code>const</code> lvalue references <em>(additionally, <code>std::cref</code> is explicitly deleted for rvalue references)</em>. Avoiding the use of <code>std::ref</code> breaks the guarantee that <code>f</code> won't allocate or throw an exception on construction.</p></li>
<li><p><code>std::function</code> is harder for compilers to optimize compared to the proposed <code>function_ref</code>. This is true due to various reasons:</p>
<ul>
<li><p><code>std::function</code> can allocate and/or throw exceptions on construction and/or assigment.</p></li>
<li><p><code>std::function</code> might use SBO, which could require an additional branch during construction/assignment, make inlining more difficult, and unnecessarily increase memory usage.</p></li>
</ul>
<p>Rough benchmarks comparing the generated assembly of a <em><code>std::function</code> parameter</em> and a <em><code>function_ref</code> parameter</em> against a <em>template parameter</em> show that:</p>
<ul>
<li><p><code>std::function</code>, on average, generates approximately 5x more assembly than a template parameter.</p></li>
<li><p><code>function_ref</code>, on average, generates approximately 1.5x more assembly than a template parameter.</p></li>
</ul>
<p>A description of the benchmarking techniques used and the full results can be found on my article <em>&quot;passing functions to functions&quot;</em> <a href="p0792r0.html#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p></li>
</ol>
<h2 id="synopsis">Synopsis</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std
{
    <span class="kw">template</span> &lt;<span class="kw">typename</span>&gt;
    <span class="kw">class</span> function_ref; <span class="co">/* undefined */</span>

    <span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
    <span class="kw">class</span> function_ref&lt;R(Args...)&gt;
    {
    <span class="kw">public</span>:
        <span class="kw">constexpr</span> function_ref() <span class="kw">noexcept</span>;
        <span class="kw">constexpr</span> function_ref(<span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;
        <span class="kw">constexpr</span> function_ref(<span class="at">const</span> function_ref&amp;) <span class="kw">noexcept</span>;

        <span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;
        <span class="kw">constexpr</span> function_ref(F&amp;&amp;) <span class="kw">noexcept</span>;

        <span class="kw">constexpr</span> function_ref&amp; <span class="kw">operator</span>=(<span class="at">const</span> function_ref&amp;) <span class="kw">noexcept</span>;
        <span class="kw">constexpr</span> function_ref&amp; <span class="kw">operator</span>=(<span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;

        <span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;
        <span class="kw">constexpr</span> function_ref&amp; <span class="kw">operator</span>=(F&amp;&amp;) <span class="kw">noexcept</span>;

        <span class="kw">constexpr</span> <span class="dt">void</span> swap(function_ref&amp;) <span class="kw">noexcept</span>;

        <span class="kw">constexpr</span> <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span>() <span class="at">const</span> <span class="kw">noexcept</span>;

        R <span class="kw">operator</span>()(Args...) <span class="at">const</span>;
    };

    <span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
    <span class="kw">constexpr</span> <span class="dt">void</span> swap(function_ref&lt;R(Args...)&gt;&amp;, function_ref&lt;R(Args...)&gt;&amp;) <span class="kw">noexcept</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp;, <span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="bu">std::</span>nullptr_t, <span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp;) <span class="kw">noexcept</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp;, <span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="bu">std::</span>nullptr_t, <span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp;) <span class="kw">noexcept</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
    function_ref(R (*)(Args...)) -&gt; function_ref&lt;R(Args...)&gt;;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;
    function_ref(F) -&gt; function_ref&lt;<span class="co">/* deduced if possible */</span>&gt;;
}</code></pre></div>
<h2 id="specification">Specification</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> function_ref&lt;R(Args...)&gt;::function_ref() <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><p><em>Effects:</em> constructs a <code>function_ref</code> referring to nothing.</p></li>
<li><p><em>Postconditions:</em> <code>!*this</code>.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> function_ref&lt;R(Args...)&gt;::function_ref(<span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><p><em>Effects:</em> constructs a <code>function_ref</code> referring to nothing.</p></li>
<li><p><em>Postconditions:</em> <code>!*this</code>.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> function_ref&lt;R(Args...)&gt;::function_ref(<span class="at">const</span> function_ref&amp; rhs) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><p><em>Effects:</em> constructs a <code>function_ref</code> referring to the same callable <code>rhs</code> refers to (or to nothing if <code>bool(rhs) == false</code>).</p></li>
<li><p><em>Postconditions:</em> <code>!*this</code> if <code>!rhs</code>; otherwise, <code>*this</code> refers to the same <code>Callable</code> <code>rhs</code> refers to.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;
<span class="kw">constexpr</span> function_ref&lt;R(Args...)&gt;::function_ref(F&amp;&amp; f) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><p><em>Remarks:</em> This function shall not participate in overload resolution unless <code>!std::is_same_v&lt;std::decay_t&lt;F&gt;, function_ref&gt; &amp;&amp; std::is_invocable_v&lt;F&amp;&amp;, R, Args...&gt;</code>.</p></li>
<li><p><em>Effects:</em> constructs a <code>function_ref</code> referring to <code>f</code>.</p></li>
<li><p><em>Postconditions:</em> <code>!*this</code> if any of the following hold:</p>
<ul>
<li><p><code>f</code> is a null function pointer value.</p></li>
<li><p><code>f</code> is a null member pointer value.</p></li>
</ul>
<p>Otherwise, <code>*this</code> refers to <code>f</code>.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> function_ref&amp; function_ref&lt;R(Args...)&gt;::<span class="kw">operator</span>=(<span class="at">const</span> function_ref&amp; rhs) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><p><em>Effects:</em> <code>*this</code> refers to the same callable <code>rhs</code> refers to (or to nothing if <code>bool(rhs) == false</code>).</p></li>
<li><p><em>Postconditions:</em> <code>bool(*this) == bool(rhs)</code>.</p></li>
<li><p><em>Returns:</em> <code>*this</code>.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> function_ref&amp; function_ref&lt;R(Args...)&gt;::<span class="kw">operator</span>=(<span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><p><em>Effects:</em> <code>*this</code> refers to nothing.</p></li>
<li><p><em>Postconditions:</em> <code>!*this</code>.</p></li>
<li><p><em>Returns:</em> <code>*this</code>.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;
<span class="kw">constexpr</span> function_ref&amp; function_ref&lt;R(Args...)&gt;::<span class="kw">operator</span>=(F&amp;&amp;) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><p><em>Requires:</em> <code>std::is_invocable_v&lt;F&amp;&amp;, R, Args...&gt;</code>.</p></li>
<li><p><em>Effects:</em> <code>*this</code> refers to <code>f</code>.</p></li>
<li><p><em>Postconditions:</em> <code>bool(*this) == true</code>.</p></li>
<li><p><em>Returns:</em> <code>*this</code>.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> <span class="dt">void</span> function_ref&lt;R(Args...)&gt;::swap(function_ref&amp; rhs) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><em>Effects:</em> exchanges the values of <code>*this</code> and <code>rhs</code>.</li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> <span class="kw">explicit</span> function_ref&lt;R(Args...)&gt;::<span class="kw">operator</span> <span class="dt">bool</span>() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><em>Returns:</em> <code>true</code> if <code>*this</code> is referring to something, <code>false</code> otherwise.</li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
R function_ref&lt;R(Args...)&gt;::<span class="kw">operator</span>()(Args... xs) <span class="at">const</span>;</code></pre></div>
<ul>
<li><p><em>Requires:</em> <code>bool(*this) == true</code>.</p></li>
<li><p><em>Effects:</em> equivalent to <code>return INVOKE&lt;R&gt;(f, std::forward&lt;Args&gt;(xs)...);</code>, where <code>f</code> is the function object referred to by <code>*this</code>.</p></li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> <span class="dt">void</span> swap(function_ref&lt;R(Args...)&gt;&amp; lhs, function_ref&lt;R(Args...)&gt;&amp; rhs) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><em>Effects:</em> equivalent to <code>lhs.swap(rhs)</code>.</li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp; fr, <span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><em>Returns:</em> <code>false</code> if <code>fr</code> is referring to something, <code>true</code> otherwise.</li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="bu">std::</span>nullptr_t, <span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp; fr) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><em>Returns:</em> <code>fr == nullptr</code>.</li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp; fr, <span class="bu">std::</span>nullptr_t) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><em>Returns:</em> <code>!(fr == nullptr)</code>.</li>
</ul>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> R, <span class="kw">typename</span>... Args&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="bu">std::</span>nullptr_t fr, <span class="at">const</span> function_ref&lt;R(Args...)&gt;&amp;) <span class="kw">noexcept</span>;</code></pre></div>
<ul>
<li><em>Returns:</em> <code>!(fr == nullptr)</code>.</li>
</ul>
<h2 id="existing-practice">Existing practice</h2>
<p>Many facilities similar to <code>function_ref</code> exist and are widely used in large codebases. Here are some examples:</p>
<ul>
<li><p>The <code>llvm::function_ref</code> <a href="p0792r0.html#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> class template is used throughout LLVM. A quick GitHub search on the LLVM organization reports hundreds of usages both in <code>llvm</code> and <code>clang</code> <a href="p0792r0.html#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p></li>
<li><p>Facebook's Folly libraries <a href="p0792r0.html#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> provide a <code>folly::FunctionRef</code> <a href="p0792r0.html#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> class template. A GitHub search shows that it's used in projects <code>proxygen</code> and <code>fbthrift</code> <a href="p0792r0.html#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>.</p></li>
<li><p>GNU's popular debugger, <code>gdb</code> <a href="p0792r0.html#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>, uses <code>gdb::function_view</code> <a href="p0792r0.html#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> throughout its code base. The documentation in the linked header file <a href="p0792r0.html#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> is particularly well-written and greatly motivates the need for this facility.</p></li>
</ul>
<p>Additionally, combining results from GitHub searches <em>(excluding &quot;<code>llvm</code>&quot; and &quot;<code>folly</code>&quot;)</em> for &quot;<code>function_ref</code>&quot; <a href="p0792r0.html#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>, &quot;<code>function_view</code>&quot; <a href="p0792r0.html#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>, &quot;<code>FunctionRef</code>&quot; <a href="p0792r0.html#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>, and &quot;<code>FunctionView</code>&quot; <a href="p0792r0.html#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a> roughly shows more than 2800 occurrences.</p>
<h2 id="possible-issues">Possible issues</h2>
<p>Accepting temporaries in <code>function_ref</code>'s constructor is extremely useful in the most common use case: using it as a function parameter:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(function_ref&lt;<span class="dt">void</span>()&gt;);

<span class="dt">int</span> main()
{
    foo([]{ });
}</code></pre></div>
<div class="inline-link">
<p><a href="https://wandbox.org/permlink/BPtbPeQtErPGj4X7"><em>(on wandbox.org)</em></a></p>
</div>
<p>The usage shown above is completely safe: the temporary closure generated by the lambda expression is guarantee to live for the entirety of the call to <code>foo</code>. Unfortunately, this also means that the following code snippet will result in <em>undefined behavior</em>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    function_ref&lt;<span class="dt">void</span>()&gt; f{[]{ }};
    <span class="co">// ...</span>
    f(); <span class="co">// undefined behavior</span>
}</code></pre></div>
<div class="inline-link">
<p><a href="https://wandbox.org/permlink/cQPEX2sKjCQjgIki"><em>(on wandbox.org)</em></a></p>
</div>
<p>The above closure is a temporary whose lifetime ends after the <code>function_ref</code> constructor call. The <code>function_ref</code> will store an address to a &quot;dead&quot; closure - invoking it will produce undefined behavior <a href="p0792r0.html#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a>. As an example, <code>AddressSanitizer</code> detects an invalid memory access in this gist <a href="p0792r0.html#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>. Note that this problem is not unique to <code>function_ref</code>: the recently standardized <code>std::string_view</code> <a href="p0792r0.html#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> has the same problem <a href="p0792r0.html#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a>.</p>
<p>I strongly believe that accepting temporaries is a &quot;necessary evil&quot; for both <code>function_ref</code> and <code>std::string_view</code>, as it enables countless valid use cases. The problem of dangling references has been always present in the language - a more general solution like Herb Sutter and Neil Macintosh's lifetime tracking <a href="p0792r0.html#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a> would prevent mistakes without limiting the usefulness of view/reference classes.</p>
<h2 id="open-questions">Open questions</h2>
<p>Below are some unanswered questions for which I kindly ask guidance from members of the commitee and readers of this paper.</p>
<ul>
<li><p><code>function_ref::operator()</code> is not currently marked as <code>constexpr</code> due to implementation issues. I could not figure a way to implement a <code>constexpr</code>-friendly <code>operator()</code>. Is there any possibility it could be marked as <code>constexpr</code> to increase the usefulness of <code>function_ref</code>?</p></li>
<li><p><code>function_ref::operator()</code> is qualified as <code>const</code> and always invokes the referenced <code>Callable</code> with <code>std::invoke(f, std::forward&lt;Args&gt;(xs)...)</code>. Should <code>f</code> be perfectly-forwarded? Should ref-qualified versions of <code>function_ref::operator()</code> that apply the ref qualifier to <code>f</code> be provided to allow users to invoke the referenced <code>Callable</code>'s potentially ref-qualified <code>operator()</code> overloads?</p></li>
<li><p>As currently proposed, <code>function_ref</code> can be in an <em>empty state</em>. This choice was made to maintain consistency with existing Standard Library classes such as <code>std::function</code> and <code>std::string_view</code>. A possible alternative is designing <code>function_ref</code> without an empty state and encourage the use of <code>std::optional&lt;std::function_ref&lt;/* ... */&gt;&gt;</code> to model a possibly null reference to a <code>Callable</code>. Should <code>function_ref</code> have an empty state?</p></li>
<li><p>As currently proposed, <code>function_ref::operator()</code> is unconditionally qualified as <code>const</code>, even though the referred <code>Callable</code> object's <code>operator()</code> might have different qualifiers and/or mutate its own state upon invocation. This choice was made to maintain consistency with <code>std::function</code>. There have been proposals in the past that would allow <code>std::function</code> signatures to be qualified <em>(see P0045R1 <a href="p0792r0.html#fn19" class="footnoteRef" id="fnref19"><sup>19</sup></a> and N4159 <a href="p0792r0.html#fn20" class="footnoteRef" id="fnref20"><sup>20</sup></a>)</em> in order to statically check whether or not an adopted target object is compatible with the specified qualifiers. Should <code>function_ref</code> embrace the ideas discussed in P0045R1, achieving more type-safety at the cost of breaking consistency with <code>std::function</code>?</p></li>
</ul>
<h2 id="bikeshedding">Bikeshedding</h2>
<p>The name <code>function_ref</code> is subject to bikeshedding. Here are some other potential names:</p>
<ul>
<li><p><code>function_view</code></p></li>
<li><p><code>callable_ref</code></p></li>
<li><p><code>callable_view</code></p></li>
<li><p><code>invocable_ref</code></p></li>
<li><p><code>invocable_view</code></p></li>
<li><p><code>fn_view</code></p></li>
<li><p><code>fn_ref</code></p></li>
</ul>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Thanks to <strong>Eric Niebler</strong>, <strong>Tim van Deurzen</strong>, and <strong>Alisdair Meredith</strong> for providing very valuable feedback on earlier drafts of this proposal.</p>
<h2 id="references">References</h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://vittorioromeo.info/index/blog/passing_functions_to_functions.html#benchmark---generated-assembly" class="uri">https://vittorioromeo.info/index/blog/passing_functions_to_functions.html#benchmark---generated-assembly</a><a href="p0792r0.html#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://llvm.org/doxygen/classllvm_1_1function__ref_3_01Ret_07Params_8_8_8_08_4.html" class="uri">http://llvm.org/doxygen/classllvm_1_1function__ref_3_01Ret_07Params_8_8_8_08_4.html</a><a href="p0792r0.html#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://github.com/search?q=org%3Allvm-mirror+function_ref&amp;type=Code">https://github.com/search?q=org%3Allvm-mirror+function_ref&amp;type=Code</a><a href="p0792r0.html#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="https://github.com/facebook/folly" class="uri">https://github.com/facebook/folly</a><a href="p0792r0.html#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="https://github.com/facebook/folly/blob/master/folly/Function.h#L743-L824" class="uri">https://github.com/facebook/folly/blob/master/folly/Function.h#L743-L824</a><a href="p0792r0.html#fnref5">↩</a></p></li>
<li id="fn6"><p><a href="https://github.com/search?q=org%3Afacebook+FunctionRef&amp;type=Code">https://github.com/search?q=org%3Afacebook+FunctionRef&amp;type=Code</a><a href="p0792r0.html#fnref6">↩</a></p></li>
<li id="fn7"><p><a href="https://www.gnu.org/software/gdb/" class="uri">https://www.gnu.org/software/gdb/</a><a href="p0792r0.html#fnref7">↩</a></p></li>
<li id="fn8"><p><a href="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob;f=gdb/common/function-view.h" class="uri">https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob;f=gdb/common/function-view.h</a><a href="p0792r0.html#fnref8">↩</a></p></li>
<li id="fn9"><p><a href="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob;f=gdb/common/function-view.h" class="uri">https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob;f=gdb/common/function-view.h</a><a href="p0792r0.html#fnref9">↩</a></p></li>
<li id="fn10"><p><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=function_ref+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code">https://github.com/search?utf8=%E2%9C%93&amp;q=function_ref+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code</a><a href="p0792r0.html#fnref10">↩</a></p></li>
<li id="fn11"><p><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=function_view+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code">https://github.com/search?utf8=%E2%9C%93&amp;q=function_view+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code</a><a href="p0792r0.html#fnref11">↩</a></p></li>
<li id="fn12"><p><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=functionref+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code">https://github.com/search?utf8=%E2%9C%93&amp;q=functionref+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code</a><a href="p0792r0.html#fnref12">↩</a></p></li>
<li id="fn13"><p><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=functionview+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code">https://github.com/search?utf8=%E2%9C%93&amp;q=functionview+AND+NOT+llvm+AND+NOT+folly+language%3AC%2B%2B&amp;type=Code</a><a href="p0792r0.html#fnref13">↩</a></p></li>
<li id="fn14"><p><a href="http://foonathan.net/blog/2017/01/20/function-ref-implementation.html" class="uri">http://foonathan.net/blog/2017/01/20/function-ref-implementation.html</a><a href="p0792r0.html#fnref14">↩</a></p></li>
<li id="fn15"><p><a href="https://gist.github.com/SuperV1234/a41eb1c825bfbb43f595b13bd4ea99c3" class="uri">https://gist.github.com/SuperV1234/a41eb1c825bfbb43f595b13bd4ea99c3</a><a href="p0792r0.html#fnref15">↩</a></p></li>
<li id="fn16"><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3762.html" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3762.html</a><a href="p0792r0.html#fnref16">↩</a></p></li>
<li id="fn17"><p><a href="http://foonathan.net/blog/2017/03/22/string_view-temporary.html" class="uri">http://foonathan.net/blog/2017/03/22/string_view-temporary.html</a><a href="p0792r0.html#fnref17">↩</a></p></li>
<li id="fn18"><p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetimes%20I%20and%20II%20-%20v0.9.1.pdf">https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetimes%20I%20and%20II%20-%20v0.9.1.pdf</a><a href="p0792r0.html#fnref18">↩</a></p></li>
<li id="fn19"><p><a href="http://wg21.link/p0045r1" class="uri">http://wg21.link/p0045r1</a><a href="p0792r0.html#fnref19">↩</a></p></li>
<li id="fn20"><p><a href="http://wg21.link/N4159" class="uri">http://wg21.link/N4159</a><a href="p0792r0.html#fnref20">↩</a></p></li>
</ol>
</div>
</body>
</html>
