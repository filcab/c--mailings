<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      lang="en-us" xml:lang="en-us">
<head>
  <title>Feature-testing recommendations for C++</title>
  <meta charset="us-ascii" />
  <style type="text/css">
    tr {
      page-break-inside: avoid;
    }

    .editornote {
      font-family: Cursive;
      background-color: Yellow;
    }

    .note {
      font-style: italic;
    }

    ins, .ins {
      text-decoration: underline;
      background-color: #CFC;
    }

    del {
      text-decoration: line-through;
      background-color: #FCC;
    }

    h2, h3, h4, p, pre, dl, table {
      background-color: inherit;
    }

      h2:before {
        content: "[" counter(h2) "]";
        padding-right: 0.25in;
      }

      h3:before {
        content: "[" counter(h2) "." counter(h3) "]";
        padding-right: 0.25in;
      }

      h4:before {
        content: "[" counter(h2) "." counter(h3) "." counter(h4) "]";
        padding-right: 0.25in;
      }

    h1 {
      counter-reset: h2 -2;
    }

    h2 {
      page-break-after: avoid;
      counter-increment: h2;
      counter-reset: h3 h4 p;
    }

    h3 {
      page-break-after: avoid;
      counter-increment: h3;
      counter-reset: h4 p;
    }

    h4 {
      page-break-after: avoid;
      counter-increment: h4;
      counter-reset: p;
    }

    body > p:before {
      content: "[" counter(p) "]";
      padding-right: 0.25in;
    }

    body > p {
      counter-increment: p;
    }
  </style>
</head>
<body>
  <table border="1">
    <tbody>
      <tr>
	<th>Doc. No.:</th>
	<td>P0096R4</td>
      </tr>
      <tr>
	<th>Date:</th>
	<td>2017-07-26</td>
      </tr>
      <tr>
	<th>Reply to:</th>
	<td>Clark Nelson</td>
      </tr>
      <tr>
	<th>Title:</th>
	<td>Feature-testing recommendations for C++</td>
      </tr>
    </tbody>
  </table>
  <h1>Feature-testing recommendations for C++</h1>
  <h2>Preface</h2>
  <p class="note">
    <del>This revision of this document contains STUBS for sections expected
		to be filled in later.</del>
  </p>
  <h2>Contents</h2>
  <ol>
    <li><a href="p0096r4.html#intro">Introduction</a></li>
    <li><a href="p0096r4.html#expl">Explanation and rationale for the approach</a>
      <ol>
	<li><a href="p0096r4.html#expl.prob">Problem statement</a></li>
	<li><a href="p0096r4.html#expl.status">Status quo</a></li>
	<li><a href="p0096r4.html#expl.soln">Characteristics of the proposed solution</a></li>
      </ol>
    </li>
    <li><a href="p0096r4.html#recs">Recommendations</a>
      <ol>
	<li><a href="p0096r4.html#recs.intro">Introduction</a></li>
	<li><a href="p0096r4.html#recs.hasinc">Testing for the presence of a header: <code>__has_include</code></a></li>
	<li><a href="p0096r4.html#recs.hasattr">Testing for the presence of an attribute: <code>__has_cpp_attribute</code></a></li>
	<li><a href="p0096r4.html#recs.cpp17">C++17 features</a></li>
	<li><a href="p0096r4.html#recs.cpp14">C++14 features</a></li>
	<li><a href="p0096r4.html#recs.cpp11">C++11 features</a></li>
	<li><a href="p0096r4.html#recs.cpp98">C++98 features</a> <del><em>(STUB)</em></del></li>
	<li><a href="p0096r4.html#recs.removed">Features published and later removed</a></li>
      </ol>
    </li>
    <li><a href="p0096r4.html#ts">Recommendations from Technical Specifications</a></li>
    <li><a href="p0096r4.html#detail">Detailed explanation and rationale</a>
      <ol>
	<li><a href="p0096r4.html#detail.cpp14">C++14 features</a></li>
	<li><a href="p0096r4.html#detail.cpp17">C++17 features</a></li>
      </ol>
    </li>
    <li><a href="p0096r4.html#model">Annex: Model wording for a Technical Specification</a></li>
    <li><a href="p0096r4.html#hist">Revision history</a></li>
  </ol>
  <h2 id="intro">Introduction</h2>
  <p>At the September 2013 (Chicago) meeting of WG21, there was a five-way poll of
		all of the C++ experts in attendance &ndash; approximately 80 &ndash; concerning
		their support for the approach described herein for feature-testing in C++. The
		results of the poll:</p>
  <table border="1">
    <thead>
      <tr>
	<th>Strongly favor</th>
	<th>Favor</th>
	<th>Neutral</th>
	<th>Oppose</th>
	<th>Strongly oppose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td>lots</td>
	<td>lots</td>
	<td>1</td>
	<td>0</td>
	<td>0</td>
      </tr>
    </tbody>
  </table>
  <p><ins>General support for these recommendations was reaffirmed
    at the 2015 October (Kona) meeting,
    as indicated by the following straw poll:
     </ins></p>
  <blockquote class="ins">
  <p>
    Should WG21 encourage, but not require, feature-test macros for proposals?</p>
  <table border="1">
    <thead>
      <tr>
	<th>Strongly favor</th>
	<th>Favor</th>
	<th>Neutral</th>
	<th>Against</th>
	<th>Strongly against</th>
      </tr>
    </thead>
    <tr>
      <td>50</td>
      <td>13</td>
      <td>7</td>
      <td>3</td>
      <td>2</td>
    </tr>
  </table>
    </blockquote>
  <p>This document was subsequently designated WG21's SD-6 (sixth standing document),
		which will continue to be maintained by SG10.</p>
  <h2 id="expl">Explanation and rationale for the approach</h2>
  <h3 id="expl.prob">Problem statement</h3>
  <p>The pace of innovation in the standardization of C++ makes long-term stability of
		implementations unlikely. Features are added to the language because programmers
		want to use those features. Features are added to (the working draft of) the standard
		as the features become well-specified. In many cases a feature is added to an implementation
		well before or well after the standard officially introducing it is approved.</p>
  <p>This process makes it difficult for programmers who want to use a feature to know
		whether it is available in any given implementation. Implementations rarely leap
		from one formal revision of the standard directly to the next; the implementation
		process generally proceeds by smaller steps. As a result, testing for a specific
		revision of the standard (e.g. by examining the value of the <code>__cplusplus</code>
    macro) often gives the wrong answer. Implementers generally don't want to appear
		to be claiming full conformance to a standard revision until all of its features
		are implemented. That leaves programmers with no portable way to determine which
		features are actually available to them.</p>
  <p>It is often possible for a program to determine, in a manner specific to a single
		implementation, what features are supported by that implementation; but the means
		are often poorly documented and ad hoc, and sometimes complex &ndash; especially
		when the availability of a feature is controlled by an invocation option. To make
		this determination for a variety of implementations in a single source base is complex
		and error-prone.</p>
  <h3 id="expl.status">Status quo</h3>
  <p>Here is some code that attempts to determine whether rvalue references are available
		in the implementation in use:</p>
  <pre>#ifndef __USE_RVALUE_REFERENCES
  #if (__GNUC__ &gt; 4 || __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3) || \
      _MSC_VER &gt;= 1600
    #if __EDG_VERSION__ &gt; 0
      #define __USE_RVALUE_REFERENCES (__EDG_VERSION__ &gt;= 410)
    #else
      #define __USE_RVALUE_REFERENCES 1
    #endif
  #elif __clang__
    #define __USE_RVALUE_REFERENCES __has_feature(cxx_rvalue_references)
  #else
    #define __USE_RVALUE_REFERENCES 0
  #endif
#endif</pre>
  <p>First, the GNU and Microsoft version numbers are checked to see if they are high
		enough. But then a check is made of the EDG version number, since that front end
		also has compatibility modes for both those compilers, and defines macros indicating
		(claimed) compatibility with them. If the feature wasn't implemented in the indicated
		EDG version, it is assumed that the feature is not available &ndash; even though
		it is possible for a customer of EDG to implement a feature before EDG does.</p>
  <p>Fortunately Clang has ways to test specifically for the presence of specific features.
		But unfortunately, the function-call-like syntax used for such tests won't work
		with a standard preprocessor, so this fine new feature winds up adding its own flavor
		of complexity to the mix.</p>
  <p>Also note that this code is only the beginning of a real-world solution. A complete
		solution would need to take into account more compilers, and also command-line option
		settings specific to various compilers.</p>
  <h3 id="expl.soln">Characteristics of the proposed solution</h3>
  <p>To preserve implementers' freedom to add features in the order that makes the most
		sense for themselves and their customers, implementers should indicate the availability
		of each separate feature by adding a definition of a macro with the name corresponding
		to that feature.</p>
  <p><strong>Important note:</strong> By recommending the use of these macros, WG21 is
		<strong>not</strong> making any feature optional; the absence of a definition for
		the relevant feature-test macro does not make an implementation that lacks a feature
		conform to a standard that requires the feature. However, if implementers and programmers
		follow these recommendations, portability of code between real-world implementations
		should be improved.</p>
  <p>To a first approximation, a feature is identified by the WG21 paper in which it is
		specified, and by which it is introduced into the working draft of the standard.
		Not every paper introduces a new feature worth a feature-test macro, but every paper
		that is not just a collection of issue resolutions is considered a candidate; exceptions
		are explicitly justified.</p>
  <p>For C++14, the feature-test macro name generally consists of some combination of words from
		the title of the paper. In the future, it is hoped that every paper will include
		its own recommendations concerning feature-test macro names.</p>
  <p>The value specified for a feature-test macro is based on the year and month in which
		the feature is voted into the working draft. In a case where a feature is subsequently
		changed in a significant way, but arguably remains the same feature, the value of
		the macro is changed to indicate the &ldquo;revision
		level&rdquo; of the specification of the feature. However, in most cases it is expected
		that the presence of a feature can be determined by the presence of any non-zero
		macro value; for example:</p>
  <pre>#if __cpp_binary_literals
int const packed_zero_to_three = 0b00011011;
#else
int const packed_zero_to_three = 0x1B;
#endif</pre>
  <p>To avoid the user's namespace, names of macros for language features are prefixed
		by &ldquo;<code>__cpp_</code>&rdquo;; for library features, by &ldquo;<code>__cpp_lib_</code>&rdquo;.
		A library feature that doesn't introduce a new header is expected to be defined
		by the header(s) that implement the feature.</p>
  <h2 id="recs">Recommendations</h2>
  <h3 id="recs.intro">Introduction</h3>
  <p>For the sake of improved portability between partial implementations of various C++
		standards, WG21 (the ISO technical committee for the C++ programming language) recommends
		that implementers and programmers follow the guidelines in this document concerning
		feature-test macros.</p>
  <p>Implementers who provide a new standard feature should define a macro with the recommended
		name and value, in the same circumstances under which the feature is available (for
		example, taking into account relevant command-line options), to indicate the presence
		of support for that feature.</p>
  <p>Programmers who wish to determine whether a feature is available in an implementation
		should base that determination on the state of the macro with the recommended name.
		(The absence of a tested feature may result in a program with decreased functionality,
		or the relevant functionality may be provided in a different way. A program that
		strictly depends on support for a feature can just try to use the feature unconditionally;
		presumably, on an implementation lacking necessary support, translation will fail.
	Therefore, if the most useful purpose for a feature-test macro
	    would be to control the inclusion of a <code>#error</code> directive
	    if the feature is unavailable,
	    that is considered inadequate justification for the macro.
	    Note that the usefulness of a test macro for a feature is completely independent
	    of the usefulness of the feature itself.)</p>
  <h3 id="recs.hasinc">Testing for the presence of a header: <code>__has_include</code></h3>
  <p>It is impossible for a C++ program to directly, reliably and portably determine whether
		or not a library header is available for inclusion. Conditionally including a header
		requires the use of a configuration macro, whose setting can be determined by a
		configuration-test process at build time (reliable, but less portable), or by some
		other means (often not reliable or portable).</p>
  <p>To solve this general problem, WG21 recommends that implementers provide, and programmers
		use, the <code>__has_include</code> feature.</p>
  <h4>Syntax</h4>
  <dl class="grammar">
    <dt><dfn>h-preprocessing-token</dfn>:</dt>
    <dd>any <var>preprocessing-token</var> other than <code>&gt;</code></dd>
  </dl>
  <dl class="grammar">
    <dt><dfn>h-pp-tokens</dfn>:</dt>
    <dd><var>h-preprocessing-token</var></dd>
    <dd><var>h-pp-tokens h-preprocessing-token</var></dd>
  </dl>
  <dl class="grammar">
    <dt><dfn>has-include-expression</dfn>:</dt>
    <dd><code>__has_include (</code> <var>header-name</var> <code>)</code></dd>
    <dd><code>__has_include (</code> <var>string-literal</var> <code>)</code></dd>
    <dd><code>__has_include ( &lt;</code> <var>h-pp-tokens</var> <code>&gt; )</code></dd>
  </dl>
  <h4>Semantics</h4>
  <p>In the first form of the <var>has-include-expression</var>,
	the parenthesized <var>header-name</var> token is not subject to macro expansion.
	The second and third
		forms are considered only if the first form does not match, and the preprocessing
		tokens are processed just as in normal text.</p>
  <p>A <var>has-include-expression</var> shall appear only in the controlling constant
		expression of a <code>#if</code> or <code>#elif</code> directive ([cpp.cond] 16.1).
		Prior to the evaluation of such an expression, the source file identified by the
		parenthesized preprocessing token sequence in each contained <var>has-include-expression</var>
    is searched for as if that preprocessing token sequence were the <var>pp-tokens</var>
    in a <code>#include</code> directive, except that no further macro expansion is
		performed. If such a directive would not satisfy the syntactic requirements of a
		<code>#include</code> directive, the program is ill-formed. The <var>has-include-expression</var>
    is replaced by the <var>pp-number</var> <code>1</code> if the search for the source
		file succeeds, and by the <var>pp-number</var> <code>0</code> if the search fails.</p>
  <p>The <code>#ifdef</code> and <code>#ifndef</code> directives, and the <code>defined</code>
    conditional inclusion operator, shall treat <code>__has_include</code> as if it
		were the name of a defined macro. The identifier <code>__has_include</code> shall
		not appear in any context not mentioned in this section.</p>
  <h4>Example</h4>
  <p>This demonstrates a way to
	use a library <code>optional</code> facility only if it is available.</p>
  <pre>
#ifdef __has_include
#  if __has_include(&lt;optional&gt;)
#    include &lt;optional&gt;
#    define have_optional 1
#  elif __has_include(&lt;experimental/optional&gt;)
#    include &lt;experimental/optional&gt;
#    define have_optional 1
#    define experimental_optional
#  else
#    define have_optional 0
#  endif
#endif
</pre>
  <h3 id="recs.hasattr">Testing for the presence of an attribute: <code>__has_cpp_attribute</code></h3>
  <p>A C++ program cannot directly, reliably, and portably determine whether or not
		a standard or vendor-specific attribute is available for use. Testing for attribute
		support generally requires complex macro logic, as illustrated above for language
		features in general.</p>
  <p>To solve this general problem, WG21 recommends that implementers provide, and
		programmers use, the <code>__has_cpp_attribute</code> feature.</p>
  <h4>Syntax</h4>
  <dl class="grammar">
    <dt><dfn>has-attribute-expression</dfn>:</dt>
    <dd><code>__has_cpp_attribute (</code> <var>attribute-token</var> <code>)</code></dd>
  </dl>
  <h4>Semantics</h4>
  <p>A <var>has-attribute-expression</var> shall appear only in the controlling constant
		expression of a <code>#if</code> or <code>#elif</code> directive ([cpp.cond] 16.1).
		The <var>has-attribute-expression</var> is replaced by a non-zero pp-number if the
		implementation supports an attribute with the specified name, and by the pp-number
		0 otherwise.</p>
  <p>For a standard attribute, the value of the <code>__has_cpp_attribute</code>
    macro is based on the year and month in which the attribute was voted into the working
		draft. In the case where the attribute is vendor-specific, the value is implementation-defined.
		However, in most cases it is expected that the availability of an attribute can
		be detected by any non-zero result.</p>
  <p>The <code>#ifdef</code> and <code>#ifndef</code> directives, and the <code>defined</code>
    conditional inclusion operator, shall treat <code>__has_cpp_attribute</code> as
		if it were the name of a defined macro. The identifier <code>__has_cpp_attribute</code>
    shall not appear in any context not mentioned in this section.</p>
  <h4>Example</h4>
  <p>This demonstrates a way to use the attribute <code>[[deprecated]]</code> only
		if it is available.</p>
  <pre><ins>#ifndef __has_cpp_attribute</ins>
<ins># define __has_cpp_attribute(x) 0</ins>
<ins>#endif</ins>
<del>#ifdef __has_cpp_attribute</del>
#if __has_cpp_attribute(deprecated)
# define ATTR_DEPRECATED(msg) [[deprecated(msg)]]
#else
# define ATTR_DEPRECATED(msg)
#endif
<del>#endif</del>
</pre>
  <h3 id="recs.cpp17">C++17 features</h3>
  <p>The following table itemizes all the changes that were made to the working draft
		for C++17 as specified in a WG21 technical document. (Changes that were made as
		specified in a core or library issue are not generally included.)</p>
  <p>The table is sorted by the section of the standard primarily affected. The &ldquo;Doc.
		No.&rdquo; column links to the paper itself on the committee web site. The &ldquo;Macro
		Name&rdquo; column links to the relevant portion of the &ldquo;Detailed explanation
		and rationale&rdquo; section of this document.
	When the recommendation is to change the value
	    of a macro previously recommended to be defined,
	    the &ldquo;Value&rdquo; column links to the table entry
	    for the previous recommendation.</p>
  <p>For library features, the &ldquo;Header&ldquo; column identifies the header
		that is expected to define the macro, although the macro may also be predefined.
		For language features, the macro must be predefined.</p>
  <table border="1">
    <caption>Significant changes to C++17</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0296r2.html">P0296R2</a></td>
	<td>Forward progress guarantees: Base definitions</td>
	<td>1.10</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0296"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0299r1.html">P0299R1</a></td>
	<td>Forward progress guarantees for the Parallelism TS features</td>
	<td>1.10, 25.2</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0299"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4086.html">N4086</a></td>
	<td>Removing trigraphs??!</td>
	<td>2.4</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4086"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0245r1.html">P0245R1</a></td>
	<td>Hexadecimal floating literals for C++</td>
	<td>2.13</td>
	<td><a href="p0096r4.html#detail.cpp17.p0245"><code>__cpp_hex_float</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4267.html">N4267</a></td>
	<td>Adding u8 character literals</td>
	<td>2.14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4267"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf">P0386R2</a></td>
	<td>Inline Variables</td>
	<td>3.6, 7.1</td>
	<td><a href="p0096r4.html#detail.cpp17.p0386"><code>__cpp_inline_variables</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0035r4.html">P0035R4</a></td>
	<td>Dynamic memory allocation for over-aligned data</td>
	<td>3.7, 5.3, 18.6</td>
	<td><a href="p0096r4.html#detail.cpp17.p0035"><code>__cpp_aligned_new</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">P0135R1</a></td>
	<td>Wording for guaranteed copy elision through simplified value categories</td>
	<td>3.10</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0135"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4261.html">N4261</a></td>
	<td>Proposed resolution for Core Issue 330: Qualification conversions and pointers to arrays of pointers</td>
	<td>4.4, 5.2</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4261"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html">P0012R1</a></td>
	<td>Make exception specifications be part of the type system</td>
	<td>4.12, 15.4</td>
	<td><a href="p0096r4.html#detail.cpp17.p0012" id="__cpp_noexcept_function_type"><code>__cpp_noexcept_function_type</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a></td>
	<td>Refining Expression Evaluation Order for Idiomatic C++</td>
	<td>5</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0145"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4295.html">N4295</a></td>
	<td>Folding expressions</td>
	<td>5.1, 14.5, 14.6</td>
	<td><a href="p0096r4.html#detail.cpp17.n4295" id="__cpp_fold_expressions_201411"><code>__cpp_fold_expressions</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html">P0018R3</a></td>
	<td>Lambda Capture of *this by Value as [=,*this]</td>
	<td>5.1</td>
	<td><a href="p0096r4.html#detail.cpp17.p0018"><code>__cpp_capture_star_this</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0170r1.pdf">P0170R1</a></td>
	<td>Wording for Constexpr Lambda</td>
	<td>5.1</td>
	<td><a href="p0096r4.html#detail.cpp17.p0170"><code>__cpp_constexpr</code></a></td>
	<td><a href="p0096r4.html#__cpp_constexpr_201304">201603</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0002r1.html">P0002R1</a></td>
	<td>Remove Deprecated operator++(bool)</td>
	<td>5.3</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0002"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r2.html">P0292R2</a></td>
	<td>constexpr if: A slightly different syntax</td>
	<td>6.4</td>
	<td><a href="p0096r4.html#detail.cpp17.p0292"><code>__cpp_if_constexpr</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html">P0305R1</a></td>
	<td>Selection statements with initializer</td>
	<td>6.4</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0305"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html">P0184R0</a></td>
	<td>Generalizing the Range-Based For Loop</td>
	<td>6.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0184"><code>__cpp_range_based_for</code></a></td>
	<td><a href="p0096r4.html#__cpp_range_based_for_200907">201603</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3928.pdf">N3928</a></td>
	<td>Extending static_assert</td>
	<td>7</td>
	<td><a href="p0096r4.html#detail.cpp17.n3928" id="__cpp_static_assert"><code>__cpp_static_assert</code></a></td>
	<td><a href="p0096r4.html#__cpp_static_assert_200410">201411</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html">N3922</a></td>
	<td>New Rules for auto deduction from braced-init-list</td>
	<td>7.1</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n3922"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0001r1.html">P0001R1</a></td>
	<td>Remove Deprecated Use of the register Keyword</td>
	<td>7.1</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0001"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">P0091R3</a></td>
	<td>Template argument deduction for class templates</td>
	<td>7.1, 13.3, 14.9</td>
	<td><a href="p0096r4.html#detail.cpp17.p0091"><code>__cpp_deduction_guides</code></a> <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0512r0.pdf">P0512R0</a></td>
	<td>Class Template Argument Deduction Assorted NB resolution and issues</td>
	<td>13.3, 14.9</td>
	<td><a href="p0096r4.html#detail.cpp17.p0512"><code>__cpp_deduction_guides</code></a> <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0127r2.html">P0127R2</a></td>
	<td>Declaring non-type template parameters with auto</td>
	<td>7.1, 14.8</td>
	<td><a href="p0096r4.html#detail.cpp17.p0127"><code>__cpp_template_auto</code></a><br />
	  <code>__cpp_nontype_template_argument_auto</code>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4266.html">N4266</a></td>
	<td rowspan="2">Attributes for namespaces and enumerators</td>
	<td rowspan="2">7.2, 7.3</td>
	<td><a href="p0096r4.html#detail.cpp17.n4266" id="__cpp_namespace_attributes"><code>__cpp_namespace_attributes</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0096r4.html#detail.cpp17.n4266" id="__cpp_enumerator_attributes"><code>__cpp_enumerator_attributes</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4230.html">N4230</a></td>
	<td>Nested namespace definition</td>
	<td>7.3</td>
	<td><a href="p0096r4.html#detail.cpp17.n4230"><code>__cpp_nested_namespace_definitions</code> <span class="editornote">ex.</span><br />
	  <em>none</em></a>
	</td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html">P0136R1</a></td>
	<td>Rewording inheriting constructors (core issue 1941 et al)</td>
	<td>7.3</td>
	<td><a href="p0096r4.html#detail.cpp17.p0136" id="__cpp_inheriting_constructors"><code>__cpp_inheriting_constructors</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td><a href="p0096r4.html#__cpp_inheriting_constructors_200802">201511</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0195r2.html">P0195R2</a></td>
	<td>Pack expansions in using-declarations</td>
	<td>7.3</td>
	<td><a href="p0096r4.html#detail.cpp17.p0195"><code>__cpp_variadic_using</code></a></td>
	<td>201611</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r1.pdf">P0188R1</a></td>
	<td>Wording for [[fallthrough]] attribute</td>
	<td>7.6</td>
	<td><code>__has_cpp_attribute(fallthrough)</code></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r1.pdf">P0189R1</a></td>
	<td>Wording for [[nodiscard]] attribute</td>
	<td>7.6</td>
	<td><code>__has_cpp_attribute(nodiscard)</code></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r1.pdf">P0212R1</a></td>
	<td>Wording for [[maybe_unused]] attribute</td>
	<td>7.6</td>
	<td><code>__has_cpp_attribute(maybe_unused)</code></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0028r4.html">P0028R4</a></td>
	<td>Using attribute namespaces without repetition</td>
	<td>7.6</td>
	<td><a href="p0096r4.html#detail.cpp17.p0028" class="editornote">???</a></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0283r2.html">P0283R2</a></td>
	<td>Standard and non-standard attributes</td>
	<td>7.6</td>
	<td><a href="p0096r4.html#detail.cpp17.p0283" class="editornote">???</a></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r1.html">P0017R1</a></td>
	<td>Extension to aggregate initialization</td>
	<td>8.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0017"><code>__cpp_aggregate_bases</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0138r2.pdf">P0138R2</a></td>
	<td>Construction Rules for enum class Values</td>
	<td>8.5</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0138"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r3.html">P0217R3</a></td>
	<td>Proposed wording for structured bindings</td>
	<td>8.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0217"><code>__cpp_structured_bindings</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0398r0.html">P0398R0</a></td>
	<td>Core issue 1518: Explicit default constructors and copy-list-initialization </td>
	<td>8.5</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0398"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0134r0.html">P0134R0</a></td>
	<td>Introducing a name for brace-or-equal-initializers for non-static data members</td>
	<td>9.2</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0134"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0391r0.html">P0391R0</a></td>
	<td>Introducing the term "templated entity"</td>
	<td>14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0391"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4051.html">N4051</a></td>
	<td>Allow typename in a template template parameter</td>
	<td>14.1</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4051"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html">N4268</a></td>
	<td>Allow constant evaluation for all non-type template arguments</td>
	<td>14.3</td>
	<td><a href="p0096r4.html#detail.cpp17.n4268" id="__cpp_nontype_template_args"><code>__cpp_nontype_template_args</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html">P0522R0</a></td>
	<td>Matching of template template-arguments excludes compatible templates</td>
	<td>14.3</td>
	<td><a href="p0096r4.html#detail.cpp17.p0522"><code>__cpp_template_template_args</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td>201611</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0036r0.pdf">P0036R0</a></td>
	<td>Unary Folds and Empty Parameter Packs</td>
	<td>14.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0036" id="__cpp_fold_expressions"><code>__cpp_fold_expressions</code></a></td>
	<td><a href="p0096r4.html#__cpp_fold_expressions_201411">201603</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4262.pdf">N4262</a></td>
	<td>Wording for Forwarding References</td>
	<td>14.8</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4262"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4285.html">N4285</a></td>
	<td>Cleanup for exception-specification and throw-expression</td>
	<td>15</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4285"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r5.html">P0003R5</a></td>
	<td>Removing Deprecated Exception Specifications from C++17</td>
	<td>15.4</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0003"><span class="editornote">???</span></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0061r1.html">P0061R1</a></td>
	<td>__has_include for C++17</td>
	<td>16.1</td>
	<td><a href="p0096r4.html#detail.cpp17.p0061" id="__has_include"><code>__has_include</code></a></td>
	<td><em>defined</em></td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0063r3.html">P0063R3</a></td>
	<td>C++17 should refer to C11 instead of C99</td>
	<td>17.6</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0063"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0180r2.html">P0180R2</a></td>
	<td>Reserve a New Library Namespace Future Standardization</td>
	<td>17.6</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0180"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0175r1.html">P0175R1</a></td>
	<td>Synopses for the C library</td>
	<td>18 etc.</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0175"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="p0298r3.pdf">P0298R3</a></td>
	<td>A byte type definition</td>
	<td>18.2</td>
	<td><a href="p0096r4.html#detail.cpp17.p0298"><code>__cpp_lib_byte</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;cstddef&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0154r1.html">P0154R1</a></td>
	<td>constexpr std::hardware_{constructive,destructive}_interference_size</td>
	<td>18.6</td>
	<td><a href="p0096r4.html#detail.cpp17.p0154"><code>__cpp_lib_hardware_interference_size</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;new&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html">P0137R1</a></td>
	<td>Core Issue 1776: Replacement of class objects containing reference members</td>
	<td>18.6, 1.8</td>
	<td><a href="p0096r4.html#detail.cpp17.p0137"><code>__cpp_lib_launder</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;new&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4259.pdf">N4259</a></td>
	<td>Wording for std::uncaught_exceptions</td>
	<td>18.8</td>
	<td><a href="p0096r4.html#detail.cpp17.n4259" id="__cpp_lib_uncaught_exceptions"><code>__cpp_lib_uncaught_exceptions</code></a></td>
	<td>201411</td>
	<td><code>&lt;exception&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0067r5.html">P0067R5</a></td>
	<td>Elementary string conversions</td>
	<td>20</td>
	<td><a href="p0096r4.html#detail.cpp17.p0067"><code>__cpp_lib_to_chars</code></a> <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr class="ins">
	<td rowspan="12"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html">P0220R1</a></td>
	<td rowspan="12">Adopt Library Fundamentals V1 TS Components
	  for C++17</td>
	<td rowspan="8">20</td>
	<td><code>__has_include(&lt;optional&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="p0096r4.html#detail.cpp17.p0220"><code>__cpp_lib_optional</code></a></td>
	<td>201603</td>
	<td><code>&lt;optional&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><code>__has_include(&lt;any&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="p0096r4.html#detail.cpp17.p0220"><code>__cpp_lib_any</code></a></td>
	<td>201603</td>
	<td><code>&lt;any&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><code>__has_include(&lt;string_view&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="p0096r4.html#detail.cpp17.p0220"><code>__cpp_lib_string_view</code></a></td>
	<td>201603</td>
	<td><code>&lt;string_view&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><code>__has_include(&lt;memory_resource&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="p0096r4.html#detail.cpp17.p0220"><code>__cpp_lib_memory_resource</code></a></td>
	<td>201603</td>
	<td><code>&lt;memory_resource&gt;</code></td>
      </tr>
      <tr class="ins">
	<td>20.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0220"><code>__cpp_lib_apply</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;tuple&gt;</code></td>
      </tr>
      <tr>
	<td>20.11</td>
	<td><a><code>__cpp_lib_shared_ptr_arrays</code></a>
	  <span class="editornote">edit fail</span></td>
	<td>201603</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr class="ins">
	<td>20.14</td>
	<td><a href="p0096r4.html#detail.cpp17.p0220"><code>__cpp_lib_boyer_moore_searcher</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr class="ins">
	<td>25.4</td>
	<td><a href="p0096r4.html#detail.cpp17.p0220"><code>__cpp_lib_sample</code></a> <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;algorithm&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0007r1.html">P0007R1</a></td>
	<td>Constant View: A proposal for a std::as_const helper function template</td>
	<td>20.2</td>
	<td><a href="p0096r4.html#detail.cpp17.p0007"><code>__cpp_lib_as_const</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf">P0032R3</a></td>
	<td>Homogeneous interface for variant, any and optional</td>
	<td>20.2, 20.6-8</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0032"><em>none</em></a>
	  <span class="editornote">?</span></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387">N4387</a></td>
	<td>Improving pair and tuple</td>
	<td>20.4, 20.5</td>
	<td><a href="p0096r4.html#detail.cpp17.n4387"><em>none</em></a>
	  <span class="editornote">???</span></td>
	<td>201505</td>
	<td><code>&lt;utility&gt; &lt;tuple&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0209r2.pdf">P0209R2</a></td>
	<td>make_from_tuple: apply for construction</td>
	<td>20.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0209"><code>__cpp_lib_make_from_tuple</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;tuple&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf">P0307R2</a></td>
	<td>Making Optional Greater Equal Again</td>
	<td>20.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0307" class="editornote">???</a></td>
	<td>201606</td>
	<td><code>&lt;optional&gt;</code></td>
      </tr>
      <tr class="ins">
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html">P0088R3</a></td>
	<td rowspan="2">Variant: a type-safe union for C++17</td>
	<td rowspan="2">20.7</td>
	<td><code>__has_include(&lt;variant&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="p0096r4.html#detail.cpp17.p0088"><code>__cpp_lib_variant</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td>201606</td>
	<td><code>&lt;variant&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0393r3.html">P0393R3</a></td>
	<td>Making Variant Greater Equal</td>
	<td>20.7</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0393"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0304r0.html">LWG2296</a></td>
	<td>std::addressof should be constexpr</td>
	<td>20.10</td>
	<td><a href="p0096r4.html#detail.cpp17.lwg2296" id="__cpp_lib_addressof_constexpr"><code>__cpp_lib_addressof_constexpr</code></a></td>
	<td>201603</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0040r3.html">P0040R3</a></td>
	<td>Extending memory management tools</td>
	<td>20.10</td>
	<td><a href="p0096r4.html#detail.cpp17.p0040" class="editornote">???</a></td>
	<td>201606</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html">P0174R2</a></td>
	<td>Deprecating Vestigial Library Parts in C++17</td>
	<td>20.10, 24.4</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0174"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4190.htm">N4190</a></td>
	<td>Removing auto_ptr, random_shuffle(), And Old &lt;functional&gt; Stuff</td>
	<td>20.11-20.14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4190"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0074r0.html">P0074R0</a></td>
	<td>Making std::owner_less more flexible</td>
	<td>20.11</td>
	<td><a href="p0096r4.html#detail.cpp17.p0074"><code>__cpp_lib_transparent_operators</code></a></td>
	<td><a href="p0096r4.html#__cpp_lib_transparent_operators_201210">201510</a></td>
	<td><code>&lt;memory&gt; &lt;functional&gt;</code>
	  <span class="editornote">?</span>
	</td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4089.pdf">N4089</a></td>
	<td>Safe conversions in unique_ptr&lt;T[]&gt;</td>
	<td>20.11</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4089"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4366.html">N4366</a></td>
	<td>LWG 2228: Missing SFINAE rule in unique_ptr templated assignment</td>
	<td>20.11</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4366"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0033r1.html">P0033R1</a></td>
	<td>Re-enabling shared_from_this</td>
	<td>20.11</td>
	<td><a href="p0096r4.html#detail.cpp17.p0033"><code>__cpp_lib_enable_shared_from_this</code></a></td>
	<td>201603</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0163r0.html">P0163R0</a></td>
	<td>shared_ptr::weak_type</td>
	<td>20.11</td>
	<td><a href="p0096r4.html#detail.cpp17.p0163"><code>__cpp_lib_shared_ptr_weak_type</code></a></td>
	<td>201606</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0497r0.html">P0497R0</a></td>
	<td>Fixes to shared_ptr support for arrays</td>
	<td>20.11</td>
	<td><a href="p0096r4.html#detail.cpp17.p0497"><code>__cpp_lib_shared_ptr_arrays</code></a> <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0337r0.html">P0337R0</a></td>
	<td>Delete operator= for polymorphic_allocator</td>
	<td>20.12</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0337"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html">N4169</a></td>
	<td>A proposal to add invoke function template</td>
	<td>20.14</td>
	<td><a href="p0096r4.html#detail.cpp17.n4169" id="__cpp_lib_invoke"><code>__cpp_lib_invoke</code></a></td>
	<td>201411</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a></td>
	<td>TriviallyCopyable reference_wrapper</td>
	<td>20.14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4277"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0005r4.html">P0005R4</a></td>
	<td>Adopt not_fn from Library Fundamentals 2 for C++17</td>
	<td>20.14</td>
	<td><a href="p0096r4.html#detail.cpp17.p0005"><code>__cpp_lib_not_fn</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0358r1.html">P0358R1</a></td>
	<td>Fixes for not_fn</td>
	<td>20.14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0358"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0253r1.pdf">P0253R1</a></td>
	<td>Fixing a design mistake in the searchers interface
	  in Library Fundamentals</td>
	<td>20.14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0253"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a></td>
	<td>Removing Allocator Support in std::function</td>
	<td>20.14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0302"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911.pdf">N3911</a></td>
	<td>TransformationTrait Alias void_t</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.n3911" id="__cpp_lib_void_t"><code>__cpp_lib_void_t</code></a></td>
	<td>201411</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4389.html">N4389</a></td>
	<td>Wording for bool_constant</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.n4389" id="__cpp_lib_bool_constant"><code>__cpp_lib_bool_constant</code></a></td>
	<td>201505</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0006r0.html">P0006R0</a></td>
	<td>Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.p0006"><code>__cpp_lib_type_trait_variable_templates</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a></td>
	<td>Logical Operator Type Traits</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.p0013"><code>__cpp_lib_logical_traits</code></a></td>
	<td>201510</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r1.html">P0185R1</a></td>
	<td>Adding [nothrow-]swappable traits</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.p0185" id="__cpp_lib_is_swappable"><code>__cpp_lib_is_swappable</code></a>
	</td>
	<td>201603</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="p0604r0.html">P0604R0</a></td>
	<td>Resolving GB 55, US 84, US 85, US 86</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.p0604"><code>__cpp_lib_is_invocable</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0258r2.html">P0258R2</a></td>
	<td>has_unique_object_representations - wording</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.p0258"><code>__cpp_lib_has_unique_object_representations</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://wiki.edg.com/pub/Wg21kona2017/StrawPolls/P0625R0.html#2911">LWG2911</a></td>
	<td>An is_aggregate type trait is needed</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.lwg2911"><code>__cpp_lib_is_aggregate</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0092r1.html">P0092R1</a></td>
	<td>Polishing &lt;chrono&gt;</td>
	<td>20.17</td>
	<td><a href="p0096r4.html#detail.cpp17.p0092"><code>__cpp_lib_chrono</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><code>&lt;chrono&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0505r0.html">P0505R0</a></td>
	<td>Wording for GB 50</td>
	<td>20.17</td>
	<td><a href="p0096r4.html#detail.cpp17.p0505"><code>__cpp_lib_chrono</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><code>&lt;chrono&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0336r1.pdf">P0336R1</a></td>
	<td>Better Names for Parallel Execution Policies in C++17</td>
	<td>20.19</td>
	<td><a href="p0096r4.html#detail.cpp17.p0336" class="editornote">???</a></td>
	<td>201606</td>
	<td><code>&lt;execution&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0254r2.pdf">P0254R2</a></td>
	<td>Integrating std::string_view and std::string</td>
	<td>21.3, 21.4</td>
	<td><a href="p0096r4.html#detail.cpp17.p0254" class="editornote">???</a></td>
	<td>201606</td>
	<td><code>&lt;string&gt; &lt;string_view&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0272r1.html">P0272R1</a></td>
	<td>Give 'std::string' a non-const
	  '.data()' member function</td>
	<td>21.4</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0272"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a></td>
	<td>Cleaning-up noexcept in the Library</td>
	<td>21.4, 23.3-23.5</td>
	<td><a href="p0096r4.html#detail.cpp17.n4258" id="__cpp_lib_allocator_traits_is_always_equal"><code>__cpp_lib_allocator_traits_is_always_equal</code></a></td>
	<td>201411</td>
	<td><code>&lt;memory&gt;</code> <code>&lt;scoped_allocator&gt;</code>
	  <code>&lt;string&gt;</code> <code>&lt;deque&gt;</code><br />
	  <code>&lt;forward_list&gt;</code> <code>&lt;list&gt;</code>
	  <code>&lt;vector&gt;</code> <code>&lt;map&gt;</code><br />
	  <code>&lt;set&gt;</code> <code>&lt;unordered_map&gt;</code> <code>&lt;unordered_set&gt;</code>
	</td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html">P0618R0</a></td>
	<td>Deprecating &lt;codecvt&gt;</td>
	<td>22.5</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0618"><em>none</em></a>
	  <span class="editornote">?</span>
	</td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4284.html">N4284</a></td>
	<td>Contiguous Iterators</td>
	<td>23.2, 24.2</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.n4284"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a></td>
	<td>Minimal incomplete type support for standard containers</td>
	<td>23.3</td>
	<td><a href="p0096r4.html#detail.cpp17.n4510"><code>__cpp_lib_incomplete_container_elements</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201505</td>
	<td><em class="editornote">headers</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0084r2.pdf">P0084R2</a></td>
	<td>Emplace Return Type</td>
	<td>23.3</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0084"><em>none</em></a></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a></td>
	<td rowspan="2">Improved insertion interface for unique-key maps</td>
	<td>23.4</td>
	<td><a href="p0096r4.html#detail.cpp17.n4279" id="__cpp_lib_map_try_emplace"><code>__cpp_lib_map_try_emplace</code></a></td>
	<td>201411</td>
	<td><code>&lt;map&gt;</code></td>
      </tr>
      <tr>
	<td>23.5</td>
	<td>
	  <a href="p0096r4.html#detail.cpp17.n4279" id="__cpp_lib_unordered_map_try_emplace"><code>__cpp_lib_unordered_map_try_emplace</code></a></td>
	<td>201411</td>
	<td><code>&lt;unordered_map&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf">P0083R3</a></td>
	<td>Splicing Maps and Sets</td>
	<td>23.3</td>
	<td><a href="p0096r4.html#detail.cpp17.p0083"><code>__cpp_lib_node_extract</code></a></td>
	<td>201606</td>
	<td><code>&lt;map&gt; &lt;set&gt; &lt;unordered_map&gt; &lt;unordered_set&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf">N4280</a></td>
	<td>Non-member size() and more</td>
	<td>24.3</td>
	<td><a href="p0096r4.html#detail.cpp17.n4280" id="__cpp_lib_nonmember_container_access"><code>__cpp_lib_nonmember_container_access</code></a></td>
	<td>201411</td>
	<td><code>&lt;iterator&gt; &lt;array&gt; &lt;deque&gt; &lt;forward_list&gt;<br />
		    &lt;list&gt; &lt;map&gt; &lt;regex&gt; &lt;set&gt; &lt;string&gt;<br />
		    &lt;unordered_map&gt; &lt;unordered_set&gt; &lt;vector&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html">P0031R0</a></td>
	<td>A Proposal to Add Constexpr Modifiers
	  to reverse_iterator, move_iterator, array
	  and Range Access</td>
	<td>24.3</td>
	<td><a href="p0096r4.html#detail.cpp17.p0031"><code>__cpp_lib_array_constexpr</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;iterator&gt; &lt;array&gt;</code></td>
      </tr>
      <tr class="ins">
	<td rowspan="3"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html">P0024R2</a></td>
	<td rowspan="3">The Parallelism TS Should be Standardized</td>
	<td rowspan="2">20</td>
	<td><code>__has_include(&lt;execution&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="p0096r4.html#detail.cpp17.p0024"><code>__lib_cpp_execution</code></a>
	  <span class="editornote">?</span></td>
	<td>201603</td>
	<td><code>&lt;execution&gt;</code></td>
      </tr>
      <tr class="ins">
	<td>25, 26</td>
	<td><a href="p0096r4.html#detail.cpp17.p0024"><code>__cpp_lib_parallel_algorithm</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td>201603</td>
	<td><code>&lt;algorithm&gt;</code> <code>&lt;numeric&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0394r4.html">P0394R4</a></td>
	<td>Hotel Parallelifornia: terminate() for Parallel Algorithms Exception Handling</td>
	<td>25.2, 18.8</td>
	<td><a href="p0096r4.html#detail.cpp17.p0394" class="editornote">???</a>
	</td>
	<td>201606</td>
	<td><code>&lt;execution&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0025r0.html">P0025R0</a></td>
	<td>An algorithm to "clamp" a value
	  between a pair of boundary values</td>
	<td>25.4</td>
	<td><a href="p0096r4.html#detail.cpp17.p0025"><code>__cpp_lib_clamp</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;algorithm&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0346r1.pdf">P0346R1</a></td>
	<td>A &lt;random&gt; Nomenclature Tweak</td>
	<td>26.6</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0346"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0295r0.pdf">P0295R0</a></td>
	<td>Adopt Selected Library Fundamentals V2 Components for C++17</td>
	<td>26.8</td>
	<td><a href="p0096r4.html#detail.cpp17.p0295"><code>__cpp_lib_gcd<br />
	  __cpp_lib_lcm</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;numeric&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0030r1.pdf">P0030R1</a></td>
	<td>Proposal to Introduce a 3-Argument Overload
	  to std::hypot</td>
	<td>26.9</td>
	<td><a href="p0096r4.html#detail.cpp17.p0030"><code>__cpp_lib_hypot</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;cmath&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0226r1.pdf">P0226R1</a></td>
	<td>Mathematical Special Functions for C++17</td>
	<td>26.10</td>
	<td><a href="p0096r4.html#detail.cpp17.p0226"><code>__cpp_lib_math_special_functions</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;cmath&gt;</code></td>
      </tr>
      <tr class="ins">
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r1.html">P0218R1</a></td>
	<td rowspan="2">Adopt the File System TS for C++17</td>
	<td rowspan="2">27.10</td>
	<td><code>__has_include(&lt;filesystem&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="p0096r4.html#detail.cpp17.p0218"><code>__cpp_lib_filesystem</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0219r1.html">P0219R1</a></td>
	<td>Relative Paths for Filesystem</td>
	<td>27.10</td>
	<td><a href="p0096r4.html#detail.cpp17.p0219" class="editornote">???</a></td>
	<td>201606</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0317r1.html">P0317R1</a></td>
	<td>Directory Entry Caching for Filesystem</td>
	<td>27.10</td>
	<td><a href="p0096r4.html#detail.cpp17.p0317" class="editornote">???</a></td>
	<td>201703</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0392r0.pdf">P0392R0</a></td>
	<td>Adapting string_view by filesystem paths</td>
	<td>27.10</td>
	<td><a href="p0096r4.html#detail.cpp17.p0392" class="editornote">???</a></td>
	<td>201606</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html">P0371R1</a></td>
	<td>Temporarily discourage memory_order_consume</td>
	<td>29.3</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0371"><em>none</em></a></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0152r1.html">P0152R1</a></td>
	<td>constexpr atomic&lt;T&gt;::is_always_lock_free</td>
	<td>29.5</td>
	<td><a href="p0096r4.html#detail.cpp17.p0152"><code>__cpp_lib_atomic_is_always_lock_free</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;atomic&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4508.html">N4508</a></td>
	<td>A proposal to add shared_mutex (untimed)</td>
	<td>30.4</td>
	<td><a href="p0096r4.html#detail.cpp17.n4508"><code>__cpp_lib_shared_mutex</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201505</td>
	<td><code>&lt;shared_mutex&gt;</code></td>
      </tr>
      <tr>
	<td><del><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0156r0.html">P0156R0</a></del></td>
	<td><del>Variadic lock_guard</del></td>
	<td><del>30.4</del></td>
	<td><del><a href="p0096r4.html#detail.cpp17.p0156r0"><code>__cpp_lib_lock_guard_variadic</code></a></del></td>
	<td><del>201510</del></td>
	<td><del><code>&lt;thread&gt;</code></del></td>
      </tr>
      <tr class="ins">
	<td><a href="p0156r2.html">P0156R2</a></td>
	<td>Variadic lock_guard (Rev. 5)</td>
	<td>30.4</td>
	<td><a href="p0096r4.html#detail.cpp17.p0156r2"><code>__cpp_lib_scoped_lock</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;mutex&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0004r1.html">P0004R1</a></td>
	<td>Remove Deprecated iostreams aliases</td>
	<td>D</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp17.p0004"><em>none</em></a></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.cpp14">C++14 features</h3>
  <p>
    The following table itemizes all the changes that were made to the working draft
		for C++14 as specified in a WG21 technical document. (Changes that were made as
		specified in a core or library issue are not generally included.)
  </p>
  <p>
    The table is sorted by the section of the standard primarily affected. The &ldquo;Doc.
		No.&rdquo; column links to the paper itself on the committee web site. The &ldquo;Macro
		Name&rdquo; column links to the relevant portion of the &ldquo;Detailed explanation
		and rationale&rdquo; section of this document.
	When the recommendation is to change the value
	    of a macro previously recommended to be defined,
	    the &ldquo;Value&rdquo; column links to the table entry
	    for the previous recommendation.
  </p>
  <p>
    For library features, the &ldquo;Header&ldquo; column identifies the header
		that is expected to define the macro, although the macro may also be predefined.
		For language features, the macro must be predefined.
  </p>
  <table border="1">
    <caption>Significant changes to C++14</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3910.html">N3910</a>
	</td>
	<td>What can signal handlers do? (CWG 1441)</td>
	<td>1.9-1.10</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3910">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3927.html">N3927</a>
	</td>
	<td>Definition of Lock-Free</td>
	<td>1.10</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3927">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3472.pdf">N3472</a>
	</td>
	<td>Binary Literals in the C++ Core Language</td>
	<td>2.14</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3472" id="__cpp_binary_literals">__cpp_binary_literals</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3781.pdf">N3781</a>
	</td>
	<td>Single-Quotation-Mark as a Digit Separator</td>
	<td>2.14</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp14.n3781"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3323.pdf">N3323</a>
	</td>
	<td>A Proposal to Tweak Certain C++ Contextual Conversions</td>
	<td>4</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3323">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3648.html">N3648</a>
	</td>
	<!--feedback-->
	<td>Wording Changes for Generalized Lambda-capture</td>
	<td>5.1</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3648" id="__cpp_init_captures">__cpp_init_captures</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3649.html">N3649</a>
	</td>
	<!--feedback-->
	<td>Generic (Polymorphic) Lambda Expressions</td>
	<td>5.1</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3649" id="__cpp_generic_lambdas">__cpp_generic_lambdas</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html">N3664</a>
	</td>
	<td>Clarifying Memory Allocation</td>
	<td>5.3</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3664">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3778.html">N3778</a>
	</td>
	<td>C++ Sized Deallocation</td>
	<td>5.3, 18.6</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3778" id="__cpp_sized_deallocation">__cpp_sized_deallocation</a></code></td>
	<td>201309</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3624.html">N3624</a>
	</td>
	<td>Core Issue 1512: Pointer comparison vs qualification conversions</td>
	<td>5.9, 5.10</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3624">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>
	</td>
	<td>Relaxing constraints on constexpr functions / constexpr member functions and implicit
					const</td>
	<td>5.19, 7.1</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3652" id="__cpp_constexpr_201304">__cpp_constexpr</a></code></td>
	<td><a href="p0096r4.html#__cpp_constexpr_200704">201304</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html">N3638</a></td>
	<!--feedback-->
	<td rowspan="2">Return type deduction for normal functions</td>
	<td rowspan="2">7.1</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3638" id="__cpp_decltype_auto">__cpp_decltype_auto</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><code><a href="p0096r4.html#detail.cpp14.n3638" id="__cpp_return_type_deduction">__cpp_return_type_deduction</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3760.html">N3760</a>
	</td>
	<td>[[deprecated]] attribute</td>
	<td>7.6</td>
	<td><code>__has_cpp_attribute(deprecated)</code></td>
	<td>201309</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html">N3653</a>
	</td>
	<td>Member initializers and aggregates</td>
	<td>8.5</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3653" id="__cpp_aggregate_nsdmi">__cpp_aggregate_nsdmi</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3667.html">N3667</a>
	</td>
	<td>Drafting for Core 1402</td>
	<td>12.8</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3667">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3651.pdf">N3651</a>
	</td>
	<td>Variable Templates</td>
	<td>14, 14.7</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3651" id="__cpp_variable_templates">__cpp_variable_templates</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3669.pdf">N3669</a>
	</td>
	<td>Fixing constexpr member functions without const</td>
	<td><em>various</em></td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3669">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3673.html">N3673</a>
	</td>
	<td>C++ Library Working Group Ready Issues Bristol 2013</td>
	<td><em>various</em></td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3673">none</a></em></td>
      </tr>
      <!--
			<tr>
				<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a>
				</td>
				<td>Constexpr Library Additions: utilities</td>
				<td>20.2-20.4</td>
				<td rowspan="3"><code><a href="#detail.cpp14.n3471">__cpp_lib_constexpr_functions</a></code>
				</td>
				<td rowspan="3">201210</td>
				<td><code>&lt;utility&gt;</code></td>
			</tr>
			<tr>
				<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3469.html">N3469</a>
				</td>
				<td>Constexpr Library Additions: chrono</td>
				<td>20.11</td>
				<td><code>&lt;chrono&gt;</code></td>
			</tr>
			<tr>
				<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3470.html">N3470</a>
				</td>
				<td>Constexpr Library Additions: containers</td>
				<td>23.3</td>
				<td><code>&lt;array&gt;</code></td>
			</tr>
-->
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html">N3658</a>
	</td>
	<!--feedback-->
	<td>Compile-time integer sequences</td>
	<td>20</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3658" id="__cpp_lib_integer_sequence">__cpp_lib_integer_sequence</a></code></td>
	<td>201304</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3668.html">N3668</a>
	</td>
	<!--feedback-->
	<td>exchange() utility function</td>
	<td>20</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3668" id="__cpp_lib_exchange_function">__cpp_lib_exchange_function</a></code></td>
	<td>201304</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a>
	</td>
	<td>Constexpr Library Additions: utilities</td>
	<td>20.2-20.4</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp14.n3471"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3670.html">N3670</a>
	</td>
	<td>Wording for Addressing Tuples by Type</td>
	<td>20.2-20.4</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3670" id="__cpp_lib_tuples_by_type">__cpp_lib_tuples_by_type</a></code></td>
	<td>201304</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3887.pdf">N3887</a>
	</td>
	<td>Consistent Metafunction Aliases</td>
	<td>20.3-20.4</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3887" id="__cpp_lib_tuple_element_t">__cpp_lib_tuple_element_t</a></code></td>
	<td>201402</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <!--<tr>
				<td><code>__cpp_lib_header_optional</code></td>
				<td>201304</td>
				<td><code>&lt;utility&gt;</code></td>
			</tr>-->
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656.htm">N3656</a>
	</td>
	<!--feedback-->
	<td>make_unique</td>
	<td>20.7</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3656" id="__cpp_lib_make_unique">__cpp_lib_make_unique</a></code></td>
	<td>201304</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">N3421</a>
	</td>
	<!--feedback-->
	<td>Making Operator Functors greater&lt;&gt;</td>
	<td>20.8</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3421" id="__cpp_lib_transparent_operators_201210">__cpp_lib_transparent_operators</a></code>
	</td>
	<td>201210</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3545.pdf">N3545</a>
	</td>
	<td>An Incremental Improvement to integral_constant</td>
	<td>20.9</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3545" id="__cpp_lib_integral_constant_callable">__cpp_lib_integral_constant_callable</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf">N3655</a>
	</td>
	<td>TransformationTraits Redux</td>
	<td>20.9</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3655" id="__cpp_lib_transformation_trait_aliases">__cpp_lib_transformation_trait_aliases</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3789.txt">N3789</a>
	</td>
	<td>Constexpr Library Additions: functional</td>
	<td>20.10</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp14.n3789"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3462.html">N3462</a>
	</td>
	<!--feedback-->
	<td>std::result_of and SFINAE</td>
	<td>20.9<br />
	  20.10</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3462" id="__cpp_lib_result_of_sfinae">__cpp_lib_result_of_sfinae</a></code></td>
	<td>201210</td>
	<td><code>&lt;functional&gt;</code><br />
	  <code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3945.html#2112">LWG 2112</a></td>
	<td>User-defined classes that cannot be derived from</td>
	<td>20.10</td>
	<td><code><a href="p0096r4.html#detail.cpp14.lwg2112" id="__cpp_lib_is_final">__cpp_lib_is_final</a></code></td>
	<td>201402</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3822.html#2247">LWG 2247</a></td>
	<td>Type traits and std::nullptr_t</td>
	<td>20.10</td>
	<td><code><a href="p0096r4.html#detail.cpp14.lwg2247" id="__cpp_lib_is_null_pointer">__cpp_lib_is_null_pointer</a></code></td>
	<td>201309</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3469.html">N3469</a>
	</td>
	<td>Constexpr Library Additions: chrono</td>
	<td>20.11</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp14.n3471"><em>none</em></a></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642.pdf">N3642</a></td>
	<td rowspan="2">User-defined Literals for Standard Library Types</td>
	<td>20.11</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3642" id="__cpp_lib_chrono_udls">__cpp_lib_chrono_udls</a></code></td>
	<td>201304</td>
	<td><code>&lt;chrono&gt;</code></td>
      </tr>
      <tr>
	<td>21.7</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3642" id="__cpp_lib_string_udls">__cpp_lib_string_udls</a></code></td>
	<td>201304</td>
	<td><code>&lt;string&gt;</code></td>
      </tr>
      <!--<tr>
				<td><code>__cpp_lib_header_dynarray</code></td>
				<td>201304</td>
				<td><code>&lt;utility&gt;</code></td>
			</tr>-->
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3470.html">N3470</a>
	</td>
	<td>Constexpr Library Additions: containers</td>
	<td>23.3</td>
	<td colspan="3"><a href="p0096r4.html#detail.cpp14.n3471"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>
	</td>
	<!--feedback-->
	<td>Adding heterogeneous comparison lookup to associative containers</td>
	<td>23.4</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3657" id="__cpp_lib_generic_associative_lookup">__cpp_lib_generic_associative_lookup</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;map&gt;</code><br />
	  <code>&lt;set&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf">N3644</a>
	</td>
	<!--feedback-->
	<td>Null Forward Iterators</td>
	<td>24.2</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3644" id="__cpp_lib_null_iterators">__cpp_lib_null_iterators</a></code></td>
	<td>201304</td>
	<td><code>&lt;iterator&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3945.html#2285">LWG 2285</a></td>
	<td>make_reverse_iterator</td>
	<td>24.5</td>
	<td><code><a href="p0096r4.html#detail.cpp14.lwg2285" id="__cpp_lib_make_reverse_iterator">__cpp_lib_make_reverse_iterator</a></code>
	</td>
	<td>201402</td>
	<td><code>&lt;iterator&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3671.html">N3671</a>
	</td>
	<td>Making non-modifying sequence operations more robust</td>
	<td>25.2</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3671" id="__cpp_lib_robust_nonmodifying_seq_ops">__cpp_lib_robust_nonmodifying_seq_ops</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;algorithm&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3779.pdf">N3779</a>
	</td>
	<td>User-defined Literals for std::complex</td>
	<td>26.4</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3779" id="__cpp_lib_complex_udls">__cpp_lib_complex_udls</a></code></td>
	<td>201309</td>
	<td><code>&lt;complex&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3924.pdf">N3924</a>
	</td>
	<td>Discouraging rand() in C++14</td>
	<td>26.8</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3924">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3654.html">N3654</a>
	</td>
	<td>Quoted Strings Library Proposal</td>
	<td>27.7</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3654" id="__cpp_lib_quoted_string_io">__cpp_lib_quoted_string_io</a></code></td>
	<td>201304</td>
	<td><code>&lt;iomanip&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3945.html#2249">LWG 2249</a></td>
	<td>Remove gets from &lt;cstdio&gt;</td>
	<td>27.9</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.lwg2249">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3786.html">N3786</a>
	</td>
	<td>Prohibiting "out of thin air" results in C++14</td>
	<td>29.3</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3786">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3659.html">N3659</a>
	</td>
	<td>Shared locking in C++</td>
	<td>30.4</td>
	<td><a href="p0096r4.html#detail.cpp14.n3659"><code>__has_include(&lt;shared_mutex&gt;)</code></a>
	</td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3891.htm">N3891</a>
	</td>
	<td>A proposal to rename shared_mutex to shared_timed_mutex</td>
	<td>30.4</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3891" id="__cpp_lib_shared_timed_mutex">__cpp_lib_shared_timed_mutex</a></code></td>
	<td>201402</td>
	<td><code>&lt;shared_mutex&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3776.pdf">N3776</a>
	</td>
	<td>Wording for ~future</td>
	<td>30.6</td>
	<td colspan="3"><em><a href="p0096r4.html#detail.cpp14.n3776">none</a></em></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.cpp11">C++11 features</h3>
  <table border="1">
    <caption>Significant features of C++11</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html">N2249</a></td>
	<td>New Character Types in C++</td>
	<td>2.13</td>
	<td><a id="__cpp_unicode_characters"><code>__cpp_unicode_characters</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">N2442</a></td>
	<td rowspan="2">Raw and Unicode String Literals Unified Proposal</td>
	<td rowspan="2">2.13</td>
	<td><a id="__cpp_raw_strings"><code>__cpp_raw_strings</code></a></td>
	<td>200710</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a id="__cpp_unicode_literals"><code>__cpp_unicode_literals</code></a></td>
	<td>200710</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf">N2765</a></td>
	<td>User-defined Literals</td>
	<td>2.13, 13.5</td>
	<td><a id="__cpp_user_defined_literals"><code>__cpp_user_defined_literals</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm">N2660</a></td>
	<td>Dynamic Initialization and Destruction with Concurrency</td>
	<td>3.6</td>
	<td><a><code>__cpp_threadsafe_static_init</code></a></td>
	<td>200806</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a></td>
	<td>New wording for C++0x lambdas</td>
	<td>5.1</td>
	<td><a id="__cpp_lambdas"><code>__cpp_lambdas</code></a></td>
	<td>200907</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a></td>
	<td>Generalized Constant Expressions</td>
	<td>5.19, 7.1</td>
	<td><a id="__cpp_constexpr_200704"><code>__cpp_constexpr</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">N2930</a></td>
	<td>Range-Based For Loop Wording (Without Concepts)</td>
	<td>6.5</td>
	<td><a id="__cpp_range_based_for_200907"><code>__cpp_range_based_for</code></a></td>
	<td>200907</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">N1720</a></td>
	<td>Proposal to Add Static Assertions to the Core Language</td>
	<td>7</td>
	<td><a id="__cpp_static_assert_200410"><code>__cpp_static_assert</code></a></td>
	<td>200410</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">N2343</a></td>
	<td>Decltype</td>
	<td>7.1</td>
	<td><a id="__cpp_decltype"><code>__cpp_decltype</code></a></td>
	<td>200707</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="3"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">N2761</a></td>
	<td rowspan="3">Towards support for attributes in C++</td>
	<td rowspan="3">7.6</td>
	<td><a id="__cpp_attributes"><code>__cpp_attributes</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a><code>__has_cpp_attribute(noreturn)</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a><code>__has_cpp_attribute(carries_dependency)</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html">N2118</a></td>
	<td>A Proposal to Add an Rvalue Reference to the C++ Language</td>
	<td>8.3</td>
	<td><a id="__cpp_rvalue_references"><code>__cpp_rvalue_references</code></a></td>
	<td>200610</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">N2242</a></td>
	<td>Proposed Wording for Variadic Templates</td>
	<td>8.3, 14</td>
	<td><a id="__cpp_variadic_templates"><code>__cpp_variadic_templates</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.pdf">N2672</a></td>
	<td>Initializer List proposed wording</td>
	<td>8.5</td>
	<td><a id="__cpp_initializer_lists"><code>__cpp_initializer_lists</code></a></td>
	<td>200806</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">N1986</a></td>
	<td>Delegating Constructors</td>
	<td>12.6</td>
	<td><a id="__cpp_delegating_constructors"><code>__cpp_delegating_constructors</code></a></td>
	<td>200604</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm">N2756</a></td>
	<td>Non-static data member initializers</td>
	<td>12.6</td>
	<td><a id="__cpp_nsdmi"><code>__cpp_nsdmi</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm">N2540</a></td>
	<td>Inheriting Constructors</td>
	<td>12.9</td>
	<td><a id="__cpp_inheriting_constructors_200802"><code>__cpp_inheriting_constructors</code></a></td>
	<td>200802</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm">N2439</a></td>
	<td>Extending move semantics to *this</td>
	<td>13.3</td>
	<td><a id="__cpp_ref_qualifiers"><code>__cpp_ref_qualifiers</code></a></td>
	<td>200710</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">N2258</a></td>
	<td>Template Aliases</td>
	<td>14.5</td>
	<td><a id="__cpp_alias_templates"><code>__cpp_alias_templates</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.condsupp"><del>Conditionally-supported constructs</del></h3>
  <p class="note"><del>STUB</del></p>
  <!--
    <div class="editornote">
	<p>The standard requires implementations to document the conditionally-supported constructs
		it does <strong>not</strong> support. For consistency, the recommendation is to
		define a macro for each conditionally-supported construct that is diagnosed (not
		supported)</p>
	<table border="1">
	    <thead>
		<tr>
		    <th>Reference</th>
		    <th>Description</th>
		    <th>Macro name</th>
		</tr>
	    </thead>
	    <tbody>
		<tr>
		    <td>2.9p2</td>
		    <td>The appearance of either of the characters <code>'</code> or <code>\</code> or of
					either of the character sequences <code>/*</code> or <code>//</code> in a <var>q-char-sequence</var>
			or an <var>h-char-sequence</var> is conditionally supported with implementation-defined
					semantics, as is the appearance of the character <code>"</code> in an <var>h-char-sequence</var>.
		    </td>
		    <td><code>__cond_no_weird_header_names</code></td>
		</tr>
		<tr>
		    <td>2.14.3p1</td>
		    <td>A multicharacter literal,
	or an ordinary character literal containing a single <var>c-char</var>
	not representable in the execution character set, is conditionally-supported,
					has type <code>int</code>, and has an implementation-defined value.</td>
		    <td><code>__cond_no_multicharacter_literals</code></td>
		</tr>
		<tr>
		    <td>2.14.3p3</td>
		    <td>Escape sequences in which the character following the backslash is not listed in
					Table 7 are conditionally-supported, with implementation-defined semantics.</td>
		    <td><em>Probably no single macro would make sense for this.</em></td>
		</tr>
		<tr>
		    <td>2.14.5p13</td>
		    <td>Any other concatenations are conditionally supported with implementation-defined
					behavior.</td>
		    <td><em>Probably no single macro would make sense for this.</em></td>
		</tr>
		<tr>
		    <td>5.2.2p7</td>
		    <td>Passing a potentially-evaluated argument of class type (Clause 9) having a nontrivial
					copy constructor, a non-trivial move constructor, or a non-trivial destructor, with
					no corresponding parameter, is conditionally-supported with implementation-defined
					semantics.</td>
		    <td><code>__cond_no_passing_non_pod_by_ellipsis</code></td>
		</tr>
		<tr>
		    <td>5.2.10p8</td>
		    <td>Converting a function pointer to an object pointer type or vice versa is conditionally-supported.
		    </td>
		    <td><code>__cond_no_fun_obj_ptr_conversion</code></td>
		</tr>
		<tr>
		    <td>7.4p1</td>
		    <td>The asm declaration is conditionally-supported; its meaning is implementation-defined.
		    </td>
		    <td><code>__cond_no_asm_declaration</code></td>
		</tr>
		<tr>
		    <td>7.5p2</td>
		    <td>Use of a <var>string-literal</var> other than <code>"C"</code> or <code>"C++"</code>
			is conditionally-supported, with implementation-defined semantics.</td>
		    <td><em>Probably no single macro would make sense for this.</em></td>
		</tr>
		<tr>
		    <td>7.6.1p3</td>
		    <td>The use of an <var>attribute-scoped-token</var> is conditionally-supported, with
					implementation-defined behavior.</td>
		    <td><code>_cond_no_attribute_scoped_token</code></td>
		</tr>
		<tr>
		    <td>14p4</td>
		    <td>Use of a linkage specification other than C or C++ with any of these constructs
					is conditionally-supported, with implementation-defined semantics.</td>
		    <td><code>_cond_no_template_linkage_spec</code></td>
		</tr>
	    </tbody>
	</table>
    </div>
    -->
  <h3 id="recs.cpp98">C++98 features</h3>
  <p class="note"><del>STUB: especially for exception handling and RTTI</del></p>
  <p>
    <ins>With very few exceptions,
    the features of C++98 have all been implemented
    in virtually every C++ compiler.
    But in many compilers, some of them can be enabled/disabled.
    It is recommended that the macros in the following table
    should be used to indicate whether one of these features
    is enabled in the current compilation.</ins>
  </p>
  <table border="1">
    <thead>
      <tr>
	<th>Feature</th>
	<th>Primary section</th>
	<th>Macro name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td>Run-time type identification</td>
	<td>5.2</td>
	<td><code><a id="__cpp_rtti">__cpp_rtti</a></code></td>
	<td>199711</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td>Exception handling</td>
	<td>15</td>
	<td><code><a id="__cpp_exceptions">__cpp_exceptions</a></code></td>
	<td>199711</td>
	<td><em>predefined</em></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.removed">Features published and later removed</h3>
  <h4><ins>Features removed from C++17</ins></h4>
  <table border="1">
    <caption>Features in the CD of C++17, subsequently removed</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a></td>
	<td>is_callable, the missing INVOKE related trait</td>
	<td>20.15</td>
	<td><a href="p0096r4.html#detail.cpp17.p0077"><code>__cpp_lib_is_callable</code></a></td>
	<td>201603</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0181r1.html">P0181R1</a></td>
	<td>Ordered By Default</td>
	<td>20.14, 23.4, 23.6</td>
	<td><a href="p0096r4.html#detail.cpp17.p0181"><code>__cpp_lib_default_order</code></a></td>
	<td>201606</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr class="ins">
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0156r0.html">P0156R0</a></td>
	<td>Variadic lock_guard</td>
	<td>30.4</td>
	<td><a href="p0096r4.html#detail.cpp17.p0156r0"><code>__cpp_lib_lock_guard_variadic</code></a></td>
	<td>201510</td>
	<td><del><code>&lt;thread&gt;</code></del><br /><ins><code>&lt;mutex&gt;</code></ins></td>
      </tr>
    </tbody>
  </table>
  <h4 id="recs.removed.cpp14">Features removed from C++14</h4>
  <table border="1">
    <caption>Features in the first CD of C++14, subsequently removed to a Technical Specification</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3639.html">N3639</a>
	</td>
	<td>Runtime-sized arrays with automatic storage duration</td>
	<td>8.3</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3639" id="__cpp_runtime_arrays">__cpp_runtime_arrays</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>
	</td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">N3672</a>
	</td>
	<td>A proposal to add a utility class to represent optional objects</td>
	<td>20.5</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3672">__has_include(&lt;optional&gt;)</a></code>
	</td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3662.html">N3662</a>
	</td>
	<!--feedback-->
	<td>C++ Dynamic Arrays</td>
	<td>23.2, 23.3</td>
	<td><code><a href="p0096r4.html#detail.cpp14.n3662">__has_include(&lt;dynarray&gt;)</a></code>
	</td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
    </tbody>
  </table>
  <p>
    The intention is that an implementation which provides runtime-sized arrays
        as specified in the first CD
        should define <code>__cpp_runtime_arrays</code> as 201304.
        The expectation is that a later document specifying runtime-sized arrays
        will specify a different value for <code>__cpp_runtime_arrays</code>.
  </p>

  <h2 id="ts">Recommendations from Technical Specifications</h2>
  <p>
    In this section, feature-test macros from all WG21 Technical Specifications
	    are collected, for convenience.
  </p>
  <h3>C++ Extensions for Library Fundamentals</h3>
  <p>
    The recommended macro name is &quot;<code>__cpp_lib_experimental_</code>&quot;
	    followed by the string in the &quot;Macro Name Suffix&quot; column.
  </p>
  <table border="1">
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name Suffix</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <!-- These rows are in the same order as their feature appears in this document. -->
    <tr>
      <td>N3915</td>
      <td>apply() call a function with arguments from a tuple</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#tuple.apply" title="tuple.apply">3.2.2</a></td>
      <td><code>apply</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/tuple&gt;</code></td>
    </tr>
    <tr>
      <td>N3932</td>
      <td>Variable Templates For Type Traits</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#meta.type.synop" title="meta.type.synop">3.3.1</a></td>
      <td><code>type_trait_variable_templates</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/type_traits&gt;</code></td>
    </tr>
    <tr>
      <td>N3866</td>
      <td>Invocation type traits</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#meta.trans.other" title="meta.trans.other">3.3.2</a></td>
      <td><code>invocation_type</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/type_traits&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Type-erased allocator for std::function</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#func.wrap.func" title="func.wrap.func">4.2</a></td>
      <td><code>function_erased_allocator</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/functional&gt;</code></td>
    </tr>
    <tr>
      <td>N3905</td>
      <td>Extending <code>std::search</code> to use Additional Searching Algorithms</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#func.searchers" title="func.searchers">4.3</a></td>
      <td><code>boyer_moore_searching</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/functional&gt;</code></td>
    </tr>
    <tr>
      <td>N3672, N3793</td>
      <td>A utility class to represent optional objects</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#optional" title="optional">5</a></td>
      <td><code>optional</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/optional&gt;</code></td>
    </tr>
    <tr>
      <td>N3804</td>
      <td>Any Library Proposal</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#any" title="any">6</a></td>
      <td><code>any</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/any&gt;</code></td>
    </tr>
    <tr>
      <td>N3921</td>
      <td><code>string_view</code>: a non-owning reference to a string</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#string.view" title="string.view">7</a></td>
      <td><code>string_view</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/string_view&gt;</code></td>
    </tr>
    <tr>
      <td>N3920</td>
      <td>Extending shared_ptr to Support Arrays</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#memory.smartptr" title="memory.smartptr">8.2</a></td>
      <td><code>shared_ptr_arrays</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/memory&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Polymorphic Memory Resources</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#memory.resource.synop" title="memory.resource.synop">8.4</a></td>
      <td><code>memory_resources</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/memory_resource&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Type-erased allocator for std::promise</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#futures.promise" title="futures.promise">9.2</a></td>
      <td><code>promise_erased_allocator</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/future&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Type-erased allocator for std::packaged_task</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#futures.task" title="futures.task">9.3</a></td>
      <td><code>packaged_task_erased_allocator</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/future&gt;</code></td>
    </tr>
    <tr>
      <td>N3925</td>
      <td>A <code>sample</code> Proposal</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#alg.random.sample" title="alg.random.sample">10.3</a></td>
      <td><code>sample</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/algorithm&gt;</code></td>
    </tr>
  </table>
  <h3>C++ Extensions for Parallelism</h3>
  <table border="1">
    <thead>
      <tr>
	<th>Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><code>__cpp_lib_experimental_parallel_algorithm</code></td>
	<td>201505</td>
	<td><code>&lt;experimental/algorithm&gt;
&lt;experimental/exception_list&gt;
&lt;experimental/execution_policy&gt;
&lt;experimental/numeric&gt;</code>
	</td>
      </tr>
    </tbody>
  </table>
  <h3>File System Technical Specification</h3>
  <table border="1">
    <thead>
      <tr>
	<th>Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><code>__cpp_lib_experimental_filesystem</code></td>
	<td>201406</td>
	<td><code>&lt;experimental/filesystem></code>
	</td>
      </tr>
    </tbody>
  </table>
  <h3>C++ Extensions for Transactional Memory</h3>
  <table border="1">
    <thead>
      <tr>
	<th>Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><code>__cpp_transactional_memory</code></td>
	<td>201505</td>
	<td><em>predeclared</em></td>
      </tr>
      <tr class="ins">
	<td><code>__has_cpp_attribute(optimize_for_synchronized)</code></td>
	<td>201411 <span class="editornote">?</span></td>
	<td><em>predeclared</em></td>
      </tr>
    </tbody>
  </table>
  <h2 id="detail">Detailed explanation and rationale</h2>
  <h3 id="detail.cpp14">C++14 features</h3>
  <p class="note">
    Many of the examples here have been shamelessly and almost brainlessly
		plagiarized from the cited paper. Assistance with improving examples is solicited.
  </p>
  <h4 id="detail.cpp14.n3323">N3323: A Proposal to Tweak Certain C++ Contextual Conversions</h4>
  <p>
    This paper specifies a small change that is considered to be more of a bug fix than
		a new feature, so no macro is considered necessary.
  </p>
  <h4 id="detail.cpp14.n3421">N3421: Making Operator Functors greater&lt;&gt;</h4>
  <p>Example:</p>
  <pre>#if __cpp_lib_transparent_operators
	sort(v.begin(), v.end(), greater&lt;&gt;());
#else
	sort(v.begin(), v.end(), greater&lt;valueType&gt;());
#endif</pre>
  <h4 id="detail.cpp14.n3462">N3462: std::result_of and SFINAE</h4>
  <p>
    The macro <code>__cpp_lib_result_of_sfinae</code>
    was originally erroneously recommended to be defined
	in the unrelated header <code>&lt;functional&gt;</code>.
	This error is being corrected,
	because it is believed that no implementation actually followed
	the erroneous recommendation.
  </p>
  <p>Example:</p>
  <pre>template&lt;typename A&gt;
#if __cpp_lib_result_of_sfinae
  typename std::result_of&lt;inc(A)&gt;::type
#else
  decltype(std::declval&lt;inc&gt;()(std::declval&lt;A&gt;()))
#endif
try_inc(A a);
</pre>
  <h4 id="detail.cpp14.n3471">N3469: Constexpr Library Additions: chrono<br />
    N3470: Constexpr Library Additions: containers<br />
    N3471: Constexpr Library Additions: utilities</h4>
  <p>
    These papers just add <code>constexpr</code> to the declarations of several dozen
		library functions in various headers. It is not clear that a macro to test for the
		presence of these changes would be sufficiently useful to be worthwhile.
  </p>
  <h4 id="detail.cpp14.n3472">N3472: Binary Literals in the C++ Core Language</h4>
  <p>Example:</p>
  <pre>int const packed_zero_to_three =
#if __cpp_binary_literals
	0b00011011;
#else
	0x1B;
#endif</pre>
  <h4 id="detail.cpp14.n3545">N3545: An Incremental Improvement to integral_constant</h4>
  <p>Example:</p>
  <pre>constexpr bool arithmetic =
#if __cpp_lib_integral_constant_callable
	std::is_arithmetic&lt;T&gt;{}();
#else
	static_cast&lt;bool&gt;(std::is_arithmetic&lt;T&gt;{});
#endif</pre>
  <h4 id="detail.cpp14.n3624">N3624: Core Issue 1512: Pointer comparison vs qualification
		conversions</h4>
  <p>
    This paper contained the wording changes to resolve a core issue. It did not introduce
		a new feature, so no macro is considered necessary.
  </p>
  <h4 id="detail.cpp14.n3638">N3638: Return type deduction for normal functions</h4>
  <p>
    This paper describes two separate features: the ability to deduce the return type
		of a function from the return statements contained in its body, and the ability
		to use <code>decltype(auto)</code>. These features can be implemented independently,
		so a macro is recommended for each.
  </p>
  <p>Examples:</p>
  <pre>template&lt;typename T&gt;
auto abs(T x)
#ifndef __cpp_return_type_deduction
	-> decltype(x &lt; 0 ? -x : x)
#endif
{
	return x &lt; 0 ? -x : x;
}</pre>
  <h4 id="detail.cpp14.n3639">N3639: Runtime-sized arrays with automatic storage duration</h4>
  <p>This was removed from C++14 to TS 19569.</p>
  <p>Example:</p>
  <pre>#if __cpp_runtime_arrays
	T local_buffer[n];	// more efficient than vector
#else
	std::vector&lt;T&gt; local_buffer(n);
#endif</pre>
  <h4 id="detail.cpp14.n3642">N3642: User-defined Literals for Standard Library Types</h4>
  <p>
    This paper specifies user-defined literal operators for two different standard library
		types, which could be implemented independently. Furthermore, user-defined literal
		operators are expected to be added later for at least one other library type. So
		for consistency and flexibility, each type is given its own macro.
  </p>
  <p>Examples:</p>
  <h4 id="detail.cpp14.n3644">N3644: Null Forward Iterators</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3648">N3648: Wording Changes for Generalized Lambda-capture</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3649">N3649: Generic (Polymorphic) Lambda Expressions</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3651">N3651: Variable Templates</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3652">N3652: Relaxing constraints on constexpr functions / constexpr
		member functions and implicit const</h4>
  <p>
    The major change proposed by this paper is considered to be strictly a further development
		of the <code>constexpr</code> feature of C++11. Consequently, the recommendation
		here is to give an increased value to the macro indicating C++11 support for <code>constexpr</code>.
  </p>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3653">N3653: Member initializers and aggregates</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3654">N3654: Quoted Strings Library Proposal</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3655">N3655: TransformationTraits Redux</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3656">N3656: make_unique</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3657">N3657: Adding heterogeneous comparison lookup to associative
		containers</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3658">N3658: Compile-time integer sequences</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3659">N3659: Shared locking in C++</h4>
  <p>
    The original recommendation, of a macro defined in header <code>&lt;mutex&gt;</code>,
		was not useful, and has been retracted.
  </p>
  <p>
    For new headers, we have a long-term solution that uses <code>__has_include</code>.
		There was not sufficient support and a number of objections against adding macros
		to existing library header files, as there was not consensus on a place to put them.
  </p>
  <p>
    There is also a simple workaround for users that are not using libraries that define
		the header file: supplying their own header that is further down the search path
		than the library headers.
  </p>
  <p>Example:</p>
  <pre>#if __has_include(&lt;shared_mutex&gt;)
#include &lt;shared_mutex&gt;

// <em>code that uses std::shared_mutex</em>
#endif</pre>
  <h4 id="detail.cpp14.n3662">N3662: C++ Dynamic Arrays</h4>
  <p>This was removed from C++14 to TS 19569.</p>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3664">N3664: Clarifying Memory Allocation</h4>
  <p>
    The substantive change in this paper just relaxes a restriction on implementations.
		There is no new feature for a programmer to use, so no macro is considered necessary.
  </p>
  <h4 id="detail.cpp14.n3667">N3667: Drafting for Core 1402</h4>
  <p>
    This paper contained the wording changes to resolve a core issue. It did not introduce
		a new feature, so no macro is considered necessary.
  </p>
  <h4 id="detail.cpp14.n3668">N3668: exchange() utility function</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3669">N3669: Fixing constexpr member functions without const</h4>
  <p>
    This paper contained the wording changes to ensure that a minor change proposed by
		N3652 did not impact the standard library. It did not introduce a new feature, so
		no macro is considered necessary.
  </p>
  <h4 id="detail.cpp14.n3670">N3670: Wording for Addressing Tuples by Type</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3671">N3671: Making non-modifying sequence operations more robust</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3672">N3672: A proposal to add a utility class to represent optional
		objects</h4>
  <p>This was removed from C++14 to TS 19568.</p>
  <p>See <a href="p0096r4.html#detail.cpp14.n3659">N3659</a> for rationale.</p>
  <p>Example:</p>
  <pre>#if __has_include(&lt;optional&gt;)
#include &lt;optional&gt;

// <em>code that uses std::optional</em>
#endif</pre>
  <h4 id="detail.cpp14.n3673">N3673: C++ Library Working Group Ready Issues Bristol 2013</h4>
  <p>
    This paper was just a collection of library issues. It did not introduce a new feature,
		so no macro is considered necessary.
  </p>

  <h4 id="detail.cpp14.n3760">N3760: [[deprecated]] attribute</h4>
  <p class="editornote">Do we really need this here?</p>
  <p>
    Differentiating attribute availability based on compiler-specific macros is error-
			prone. Since vendors are allowed to provide implementation-specific attributes in
			addition to standards-based attributes, this feature provides a uniform, future-proof
			way to test the availability of attributes.
  </p>
  <p>Example:</p>
  <pre>#ifdef __has_cpp_attribute
#  if __has_cpp_attribute(deprecated)
#    define ATTR_DEPRECATED(msg) [[deprecated(msg)]]
#  else
#    define ATTR_DEPRECATED(msg)
#  endif
#endif

ATTR_DEPRECATED("f() has been deprecated") void f();</pre>
  <h4 id="detail.cpp14.n3776">N3776: Wording for ~future</h4>
  <p>The change made by this paper is a bug fix, and no macro is considered necessary.</p>
  <h4 id="detail.cpp14.n3778">N3778: C++ Sized Deallocation</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3779">N3779: User-defined Literals for std::complex</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3781">N3781: Single-Quotation-Mark as a Digit Separator</h4>
  <p>
    Writing code that uses digit separators conditionally when they are available
	would require:
  </p>
  <ul>
    <li>either duplicating constants, presumably containing large numbers of digits,
	which would be error-prone and difficult to maintain,</li>
    <li>or using a scheme based on macros and token concatenation,
	    which would effectively take the place of digit separators
	    as supported by the language.</li>
  </ul>
  <p>
    Thus it is believed that a macro indicating support
	for digit separators in the language would not be sufficiently useful.
  </p>
  <h4 id="detail.cpp14.n3786">N3786: Prohibiting "out of thin air" results in C++14</h4>
  <p>The change made by this paper is a bug fix, and no macro is considered necessary.</p>
  <h4 id="detail.cpp14.n3789">N3789: Constexpr Library Additions: functional</h4>
  <p>See <a href="p0096r4.html#detail.cpp14.n3471">N3471</a> for rationale.</p>
  <h4 id="detail.cpp14.n3887">N3887: Consistent Metafunction Aliases</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3891">N3891: A proposal to rename shared_mutex to shared_timed_mutex</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.n3910">N3910: What can signal handlers do? (CWG 1441)</h4>
  <p>The change made by this paper is a bug fix, and no macro is considered necessary.</p>
  <h4 id="detail.cpp14.n3924">N3924: Discouraging rand() in C++14</h4>
  <p>The change made by this paper is not normative; no macro is necessary.</p>
  <h4 id="detail.cpp14.n3927">N3927: Definition of Lock-Free</h4>
  <p>The change made by this paper is a bug fix, and no macro is considered necessary.</p>
  <h4 id="detail.cpp14.lwg2112">LWG issue 2112: User-defined classes that cannot be derived
			from</h4>
  <p>
    Libraries that want to do empty-base optimization could reasonably want to use
	<code>!is_final &amp;&amp; is_empty</code> if <code>is_final</code> exists, and fall back
			to just using <code>is_empty</code> otherwise.
  </p>
  <p>Example:</p>
  <pre>template&lt;typename T&gt;
struct use_empty_base_opt :
	std::integral_constant&lt;bool, 
		std::is_empty&lt;T&gt;::value
#if __cpp_lib_has_is_final
		&amp;&amp; !std::is_final&lt;T&gt;::value
#endif
	&gt;
{ };
</pre>
  <h4 id="detail.cpp14.lwg2247">LWG issue 2247: Type traits and std::nullptr_t</h4>
  <p>Example:</p>
  <h4 id="detail.cpp14.lwg2249">LWG issue 2249: Remove gets from &lt;cstdio&gt;</h4>
  <p>
    Since portable, well-written code does not use the <code>gets</code> function at
			all, there is no need for a macro to indicate whether it is available.
  </p>
  <h4 id="detail.cpp14.lwg2285">LWG issue 2285: make_reverse_iterator</h4>
  <p>Example:</p>
  <h3 id="detail.cpp17">C++17 features</h3>
  <h4 id="detail.cpp17.n3911">N3911: TransformationTrait Alias void_t</h4>
  <!--Author: Brown -->
  <!--Contributor: Brown -->
  <p>Example:</p>
  <pre>#if __cpp_lib_void_t
  using std::void_t;
#else
  template&lt; class... &gt;  using void_t = void;
#endif</pre>
  <h4 id="detail.cpp17.n3922">N3922: New Rules for auto deduction from braced-init-list</h4>
  <!--Author: Dennett -->
  <!--Contributor: Dennett -->
  <p>
    This change is considered a fix to a problem in C++14,
    not a new feature, so no macro is recommended.
    Code that needs to work both with and without this change
    should not attempt to deduce a type
    from a direct
    <var>braced-init-list</var>
    initializer.
  </p>
  <h4 id="detail.cpp17.n3928">N3928: Extending static_assert</h4>
  <!--Author: Brown -->
  <!--Contributor: Nelson -->
  <p>Example:</p>
  <pre>#if __cpp_static_assert
#if __cpp_static_assert &gt; 201400
#define Static_Assert(cond) static_assert(cond)
#else
#define Static_Assert(cond) static_assert(cond, #cond)
#endif
#define Static_Assert_Msg(cond, msg) static_assert(cond, msg)
#else
#define Static_Assert(cond)
#define Static_Assert_Msg(cond, msg)
#endif</pre>
  <h4 id="detail.cpp17.n4051">N4051: Allow typename in a template template parameter</h4>
  <!--Author: Smith -->
  <!--Contributor: Nelson -->
  <p>
    This is a minor stylistic extension;
    there is no difference in functionality or verbosity
    between code that uses the <code>class</code> keyword
    and code that uses the <code>typename</code> keyword in this context.
    If portability is needed between implementations having and lacking this feature,
    generally it would be easier to continue to write code using <code>class</code>
    than to write and maintain conditional compilation to use <code>typename</code>
    when available.
    So a macro for this feature would not seem to be justified.
  </p>
  <h4 id="detail.cpp17.n4086">N4086: Removing trigraphs??!</h4>
  <!--Author: Smith -->
  <!--Contributor: Nelson -->
  <p>
    This is a very low-level change, purely lexical.
    Writing code to use trigraphs when they are available
    and different characters when trigraphs are not available
    would be tedious,
    and the resulting code would be even uglier than code that just uses trigraphs.
  </p>
  <p>
    Even in circumstances where use of a character
    not in the ISO/IEC 646 Basic Character Set is problematic,
    it would generally be easier
    to use alternative tokens (a.k.a. &ldquo;digraphs&rdquo;)
    than to conditionally use trigraphs.
  </p>
  <h4 id="detail.cpp17.n4089">N4089: Safe conversions in unique_ptr&lt;T[]&gt;</h4>
  <!--Author: Romer -->
  <!--Contributor: Romer -->
  <p>
    This is considered a fix for a library issue,
    to remove an unnecessary restriction;
    no macro is considered necessary.
  </p>
  <h4 id="detail.cpp17.n4169">N4169: A proposal to add invoke function template</h4>
  <!--Author: Kaminski -->
  <!--Contributor: Kaminski -->
  <p>Example:</p>
  <pre>template&lt;typename F&gt;
auto deref_fn(F&amp;&amp; f) 
{ 
  return [f](auto&amp;&amp;... args) {
#if __cpp_lib_invoke
    return *std::invoke(f, std::forward&lt;decltype(args)>(args)...);
#else
    return *f(std::forward&lt;decltype(args)&gt;(args)...);
#endif
  };
}</pre>
  <p>
    In this example, member function pointers are supported
    only if <code>invoke</code> is available.
  </p>
  <h4 id="detail.cpp17.n4190">N4190: Removing auto_ptr, random_shuffle(), And Old &lt;functional&gt; Stuff</h4>
  <!--Author: Lavavej approves-->
  <!--Contributor: Nelson -->
  <p>
    These library features are removed because
    superior alternatives to them were introduced in C++11.
    Because these alternatives are superior,
    there is little motivation to maintain code
    that uses one of these obsolescent features when available.
  </p>
  <h4 id="detail.cpp17.n4230">N4230: Nested namespace definition</h4>
  <!--Author: Kawulak/Tomazos -->
  <!--Contributor: Nelson -->
  <p>
    This feature doesn't provide any new functionality;
    it just makes it somewhat easier to write code.
    For code that needs to be portable
    to an implementation that doesn't provide this feature,
    it would be easier just to avoid using the feature
    than it would be maintain the code to use it when available
    but not otherwise.
    Therefore, a macro to indicate the availability of this feature
    would not seem to be justified.
  </p>
  <h4 id="detail.cpp17.n4258">N4258: Cleaning-up noexcept in the Library</h4>
  <!--Authopr: Josuttis -->
  <!--Contributor: Halpern -->
  <p>Example:</p>
  <pre>template &lt;class T, class Allocator = std::allocator&lt;T>>
class myContainer {
    typedef std::allocator_traits&lt;Allocator> alloc_traits;
public:
    ...
    myContainer&amp; operator=(myContainer&amp;&amp; x)
#ifdef __cpp_lib_allocator_traits_is_always_equal
      noexcept(alloc_traits::propagate_on_container_move_assignment::value ||
               alloc_traits::is_always_equal::value);
#else
      noexcept(alloc_traits::propagate_on_container_move_assignment::value);
#endif
    ...
};</pre>
  <p>
    Without the trait, the code will be correct,
	    but container move-assignment would have fewer exception guarantees,
	    especially with pre-C++11 stateless allocators.
	    An implementation of a mutating algorithm
	    might choose to use copy-assignment instead of move-assignment
	    if the <code>noexcept</code> clause evaluates to false,
	    because the implementation is unable to determine
	    whether the allocator always compares equal.
  </p>
  <h4 id="detail.cpp17.n4259">N4259: Wording for std::uncaught_exceptions</h4>
  <!--Author: Sutter -->
  <!--Contributor: Sutter/Nelson -->
  <p>Example:</p>
  <pre>bool throw_may_terminate()
{
#if __cpp_lib_uncaught_exceptions
    return std::uncaught_exceptions() > 0;
#else
    return std::uncaught_exception();
#endif
}</pre>
  <h4 id="detail.cpp17.n4261">N4261: Proposed resolution for Core Issue 330: Qualification conversions and pointers to arrays of pointers</h4>
  <!--Author: Maurer-->
  <!--Contributor: Maurer -->
  <p>This paper fixes a core language issue; no new feature is introduced.</p>
  <h4 id="detail.cpp17.n4262">N4262: Wording for Forwarding References</h4>
  <!--Author: Sutter -->
  <!--Contributor: Nelson -->
  <p>
    The changes detailed in this paper are solely editorial.
	    It does not introduce any new feature.
  </p>
  <h4 id="detail.cpp17.n4266">N4266: Attributes for namespaces and enumerators</h4>
  <!--Author: Smith -->
  <!--Contributor: Nelson -->
  <p>Example:</p>
  <pre>enum {
old_val
#if __cpp_enumerator_attributes
	[[deprecated]]
#endif
, new_val };</pre>
  <h4 id="detail.cpp17.n4267">N4267: Adding u8 character literals</h4>
  <!--Author: Smith -->
  <!--Contributor: Smith/Nelson -->
  <p>
    This feature gives guaranteed access
	    to the Unicode encoding for a 7-bit ASCII character
	    even in an implementation that uses a different character encoding.
	    In an application that needs this functionality,
	    it would probably be easier simply to hard-code
	    the numeric values of the needed encodings.
	    Thus a macro for this feature would seem to be of limited usefulness.
  </p>
  <h4 id="detail.cpp17.n4268">N4268: Allow constant evaluation for all non-type template arguments</h4>
  <!--Author: Smith -->
  <!--Contributor: Smith -->
  <p>Example:</p>
  <pre>int n = 0, m = 0;
int &amp;r = n;
template&lt;int &amp;&gt; struct X {};
#if __cpp_nontype_template_args
  X&lt;r&gt; x;
#else
  std::conditional&lt;&amp;r == &amp;n, X&lt;n&gt;, X&lt;m&gt;&gt;::type x;
#endif</pre>
  <h4 id="detail.cpp17.n4277">N4277: TriviallyCopyable reference_wrapper</h4>
  <!--Author: Berge -->
  <!--Contributor: Nelson -->
  <p>
    This paper imposes a new requirement on implementations,
	    which most implementations had already satisfied.
	    A reliable indication of when this requirement was not satisfied
	    would have been useful for programming;
	    an indication that it is satisfied would not be so useful.
  </p>
  <h4 id="detail.cpp17.n4279">N4279: Improved insertion interface for unique-key maps</h4>
  <!--Author: Koeppe -->
  <!--Contributor: Koeppe/Nelson -->
  <p>Example:</p>
  <pre>#if __cpp_lib_map_try_emplace
    m.insert_or_assign("foo", std::move(p));
#else
    m["foo"] = std::move(p);
#endif</pre>
  <p>
    In this example, if <code>insert_or_assign</code> is not available,
	    the type of <code>p</code> must be default-constructible.
  </p>
  <h4 id="detail.cpp17.n4280">N4280: Non-member size() and more</h4>
  <!--Author: Marcangelo -->
  <!--Contributor: Nelson -->
  <p>Example:</p>
  <pre>auto n =
#if __cpp_lib_nonmember_container_access
    std::size(c);
#else
    c.size();
#endif</pre>
  <p>
    In this example, an array type is supported for <code>c</code>
    only if the nonmember <code>size</code> function is available.
  </p>
  <h4 id="detail.cpp17.n4284">N4284: Contiguous Iterators</h4>
  <!--Author: Maurer -->
  <!--Contributer: Nelson -->
  <p>
    The changes detailed in this paper are solely editorial.
	    It does not introduce any new feature.
  </p>
  <h4 id="detail.cpp17.n4285">N4285: Cleanup for exception-specification and throw-expression</h4>
  <!--Author: Maurer -->
  <!--Contributor: Nelson -->
  <p>
    The changes detailed in this paper are solely editorial.
	    It does not introduce any new feature.
  </p>
  <h4 id="detail.cpp17.n4295">N4295: Folding expressions</h4>
  <!--Author: Sutton/Smith -->
  <!--Contributor: Sutton -->
  <p>Example:</p>
  <pre>#if __cpp_fold_expressions
template&lt;typename... T>
  auto sum(T... args)  { return (args + ...); }
#else
auto sum() { return 0; }
template&lt;typename T>
  auto sum(T t) { return t; }
template(typename T, typename... Ts)
  auto sum(T t, Ts... ts) { return t + sum(ts...); }
#endif
</pre>
  <h4 id="detail.cpp17.n4366">N4366: LWG 2228 missing SFINAE rule</h4>
  <!--Author: Hinnant -->
  <!--Contributor: Nelson -->
  <p>
    This change fixes a defect in the library.
	    No new feature is added, so no feature-test macro is needed.
  </p>
  <h4 id="detail.cpp17.n4387">N4387: Improving pair and tuple</h4>
  <!--Authors: Krugler, Romer, Voutilainen -->
  <p>
    <ins>This paper resolves some library issues.
    There is no new feature; no macro is required.
    <span class="editornote">Someone please confirm my guess here.</span></ins>
  </p>
  <h4 id="detail.cpp17.n4389">N4389: Wording for bool_constant</h4>
  <!--Author: Yuan -->
  <!--Contributor: Brown -->
  <p>Example:</p>
  <pre>#if __cpp_lib_bool_constant
  template &lt;bool B&gt;
  using my_bool_constant = std::bool_constant&lt;B&gt;;
#else
  template &lt;bool B&gt;
  using my_bool_constant = std::integral_constant&lt;bool, B&gt;;
#endif</pre>
  <h4 id="detail.cpp17.n4508">N4508: A proposal to add shared_mutex (untimed)</h4>
  <!--Author: Nishanov -->
  <p>Example:</p>
  <p class="editornote">Lenexa</p>
  <h4 id="detail.cpp17.n4510">N4510: Minimal incomplete type support for standard containers</h4>
  <!--Author: Yuan -->
  <p>Example:</p>
  <p class="editornote">Lenexa</p>
  <h4 id="detail.cpp17.p0001">P0001R1: Remove Deprecated Use of the register Keyword</h4>
  <!--Author: Meredith -->
  <!--Contributor: Nelson -->
  <p>
    The simplest way to write code to be portable between implementations
	    that have and lack this change is to avoid using the <code>register</code> keyword.
	    A feature-test macro would not be sufficiently useful.
  </p>
  <h4 id="detail.cpp17.p0002">P0002R1: Remove Deprecated operator++(bool)</h4>
  <!--Author: Meredith -->
  <!--Contributor: Nelson -->
  <p>
    The simplest way to write code to be portable between implementations
	    that have and lack this change is to avoid applying <code>++</code> to <code>bool</code> objects.
	    A feature-test macro would not be sufficiently useful.
  </p>
  <h4 id="detail.cpp17.p0004">P0004R1: Remove Deprecated iostreams aliases</h4>
  <!--Author: Meredith -->
  <!--Contributor: Nelson -->
  <p>
    The simplest way to write code to be portable between implementations
	    that have and lack this change is not to use the previously deprecated features.
	    A feature-test macro would not be sufficiently useful.
  </p>
  <h4 id="detail.cpp17.p0006">P0006R0: Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17</h4>
  <!--Author: Meredith -->
  <p>Example:</p>
  <p class="editornote">Kona</p>
  <h4 id="detail.cpp17.p0007">P0007R1: Constant View: A proposal for a std::as_const helper function template</h4>
  <!--Author: Meredith -->
  <p>Example:</p>
  <p class="editornote">Kona</p>
  <h4 id="detail.cpp17.p0012">P0012R1: Make exception specifications be part of the type system</h4>
  <!--Author: Maurer -->
  <p>Example:</p>
  <p class="editornote">Kona</p>
  <h4 id="detail.cpp17.p0013">P0013R1: Logical Operator Type Traits</h4>
  <!--Author: Wakely -->
  <!--Contributor: Wakely -->
  <p>Example:</p>
  <pre class="ins">template&lt;typename... T>
  using condition =
#if __cpp_lib_logical_traits
  conjunction&lt;is_pointer&lt;decay_t&lt;T>>...>;
#else
  bool_constant&lt;(is_pointer&lt;decay_t&lt;T>>::value &amp;&amp; ...)>;
#endif

template&lt;typename... T>
  enable_if_t&lt;condition&lt;T...>::value>
  foo(T&amp;&amp;...) { }

template&lt;typename... T>
  enable_if_t&lt;!condition&lt;T...>::value>
  foo(T&amp;&amp;...) { }</pre>
  <p>
    <ins>Using conjunction is more efficient at compile-time,
    because it short-circuits
    and doesn't evaluate every expression in the pack expansion
    if it doesn't need to.</ins>
  </p>
  <h4 id="detail.cpp17.p0061">P0061R1: __has_include for C++17</h4>
  <!--Author: Nelson, Smith -->
  <!--Contributor: Nelson -->
  <p>
    <ins>The presence of this feature can be determined
    by testing whether the <code>__has_include</code> macro
    is defined.
    However, because it is a function-like macro,
    it has no specific value that can be tested.</ins>
  </p>
  <h4 id="detail.cpp17.p0074">P0074R0: Making std::owner_less more flexible</h4>
  <!--Author: Wakely -->
  <!--Contributor: Wakely -->
  <p><ins>Example:</ins></p>
  <pre class="ins">#if __cpp_lib_transparent_operators >= 201510
using generic_owner_less = std::owner_less&lt;>;
#else
struct generic_owner_less {
  template&lt;typename T, typename U>
    bool
    operator()(const std::shared_ptr&lt;T>&amp; p1,
	       const std::shared_ptr&lt;U>&amp; p2) const
    { return p1.owner_before(p2); }
};
#endif
</pre>
  <h4 id="detail.cpp17.p0092">P0092R1: Polishing &lt;chrono&gt;</h4>
  <!--Author: Hinnant -->
  <p>Example:</p>
  <p class="editornote">Kona</p>
  <h4 id="detail.cpp17.p0134">P0134R0: Introducing a name for brace-or-equal-initializers for non-static data members</h4>
  <!--Author: Smith -->
  <!--Author: Nelson -->
  <p>This change is entirely editorial; no feature is added, and no test macro is needed.</p>
  <h4 id="detail.cpp17.p0136">P0136R1: Rewording inheriting constructors (core issue 1941 et al)</h4>
  <!--Author: Smith -->
  <!--Contributor: Nelson -->
  <p>
    This change is considered a minor tweak to the inheriting constructors feature,
	    and mostly just fixes issues with the original description.
	    However, it can change the behavior of some code.
	    Therefore the value of the <code>__cpp_inheriting_constructors</code>
    macro is adjusted.
  </p>
  <p>Example:</p>
  <p class="editornote">Kona</p>
  <h4 id="detail.cpp17.p0156r0">P0156R0: Variadic lock_guard</h4>
  <!--Author: Spertus -->
  <p>
    <ins>In a previous revision,
    it was recommended that a test macro for this feature
    be defined in <code>&lt;thread&gt;</code>.
    That was a mistake; the relevant code is actually in
    <code>&lt;mutex&gt;</code>.</ins>
  </p>
  <p><ins>This feature was subsequently removed from C++17.
    The functionality it had provided
    is now provided by a <code>scoped_lock</code>.
     </ins></p>
  <ins>
    <h4><a id="detail.cpp17.p0005">P0005R4:</a> Adopt not_fn
    from Library Fundamentals 2 for C++17</h4>
    <!--Author: Meredith, Lavavej -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0017">P0017R1:</a> Extension to
    aggregate initialization</h4>
    <!--Author: Smolsky -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0018">P0018R3:</a> Lambda Capture
    of *this by Value as [=,*this]</h4>
    <!--Author: Edwards, Vandevoorde -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0024">P0024R2: The Parallelism TS
    Should be Standardized</a></h4>
    <!--Author: Hoberock -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0025">P0025R0: An algorithm to "clamp"
    a value between a pair of boundary values</a></h4>
    <!--Author: Moene, Dekker -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0030">P0030R1:</a> Proposal to Introduce
    a 3-Argument Overload to std::hypot</h4>
    <!--Author: Ma -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0031">P0031R0:</a> A Proposal to Add
    Constexpr Modifiers to reverse_iterator, move_iterator, array
    and Range Access</h4>
    <!--Author: Polukhin -->
    <p class="editornote">Jacksonville</p>
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0033">P0033R1:</a> Re-enabling
    shared_from_this</h4>
    <!--Author: Wakely, Dimov -->
    <!--Contributor: Wakely -->
    <p>Example:</p>
    <pre>template&lt;class ObjectType>
void register_observers(ObjectType&amp; obj)
{
#if __cpp_lib_enable_shared_from_this
    auto wptr = obj.weak_from_this();
#else
    auto sptr = obj.shared_from_this();
    // Fails if sptr is not std::shared_ptr
    // (e.g. std::experimental::shared_ptr or boost::shared_ptr)
    auto wptr = weak_ptr&lt;decltype(sptr)::element_type>(sptr);
    sptr.reset(); // drop the strong reference as soon as possible
#endif
    register_observer_1(wptr);
    register_observer_2(wptr);
}</pre>
    <h4><a id="detail.cpp17.p0036">P0036R0:</a> Unary Folds
    and Empty Parameter Packs</h4>
    <!--Author: Le Jehan, Maurer -->
    <!--Contributor: Nelson -->
    <p>
      This is a change to the original definition of
      the &ldquo;unary fold&rdquo; feature.
      The presence or absence of this change should be distinguished
      by the value
      of the <code>__cpp_fold_expression</code> macro.
    </p>
    <h4><a id="detail.cpp17.p0077">P0077R2:</a> is_callable,
    the missing INVOKE related trait</h4>
    <!--Author: Berge -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0138">P0138R2:</a> Construction Rules
    for enum class Values</h4>
    <!--Author: Dos Reis -->
    <!--Contributor: Nelson -->
    <p>
      This doesn't provide any new functionality;
      it just makes some kinds of code simpler to write.
      Code that needs to be portable to implementations
      lacking this feature would be still more complicated
      if it tried to use the new feature when available.
      So a macro for this feature would not seem to be justified.
    </p>
    <h4><a id="detail.cpp17.p0152">P0152R1:</a> constexpr
    atomic&lt;T&gt;::is_always_lock_free</h4>
    <!--Author: Giroux, Bastien-->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0154">P0154R1:</a> constexpr
    std::hardware_{constructive,destructive}_interference_size</h4>
    <!--Author: Giroux, Bastien -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0170">P0170R1:</a> Wording for
    Constexpr Lambda</h4>
    <!--Author: Vali, Maurer -->
    <!--Contributor: Nelson -->
    <p>
      The changes proposed in this paper are considered to be
      an extension of the capabilities
      of the <code>constexpr</code> keyword.
      Therefore the presence or absence of this feature
      should be distinguished by the value
      of the <code>__cpp_constexpr</code> macro.
    </p>
    <h4><a id="detail.cpp17.p0184">P0184R0:</a> Generalizing
    the Range-Based For Loop</h4>
    <!--Author: Niebler -->
    <!--Contributor: Nelson -->
    <p>
      This is considered an extension
      of the range-based <code>for</code> statement.
      Therefore the presence or absence of this feature
      should be distinguished by the value
      of the <code>__cpp_range_based_for</code> macro.
    </p>
    <h4><a id="detail.cpp17.p0185">P0185R1:</a> Adding
    [nothrow-]swappable traits</h4>
    <!--Author: Krugler-->
    <!--Contributor: Krugler -->
    <p>Example:</p>
    <pre>template&lt;class T>
  void my_swap(T& x, T& y)
#if __cpp_lib_is_swappable
  noexcept(std::is_swappable_v&lt;T>); // Covers all Lvalue Swappable cases
#else
  noexcept(
    std::is_nothrow_move_constructible_v&lt;T> &&
    std::is_nothrow_move_assignable_v&lt;T>
  );
#endif</pre>
    <h4><a id="detail.cpp17.p0218">P0218R1: Adopt the File System TS
    for C++17</a></h4>
    <!--Author: Dawes -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0220">P0220R1:</a> Adopt
    Library Fundamentals V1 TS Components for C++17</h4>
    <!--Author: Dawes, Meredith-->
    <h4><a id="detail.cpp17.p0226">P0226R1: Mathematical Special
    Functions for C++17</a></h4>
    <!--Author: Naumann, Brown -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0245">P0245R1:</a> Hexadecimal floating
    literals for C++</h4>
    <!--Author: Koeppe -->
    <p>Example:</p>
    <p class="editornote">Jacksonville</p>
    <h4><a id="detail.cpp17.p0253">P0253R1:</a> Fixing a design mistake
    in the searchers interface in Library Fundamentals</h4>
    <!--Author: Clow -->
    <!--Contributor: Nelson -->
    <p>
      This is a fix that is applied to the searchers interface
    at the same time that it is incorporated into the standard.
    The unfixed state exists only in the TS,
    which has its own macro name and value.
    The new macro for the searchers interface in the standard,
    with its new value,
    will be enough to indicate that this fix is applied.
    </p>
    <h4><a id="detail.cpp17.p0272">P0272R1:</a> Give 'std::string'
    a non-const '.data()' member function</h4>
    <!--Author: Sankel -->
    <p>
      This doesn't provide any new functionality;
      it just makes some kinds of code simpler to write.
      Code that needs to be portable to implementations
      lacking this feature would be still more complicated
      if it tried to use the new feature when available.
      So a macro for this feature would not seem to be justified.
    </p>
    <h4><a id="detail.cpp17.lwg2296">LWG2296:</a> std::addressof should be constexpr</h4>
    <!--Author: Clow -->
    <!--Contributor: Smith -->
    <p>Example:</p>
    <pre>struct optional {
  bool b;
  T t;
  constexpr T *get() {
    return b ?
#if __cpp_lib_addressof_constexpr
      std::addressof(t)
#else
      &t
#endif
      : nullptr;
  }
};
</pre>
    <p>
      It is more important for <code>get</code> to be
      <code>constexpr</code> than for it to work
      if there is an overloaded <code>operator&amp;</code>,
      so <code>addressof</code> is used
      only if it would actually work in a constant expression.
    </p>
    <hr />
    <p class="editornote">Oulu:</p>
    <h4><a id="detail.cpp17.p0028">P0028R4: Using attribute namespaces without repetition</a></h4>
    <!--Author: Garcia, Vandevoorde -->
    <h4><a id="detail.cpp17.p0032">P0032R3: Homogeneous interface for variant, any and optional</a></h4>
    <!--Author: Botet Escriba -->
    <h4><a id="detail.cpp17.p0035">P0035R4: Dynamic memory allocation for over-aligned data</a></h4>
    <!--Author: Nelson -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0040">P0040R3: Extending memory management tools</a></h4>
    <!--Author: Friedman -->
    <h4><a id="detail.cpp17.p0063">P0063R3: C++17 should refer to C11 instead of C99</a></h4>
    <!--Author: Nelson -->
    <!--Contributor: Nelson -->
    <p>
      This paper is primarily editorial.
      There are a few additional C library functions
      that are formally required as a result of these changes,
      but in many cases they are not under the control
      of the C++ library implementer.
      It might be possible to tell the difference
      by the value of the <code>__STDC__</code> macro.
      It's not clear that any real purpose would be served
      by recommending a C++-specific macro
      to distinguish the difference.
    </p>
    <h4><a id="detail.cpp17.p0083">P0083R3: Splicing Maps and Sets</a></h4>
    <!--Author: Talbot -->
    <!--Contributor: Wakely -->
    <p>Example:</p>
    <pre>void update(std::set&lt;X>&amp; set, const X&amp; elem, int val)
{
  auto pos = set.find(elem);
  if (pos == set.end())
    return;
#if __cpp_lib_node_extract
  auto next = std::next(pos);
  auto x = set.extract(pos);
  x.value().update(val);
  set.insert(next, std::move(x));
#else
  X tmp = *pos;
  pos = set.erase(pos);
  tmp.update(val);
  set.insert(pos, std::move(tmp));
#endif
}</pre>
    <p>
      The version using <code>extract</code>
      doesn't need to copy or move any <code>X</code> objects
      and performs no memory allocation.
    </p>
    <h4><a id="detail.cpp17.p0084">P0084R2: Emplace Return Type</a></h4>
    <!--Author: Talbot -->
    <!--Contribute: Wakely -->
    <p>
      Code that needs to be portable between implementations
      with and without changes required by this paper
      should simply assume the previous rules.
    </p>
    <h4><a id="detail.cpp17.p0088">P0088R3: Variant: a type-safe union for C++17</a></h4>
    <!--Author: Naumann -->
    <h4><a id="detail.cpp17.p0091">P0091R3: Template argument deduction for class templates</a></h4>
    <!--Author: Spertus, Smith -->
    <h4><a id="detail.cpp17.p0127">P0127R2: Declaring non-type template parameters with auto</a></h4>
    <!--Author: Touton -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0135">P0135R1: Wording for guaranteed copy elision through simplified value categories</a></h4>
    <!--Author: Smith -->
    <!--Contributor: Smith -->
    <p>
      This feature doesn't provide any new functionality;
    it just makes it somewhat easier to write code.
    For code that needs to be portable
    to an implementation that doesn't provide this feature,
    it would be easier just to avoid using the feature
    than it would be maintain the code to use it when available
    but not otherwise.
    Therefore, a macro to indicate the availability of this feature
    would not seem to be justified.
    </p>
    <h4><a id="detail.cpp17.p0137">P0137R1: Core Issue 1776: Replacement of class objects containing reference members</a></h4>
    <!--Author: Smith -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0145">P0145R3: Refining Expression Evaluation Order for Idiomatic C++</a></h4>
    <!--Author: Dos Reis -->
    <!--Contributor: Smith -->
    <p>
      Code that needs to be portable between implementations
      with and without changes required by this paper
      should simply assume the previous rules.
    </p>
    <h4><a id="detail.cpp17.p0163">P0163R0: shared_ptr::weak_type</a></h4>
    <!--Author: O'Dwyer -->
    <!--Contributor: Wakely -->
    <p>Example:</p>
    <pre>template&lt;class ObjectType>
void register_observers(ObjectType&amp; obj)
{
    auto sptr = obj.shared_from_this();
#if  __cpp_lib_shared_ptr_weak_type
    decltype(sptr)::weak_type wptr(sptr);
#else
    // Fails if sptr is not std::shared_ptr
    // (e.g. std::experimental::shared_ptr or boost::shared_ptr)
    auto wptr = weak_ptr&lt;decltype(sptr)::element_type>(sptr);
#endif
    sptr.reset(); // drop the strong reference as soon as possible
    register_observer_1(wptr);
    register_observer_2(wptr);
}</pre>
    <h4><a id="detail.cpp17.p0174">P0174R2: Deprecating Vestigial Library Parts in C++17</a></h4>
    <!--Author: Meredith -->
    <p>
      This paper deprecates some library facilities
      for which superior alternatives exist.
      Code that needs to be portable should use the alternatives;
      a macro to enable code to adapt would not be useful.
    </p>
    <h4><a id="detail.cpp17.p0175">P0175R1: Synopses for the C library</a></h4>
    <!--Author: Koeppe, Smith -->
    <!--Contributor: Nelson -->
    <p>
      The changes proposed in this paper are entirely editorial;
      no macro is required.
    </p>
    <h4><a id="detail.cpp17.p0180">P0180R2: Reserve a New Library Namespace Future Standardization</a></h4>
    <!--Author: Meredith -->
    <!--Contributor: Nelson -->
    <p>
      This paper does not describe a new feature.
      It describes a retracted feature:
      the ability of a program to define a namespace
      with any of a certain set of names.
      Portable code should avoid defining such a namespace;
      no macro is necessary.
    </p>
    <h4><a id="detail.cpp17.p0181">P0181R1: Ordered By Default</a></h4>
    <!--Author: Meredith -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0209">P0209R2: make_from_tuple: apply for construction</a></h4>
    <!--Author: Halpern -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0217">P0217R3: Proposed wording for structured bindings</a></h4>
    <!--Author: Maurer -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0219">P0219R1: Relative Paths for Filesystem</a></h4>
    <!--Author: Dawes -->
    <h4><a id="detail.cpp17.p0254">P0254R2: Integrating std::string_view and std::string</a></h4>
    <!--Author: Clow -->
    <h4><a id="detail.cpp17.p0258">P0258R2: has_unique_object_representations - wording</a></h4>
    <!--Author: Spencer -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0283">P0283R2: Standard and non-standard attributes</a></h4>
    <!--Author: Garcia -->
    <h4><a id="detail.cpp17.p0292">P0292R2: constexpr if: A slightly different syntax</a></h4>
    <!--Author: Maurer -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0295">P0295R0: Adopt Selected Library Fundamentals V2 Components for C++17</a></h4>
    <!--Author: Brown -->
    <p>Example:</p>
    <h4><a id="detail.cpp17.p0296">P0296R2: Forward progress guarantees: Base definitions</a><br />
      <a id="detail.cpp17.p0299">P0299R1: Forward progress guarantees for the Parallelism TS features</a></h4>
    <!--Author: Riegel -->
    <!--Contributor: Smith -->
    <p>
      These papers
      effectively add only definitions.
      The added guarantees are intended only to formalize
      widespread existing practice.
    </p>
    <h4><a id="detail.cpp17.p0302">P0302R1: Removing Allocator Support in std::function</a></h4>
    <!--Author: Wakely -->
    <!--Contributor: Wakely -->
    <p>
      Since these constructors could not be used
      portably or reliably, there is no need for a feature test macro
      to indicate their absence.
    </p>
    <h4><a id="detail.cpp17.p0305">P0305R1: Selection statements with initializer</a></h4>
    <!--Author: Koeppe -->
    <!--Contributor: Smith -->
    <p>
      This feature doesn't provide any new functionality;
    it just makes it somewhat easier to write code.
    For code that needs to be portable
    to an implementation that doesn't provide this feature,
    it would be easier just to avoid using the feature
    than it would be maintain the code to use it when available
    but not otherwise.
    Therefore, a macro to indicate the availability of this feature
    would not seem to be justified.
    </p>
    <h4><a id="detail.cpp17.p0307">P0307R2: Making Optional Greater Equal Again</a></h4>
    <!--Author: Van Eerd -->
    <h4><a id="detail.cpp17.p0336">P0336R1: Better Names for Parallel Execution Policies in C++17</a></h4>
    <!--Author: Halpern -->
    <h4><a id="detail.cpp17.p0337">P0337R0: Delete operator= for polymorphic_allocator</a></h4>
    <!--Author: Halpern -->
    <!--Contributor: Nelson -->
    <p>
      This paper just fixes a defect.
      It doesn't add any new feature, so no macro is needed.
    </p>
    <h4><a id="detail.cpp17.p0346">P0346R1: A &lt;random&gt; Nomenclature Tweak</a></h4>
    <!--Author: Brown -->
    <!--Contributor: Nelson -->
    <p>
      The paper changes nothing but terminology,
      and is entirely editorial;
      no macro is needed.
    </p>
    <h4><a id="detail.cpp17.p0358">P0358R1: Fixes for not_fn</a></h4>
    <!--Author: Kaminski -->
    <p>
      The changes in this paper were adopted
      into the working draft of the standard at the same time as
      the <code>not_fn</code> feature they modify.
      The specification in the technical specification
      never appeared as such in any working draft of the standard,
      so a macro to distinguish
      the presence or absence of these changes
      is not considered necessary.
    </p>
    <h4><a id="detail.cpp17.p0371">P0371R1: Temporarily discourage memory_order_consume</a></h4>
    <!--Author: Boehm -->
    <!--Contributor: Nelson -->
    <p>This paper is entirely editorial; no macro is required.</p>
    <h4><a id="detail.cpp17.p0386">P0386R2: Inline Variables</a></h4>
    <!--Author: Finkel -->
    <!--Contributor: Krugler -->
    <p>Example:</p>
    <pre>#if __cpp_inline_variables &gt;= 201703
#define INLINE_VAR_DECL inline
#else
#define INLINE_VAR_DECL /*fingers crossed*/
#endif

INLINE_VAR_DECL constexpr piecewise_construct_t piecewise_construct{};</pre>
    <p class="editornote">Do we really want to (appear to) recommend
      that people write code like this?</p>
    <h4><a id="detail.cpp17.p0391">P0391R0: Introducing the term "templated entity"</a></h4>
    <!--Author: Maurer -->
    <!--Contributor: Nelson -->
    <p>
      This paper is entirely editorial, introducing a new term
      to make it easier to correctly draft the standard;
      no macro is necessary.
    </p>
    <h4><a id="detail.cpp17.p0392">P0392R0: Adapting string_view by filesystem paths</a></h4>
    <!--Author: Josuttis -->
    <h4><a id="detail.cpp17.p0393">P0393R3: Making Variant Greater Equal</a></h4>
    <!--Author: Van Eerd -->
    <!--Contributor: Smith -->
    <p>
      The changes in this paper were adopted
      into the working draft of the standard at the same time as
      the <code>variant</code> feature they modify.
      The specification in P0083R3 never appeared as such
      in any working draft, so a macro to distinguish
      the presence or absence of these changes
      is not considered necessary.
    </p>
    <h4><a id="detail.cpp17.p0394">P0394R4: Hotel Parallelifornia: terminate() for Parallel Algorithms Exception Handling</a></h4>
    <!--Author: Adelstein-Lelbach -->
    <h4><a id="detail.cpp17.p0398">P0398R0: Core issue 1518: Explicit default constructors and copy-list-initialization</a></h4>
    <!--Author: Maurer -->
    <!--Contributor: Nelson -->
    <p>
      This paper describes a bug fix, not a new feature;
      no new macro is needed.
    </p>
    <hr />
    <p class="editornote">Issaquah:</p>
    <h4><a id="detail.cpp17.p0003">P0003R5:</a> Removing Deprecated Exception Specifications from C++17</h4>
    <h4><a id="detail.cpp17.p0067">P0067R5:</a> Elementary string conversions</h4>
    <h4><a id="detail.cpp17.p0195">P0195R2:</a> Pack expansions in using-declarations</h4>
    <pre>#if __cpp_variadic_using &gt;= 201611
template&lt;typename ...T&gt; struct Callable : T... {
  using T::operator() ...;
};
#else
template&lt;typename ...T&gt; struct Callable;
template&lt;typename T, typename ...U&gt; struct Callable&lt;T, U...&gt; : T,
Callable&lt;U...&gt; {
  using T::operator();
  using Callable&lt;U...&gt;::operator();
};
template&lt;typename T&gt; struct Callable&lt;T&gt; : T {
  using T::operator();
};
template&lt;&gt; struct Callable&lt;&gt; {};
#endif</pre>
    <h4><a id="detail.cpp17.p0497">P0497R0:</a> Fixes to shared_ptr support for arrays</h4>
    <h4><a id="detail.cpp17.p0505">P0505R0:</a> Wording for GB 50</h4>
    <h4><a id="detail.cpp17.p0512">P0512R0:</a> Class Template Argument Deduction Assorted NB resolution and issues</h4>
    <h4><a id="detail.cpp17.p0522">P0522R0:</a> Matching of template template-arguments excludes compatible templates</h4>
    <hr />
    <p class="editornote">Kona:</p>
    <h4><a id="detail.cpp17.p0156r2">P0156R2:</a> Variadic lock_guard</h4>
    <h4><a id="detail.cpp17.p0298">P0298R3:</a> A byte type definition</h4>
    <h4><a id="detail.cpp17.p0317">P0317R1:</a> Directory Entry Caching for Filesystem</h4>
    <h4><a id="detail.cpp17.p0604">P0604R0:</a> Resolving GB 55, US 84, US 85, US 86</h4>
    <!--Contributor: Krugler/Wakely -->
    <p>Example:</p>
    <pre>#if _cpp_lib_is_invocable >= 201703
using std::is_invocable;
#elif __cpp_lib_void_t >= 201411
template&lt;typename R, typename = void&gt;
  struct is_invocable_impl : std::false_type
  { };
template&lt;typename R&gt;
  struct is_invocable_impl&lt;R, std::void_t&lt;typename R::type&gt;&gt; : std::true_type
  { };
template&lt;typename F, typename... Args&gt;
  struct is_invocable : is_invocable_impl&lt;std::result_of&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;&gt;::type
  { };
#else
#error either is_invocable or void_t is needed
#endif
</pre>
    <h4><a id="detail.cpp17.p0618">P0618R0:</a> Deprecating &lt;codecvt&gt;</h4>
    <h4><a id="detail.cpp17.lwg2911">LWG2911:</a> An is_aggregate type trait is needed</h4>
    <pre>#include &lt;vector&gt;
template&lt;typename T, typename... Args&gt;
T make(Args&&... args)
{
#if __cpp_lib_is_aggregate
    if constexpr (std::is_aggregate_v&lt;T&gt;)
        return { std::forward&lt;Args&gt;(args)... };
    else
#endif
        return T(std::forward&lt;Args&gt;(args)...);
}
struct Agg { int i; };
int main()
{
    auto v = make&lt;std::vector&lt;int&gt;&gt;(1, 2);
#if __cpp_lib_is_aggregate
    // make&lt;&gt; only supports aggregates if std::is_aggregate is available
    auto a = make&lt;Agg&gt;(1);
#endif
}</pre>
  </ins>
  <h2 id="model">Annex: Model wording for a Technical Specification</h2>
  <p>
    It is recommended that Technical Specifications include the wording below.
	<var>yyyymm</var>
    indicates the year and month of the date of the TS.
  </p>
  <blockquote>
    <p><strong>1.x Feature testing [intro.features]</strong></p>
    <p>
      An implementation that provides support for this Technical Specification
	    shall define the feature test macro(s) in Table
      <var>X</var>.
    </p>
    <table border="1">
      <caption>Table X &mdash; Feature Test Macro(s)</caption>
      <thead>
	<tr>
	  <th>Name</th>
	  <th>Value</th>
	  <th>Header</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td>__cpp_<var>name</var></td>
	  <td>
	    <var>yyyymm</var></td>
	  <td>&ldquo;<em>predefined</em>&rdquo; <strong>OR</strong> &ldquo;<code>&lt;<var>name</var>&gt;</code>&rdquo;</td>
	</tr>
      </tbody>
    </table>
  </blockquote>
  <h2 id="hist">Revision history</h2>
  <table border="1">
    <thead>
      <tr>
	<th>Date</th>
	<th>Document</th>
	<th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td>2017-07-26</td>
	<td>P0096R4</td>
	<td>Added C++17 features from Oulu, Issaquah and Kona</td>
      </tr>
      <tr>
	<td>2016-03-08</td>
	<td>SD-6<br />
	  P0096R3</td>
	<td>Updated from P0096R2</td>
      </tr>
      <tr>
	<td>2016-02-23</td>
	<td>P0096R2</td>
	<td>Fixed recommendation for P0074R0<br />
	  A few editorial fixes</td>
      </tr>
      <tr>
	<td>2016-01-19</td>
	<td>P0096R1</td>
	<td>Added C++17 features from Kona</td>
      </tr>
      <tr>
	<td>2015-09-16</td>
	<td>P0096R0</td>
	<td>Added C++17 features from Lenexa<br />
	  A few adjustments to C++17 recommendations<br />
	  Added model wording for a Technical Specification<br />
	  Added summaries of recommendations from TS'es</td>
      </tr>
      <tr>
	<td>2015-04-09</td>
	<td>N4440</td>
	<td>Added C++17 features from Urbana<br />
	  A couple of changes to C++14 recommendations<br />
	  A few new C++11 features</td>
      </tr>
      <tr>
	<td>2014-12-29</td>
	<td>SD-6</td>
	<td>Updated from N4200</td>
      </tr>
      <tr>
	<td>2014-10-08</td>
	<td>N4200</td>
	<td>Updated for final C++14<br />
	  Added more support for C++11 and C++98</td>
      </tr>
      <tr>
	<td>2014-05-22</td>
	<td>N4030</td>
	<td>Updated for changes from Chicago and Issaquah meetings<br />
	  Added <code>__has_cpp_attribute</code> test</td>
      </tr>
      <tr>
	<td>2013-11-27</td>
	<td>SD-6</td>
	<td>Initial publication<br />
	  No substantive changes from N3745</td>
      </tr>
      <tr>
	<td>2013-08-28</td>
	<td>N3745</td>
	<td>Endorsed by WG21 membership</td>
      </tr>
      <tr>
	<td>2013-06-27</td>
	<td>N3694</td>
	<td>Initial draft</td>
      </tr>
    </tbody>
  </table>
</body>
</html>
