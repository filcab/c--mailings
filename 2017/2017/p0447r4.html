<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Introduction of std::colony to the standard library</title>
  <style type="text/css">
      body {
         font-size: 12pt;
         font-weight: normal;
         font-style: normal;
         color: black;
         background-color: white;
         line-height: 1.2em;
         margin-left: 4em;
         margin-right: 2em;
      }
      /* paragraphs */

      p {
         padding: 0;
         line-height: 1.3em;
         margin-top: 2.5em;
         margin-bottom: 1em;
         text-align: left;
      }
      /* paragraphs */

      table {
         margin-top: 3.8em;
         margin-bottom: 2em;
         text-align: left;
      }
      /* headings */

      h1 {
         font-size: 195%;
         font-weight: bold;
         font-style: normal;
         font-variant: small-caps;
         line-height: 1.6em;
         text-align: left;
         padding: 0;
         margin-top: 3.5em;
         margin-bottom: 1.7em;
      }
      h2 {
         font-size: 122%;
         font-weight: bold;
         font-style: normal;
         text-decoration: underline;
         padding: 0;
         margin-top: 4.5em;
         margin-bottom: 1.1em;
      }
      h3 {
         font-size: 110%;
         font-weight: bold;
         font-style: normal;
         text-decoration: underline;
         padding: 0;
         margin-top: 4em;
         margin-bottom: 1.1em;
      }
      h4 {
         font-size: 100%;
         font-weight: bold;
         font-style: normal;
         padding: 0;
         margin-top: 4em;
         margin-bottom: 1.1em;
      }
      h5 {
         font-size: 90%;
         font-weight: bold;
         font-style: italic;
         padding: 0;
         margin-top: 3em;
         margin-bottom: 1em;
      }
      h6 {
         font-size: 80%;
         font-weight: bold;
         font-style: normal;
         padding: 0;
         margin-top: 1em;
         margin-bottom: 1em;
      }
      /* divisions */

      div {
         padding: 0;
         margin-top: 0em;
         margin-bottom: 0em;
      }
      ul {
         margin: 0pt 0pt 22pt 15.7pt;
         padding: 0pt 0pt 0pt 0pt;
         list-style-type: square;
         font-size: 98%;
      }
      ol {
         margin: 12pt 0pt 8pt 15.7pt;
         padding: 0pt 0pt 0pt 0pt;
         font-size: 98%;
      }
      li {
         margin: 0pt 0pt 10.5pt 0pt;
         padding: 0pt 0pt 0pt 0pt;
         text-indent: 0pt;
         font-size: 98%;
         display: list-item;
      }
      /* inline */

      strong {
         font-weight: bold;
      }
      sup,
      sub {
         vertical-align: baseline;
         position: relative;
         top: -0.4em;
         font-size: 70%;
      }
      sub {
         top: 0.4em;
      }
      em {
         font-style: italic;
      }
      code {
         font-family: Courier New, Courier, monospace;
         padding: 0 0 0 0em;
      }
      ins {
         background-color: yellow;
         text-decoration: underline;
      }
      del {
         text-decoration: line-through;
      }
      a:hover {
         color: #4398E1;
      }
      a:active {
         color: #4598E1;
         text-decoration: none;
      }
      a:link.review {
         color: #AAAAAF;
      }
      a:hover.review {
         color: #4398E1;
      }
      a:visited.review {
         color: #444444;
      }
      a:active.review {
         color: #AAAAAF;
         text-decoration: none;
      }
  </style>
</head>
<body>
Audience: LEWG, SG14<br>
Document number: P0447R4<br>
Date: 2017-10-16<br>
Project: Introduction of std::colony to the standard library <br>
Reply-to: Matthew Bentley &lt;mattreecebentley@gmail.com&gt; <br>

<h1>Introduction of std::colony to the standard library</h1>

<h2>Table of Contents</h2>
<ol type="I">
  <li><a href="p0447r4.html#introduction">Introduction</a></li>
  <li><a href="p0447r4.html#motivation">Motivation and Scope</a></li>
  <li><a href="p0447r4.html#impact">Impact On the Standard</a></li>
  <li><a href="p0447r4.html#design">Design Decisions</a></li>
  <li><a href="p0447r4.html#technical">Technical Specifications</a></li>
  <li><a href="p0447r4.html#acknowledgements">Acknowledgements</a></li>
  <li>Appendixes:
    <ol type="A">
      <li><a
      href="p0447r4.html#functions">Reference implementation member functions</a></li>
      <li><a href="p0447r4.html#benchmarks">Reference implementation benchmarks</a></li>
      <li><a href="p0447r4.html#faq">Frequently Asked Questions</a></li>
      <li><a href="p0447r4.html#responses">Specific responses to previous committee feedback</a></li>
      <li><a href="p0447r4.html#questions">Open questions from the author</a></li>
      <li><a href="p0447r4.html#revisions">Paper revision history</a></li>
    </ol>
  </li>
</ol>

<h2><a name="introduction"></a>I. Introduction</h2>

<p>In a human colony, people move into houses then when they move on those
houses are filled by other people (assuming limited resources). New houses
are not built unless necessary, as it's inefficient to do so. But as the colony grows, we'd start building larger and larger houses for efficiency's sake - if a small one became empty it could be demolished and the land cleared to make way for a larger one. Lastly, if we wanted to find people, but had many of empty houses in a row, we'd want to avoid checking each and every individual house. For that reason we might want to use a numbering system to allow us to skip over rows of empty houses.</p>

<p>That metaphor roughly describes the three core aspects of a colony container - erased-element location reuse upon reinsertion, block-based allocation with a growth factor, and jump-counting skipfields. Memory locations of erased elements are marked as empty and 'recycled', with new elements utilizing them upon future insertion, meanwhile being skipped over during iteration. This avoids reallocation upon erasure. New memory blocks are not allocated unless necessary - and when a memory block becomes empty, it is freed to the OS (under certain circumstances it may be retained for performance reasons - see <a href="p0447r4.html#clear">clear()</a> and <a href="p0447r4.html#erase">erase()</a>). This avoids needless iteration over erased blocks and is one part of enabling O(1) iteration time complexity. The other part is the use of what I've called a <a href="http://em.rdcu.be/wf/click?upn=KP7O1RED-2BlD0F9LDqGVeSPyQHezub7M4gGFa4NTPPTU-3D_ih77hK-2FwXUNPXOClzbShNQsKzXRuUomlRdQ1DjaMsrpnUBwwtbFTp5VEo6fdTXEOm5aVQpvVZ28aaMucmOmTG7j6bqKdutLSZ5s-2FvVOpi0U-2BRUm-2BokLgfiyljrkOnlzzohhddyytFQ6xbOHnaSP-2BiryryBzyk0-2FcqHJHqWla0UjauVoYm2aWi5no-2F91Tum6XKjVqwSLtk3SZQBA-2BuYbfglhC7NGb-2F0qoV47pMMnoV-2Fo-3D">jump-counting skipfield</a>, which allows contiguous erased elements to be skipped during iteration and also increases iteration performance compared to a boolean skipfield. Lastly, elements in a colony are allocated in multiple memory blocks, with a growth factor, enabling pointers to elements to stay valid after insertions and reducing the total number of allocations.</p>

<p>Colony is designed to be a higher-performance container for situations where the ratio of
insertions/erasures to iterations is relatively high. It
allows only for unordered insertion but is sortable, has fast iteration and
gives the programmer direct pointer/iterator access to elements without the
threat of those pointers/iterators being invalidated by subsequent
insertions or erasure. This makes it useful for object-oriented scenarios and many other frameworks such as entity component systems. A colony has some similarities to a ``bag'' container, but without id lookups or element counting. Instead of using id's as lookups for individual elements, the insert function returns an iterator which is valid for the lifetime of the element. The iterator can of course be dereferenced to obtain a pointer to the element, which is also valid for the element's lifetime. Since direct pointer access or iterator access does not have the overhead of id lookup, this is another positive point for colony, performance-wise. Based on the reference implementation (<a
href="http://www.plflib.org/colony.htm">plf::colony</a>) it has been established that colonies have better overall performance than standard library containers or container modifications when the following are valid:</p>
<ol type="a">
  <li>Insertion order is unimportant</li>
  <li>Insertions and erasures to the container occur frequently in
    performance-critical code, <i><b>and</b></i> </li>
  <li>Pointers/iterators to non-erased container elements may not be
    invalidated by insertion or erasure.</li>
</ol>

<p>The performance characteristics compared to other containers, for the
most-commonly-used operations in the above circumstance are:</p>
<ul>
  <li><i>Singular (non-fill, unordered) insertion</i>: better than any std::
    library container.</li>
  <li><i>Erasure (from random location)</i>: better than any std::
    library container.</li>
  <li><i>Iteration</i>: better than any std:: library container capable of
    preserving pointer/iterator validity post-erasure/insertion (eg. map, multiset,
    list). Some variance here for scalar types and different CPUs. Where pointer/iterator validity is unimportant, better than any
    std:: library container except deque and vector.</li>
</ul>

<p>There are some vector/deque modifications/workarounds which can outperform
colony for iteration while maintaining link validity, but which have slower
insertion and erasure speeds, and typically also have a cost to usability or
memory requirements. Under scenarios involving high levels of modification
colony will outperform these as well. These results, along with performance
comparisons to the unmodified std:: containers, are explored in detail in the
<a href="p0447r4.html#benchmarks">Appendix B Benchmarks</a>.</p>

<p>In terms of usage, there are two access patterns for stored elements; the first is to simply iterate over the colony and process each element (or skip some using the advance/prev/next functions). The second is to store the iterator returned by the insert() function (or a pointer derived from the iterator) in some other structure and access the inserted element that way. This is particularly useful in object-oriented code, as we shall see.</p>


<h2><a name="motivation"></a>II. Motivation and Scope</h2>

<p><i>Note: Throughout this document I will use the term 'link' to denote any form of referencing between elements whether it be via iterators/pointers/indexes/references/id's.</i></p>

<p>There are situations where data is heavily interlinked, iterated
over frequently, and changing often. An example is a typical video game engine. Most games will have a central 'entity' class, regardless of their overall schema. These are 'has a'-style objects rather than 'is a'-style
objects, which reference other shared resources like sprites, sounds and
suchforth. These resources are typically located in separate containers/arrays.
The entities are in turn referenced by other structures such as
quadtrees/octrees, level structures and so on.</p>
<p>The entities may be erased
at any time (for example, a wall gets destroyed and no longer requires
processing) and new entities may be inserted (for example, a new enemy is
created). All the while, inter-linkages between entities, resources and
superstructures such as levels and quadtrees, are required to stay valid in
order for the game to run. The order of the entities and resources themselves
within the containers is, in the context of a game, typically unimportant.</p>

<p>What is needed is a container (or modified use of a container) which allows for
insertions and erasures to occur without invalidating links between elements within containers. Unfortunately the container
with the best iteration performance in the standard library, vector<sup><a
href="p0447r4.html#benchmarks">[1]</a></sup>, also loses pointer validity to elements
within it upon insertion, and also pointer/index validity upon erasure. This
tends to lead to sophisticated, and often restrictive, workarounds when
developers attempt to utilize vector or similar containers under the above
circumstances.</p>

<p>As another example, non-game particle simulation (weather, physics etcetera) involve large clusters of particles which interact with external objects and each other, where the particles each have individual properties (spin, momentum, direction etc) and are being created and destroyed continuously. The order of the particles is unimportant, but what is important is the speed of erasure and insertion, since this is a high-modification scenario. No standard library container has both strong insertion and non-back erasure speed, and again this is a good match for colony.</p>


<p>Here are some more specific requirements with regards to game engines, verified by game developers within SG14:</p>
<ol type="a">
  <li>Elements within data collections refer to elements within other data
    collections (through a variety of methods - indices, pointers, etc). These
    references must stay valid throughout the course of the game/level. Any
    container which causes pointer or index invalidation creates
    difficulties or necessitates workarounds.</li>
  <li>Order is unimportant for the most part. The majority of data is simply
    iterated over, transformed, referred to and utilized with no regard to
    order.</li>
  <li>Erasing or otherwise "deactivating" objects occurs frequently in
    performance-critical code. For this reason methods of erasure which create
    strong performance penalties are avoided.</li>
  <li>Inserting new objects in performance-critical code (during gameplay) is
    also common - for example, a tree drops leaves, or a player
    spawns in an online multiplayer game.</li>
  <li>It is not always clear in advance how many elements there will be in a
    container at the beginning of development, or at the beginning of a
    level during play. Genericized game engines in particular have to adapt to
    considerably different user requirements and scopes. For this reason
    extensible containers which can expand and contract in realtime are
    necessary.</li>
  <li>Due to the effects of cache on performance, memory storage which is more-or-less
    contiguous is preferred.</li>
  <li>Memory waste is avoided.</li>
</ol>

<p>std::vector in it's default state does not meet these
requirements due to: </p>
<ol>
  <li>Poor (non-fill) singular insertion performance (regardless of insertion
    position) due to the need for reallocation upon reaching capacity</li>
  <li>Insert invalidates pointers/iterators to all elements </li>
  <li>Erase invalidates pointers/iterators/indexes to all elements afer the
    erased element</li>
</ol>

<p>Game developers therefore either develop custom solutions for
each scenario or implement workarounds for vector. The
most common workarounds are most likely the following or derivatives:</p>
<ol>
  <li>Using a boolean flag or similar to indicate the inactivity of an object
    (as opposed to actually erasing from the vector). Elements flagged as
    inactive are skipped during iteration. <br>
    <br>
    Advantages: Fast "deactivation". Easy to manage in multi-access environments.<br>
    Disadvantages: Slower to iterate due to branching.</li>
  <li>Using a vector of data and a secondary vector of indexes. When erasing,
    the erasure occurs only in the vector of indexes, not the vector of data.
    When iterating it iterates over the vector of indexes and accesses the data
    from the vector of data via the remaining indexes. <br>
    <br>
    Advantages: Fast iteration.<br>
    Disadvantages: Erasure still incurs some reallocation cost which can
    increase jitter.</li>
  <li>Combining a swap-and-pop approach to erasure with some form of
    dereferenced lookup system to enable contiguous element iteration
    (sometimes called a 'packed array': <a
    href="http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html">http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html</a>).
    <br>
    Advantages: Iteration is at standard vector speed.<br>
    Disadvantages: Erasure will be slow if objects are large and/or
    non-trivially copyable, thereby making swap costs large. All link-based
    access to elements incur additional costs due to the dereferencing system.
  </li>
</ol>

<p>Colony brings a more generic solution to these contexts.</p>


<h2><a name="impact"></a>III. Impact On the Standard</h2>

<p>This is a pure library addition, no changes necessary to the standard asides
from the introduction of the colony container. <br>
A reference implementation of colony is available for download and use: <a
href="http://www.plflib.org/colony.htm#download">http://www.plflib.org/colony.htm</a>
</p>

<h2><a name="design"></a>IV. Design Decisions</h2>

<p>As mentioned the key technical features of this container are:</p>
<ul>
  <li>Unordered non-associative data</li>
  <li>Never invalidates pointers/iterators to non-erased elements (iterators
    pointing to end() excluded)</li>
  <li>Reuses or frees memory from erased elements</li>
  <li>Where ratio of insertion/erasure to iteration is high, faster than any std:: library container or
    container workaround</li>
</ul>

<p>The abstract requirements needed to support these features are:</p>
<ol>
  <li>A multiple-memory-block based allocation pattern which allows for
    fast removal of memory blocks when they become empty of elements without
    causing element pointer invalidation within other memory blocks.</li>
  <li>A skipfield to enable the O(1) skipping over of consecutive erased elements during
    iteration. </li>
  <li>A mechanism for reusing erased element locations upon subsequent
    insertions. </li>
</ol>

<p>Obviously these three things can be achieved in a variety of different ways.
Here's how the reference implementation achieves them:</p>


<h4>Memory blocks - chained group allocation pattern</h4>

<p>This is essentially a doubly-linked list of nodes (groups) containing (a)
memory blocks, (b) memory block metadata and (c) skipfields. The memory blocks
themselves have a growth factor of 2. The metadata in question includes information necessary for an iterator to iterate
over colony elements, such as the last insertion point within the memory block,
and other information useful to specific functions, such as the total number of
non-erased elements in the node. This approach keeps the operation of freeing
empty memory blocks from the colony structure at O(1) time complexity. Further information is available here: <a
href="http://www.plflib.org/chained_group_allocation_pattern.htm">http://www.plflib.org/chained_group_allocation_pattern.htm</a>
</p>

<p>A vector of memory blocks would not work in this context as a colony iterator must store
a pointer (or index) to it's current group in order for iteration to work, and
groups <a href="p0447r4.html#remove_when_empty">must be removed when empty</a> in order to
enable O(1) iteration and avoid cache misses. Erasing a group in
a vector would invalidate pointers/indexes to all groups after the erased
group, and similarly inserting new groups would invalidate pointers to existing groups. A
vector of pointers to dynamically-allocated groups is possible, but likely represents little performance advantage when reallocation costs and structural overhead are taken into consideration. In addition the jitter caused when non-back groups are removed could become problematic.</p>


<h4>Skipfield - jump-counting skipfield pattern</h4>

<p>This numeric pattern allows for O(1) time complexity iterator operations and
fast iteration when compared to boolean skipfields. It stores and modifies
(during insertion and erasure) numbers which correspond to the number of
elements in runs of consecutive erased elements, and during iteration uses
these numbers to skip over the runs. This avoids the looping
branch code necessary for iteration with a boolean skipfield - which is slow, but which also cannot be used due to it's O(random) time complexity. It has two variants - a simple and an advanced solution, the latter of which colony uses. The published paper of the advanced version of the jump-counting skipfield pattern is available for viewing here: <a
href="http://em.rdcu.be/wf/click?upn=KP7O1RED-2BlD0F9LDqGVeSPyQHezub7M4gGFa4NTPPTU-3D_ih77hK-2FwXUNPXOClzbShNQsKzXRuUomlRdQ1DjaMsrpnUBwwtbFTp5VEo6fdTXEOm5aVQpvVZ28aaMucmOmTG7j6bqKdutLSZ5s-2FvVOpi0U-2BRUm-2BokLgfiyljrkOnlzzohhddyytFQ6xbOHnaSP-2BiryryBzyk0-2FcqHJHqWla0UjauVoYm2aWi5no-2F91Tum6XKjVqwSLtk3SZQBA-2BuYbfglhC7NGb-2F0qoV47pMMnoV-2Fo-3D">http://rdcu.be/ty6U</a>,
</p>

<h6>Iterative performance after having previously erased 75% of all elements in
the containers at random, for a std::vector, std::deque and a colony with
boolean skipfields, versus a colony with a jump-counting skipfield (GCC 5.1
x64, Intel Core2 processor) - storing a small struct type:</h6>
<img alt="test result graph"
src="http://www.plflib.org/tests/gcc/colony/comparitive/skipfield_approach_iterative_comparison_log.png">

<h4>Memory re-use mechanism - reduced_stack</h4>

<p>This is a stripped-down custom internal stack class based on plf::stack (<a
href="http://www.plflib.org/stack.htm">http://www.plflib.org/stack.htm</a>),
which outperforms any std:: container in a stack context for all
datatypes and across compilers. plf::stack uses the same chained-group allocation pattern as
plf::colony. In this context the stack pushes erased element memory locations and these are
popped upon subsequent insertions. If a memory block becomes empty and
is subsequently removed, the stack must be processed and any memory
locations from within the block removed.</p>

<h6>Time to push all elements then read-and-pop all elements, plf::stack vs
std::stack (std::deque) and std::vector (GCC 5.1 x64) - storing type
double:</h6>
<img alt="test result graph"
src="http://www.plflib.org/tests/gcc/stack/double_total_time_log.png">

<p>An alternative approach, using a "free list" (explanation of this concept:
<a
href="http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html">http://bitsquid.blogspot.ca/2011/09/managing-decoupling-part-4-id-lookup.html</a>)
to record the erased element memory locations, by creating a union between T
and T*, has been explored and the following issues identified:</p>
<ol>
  <li>Unions in C++ (11 or otherwise) currently do not support
    the preservation of fundamental functionality of the
    objects being unioned (<a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">n4567</a>,
    9.5/2). Copy/move assignment/constructors, constructors and destructors
    would be lost, which makes this approach untenable.</li>
  <li>A colony element could be smaller in size than a pointer and thus a union
    with such would dramatically increase the amount of wasted space in
    circumstances with low numbers of erasures - moreso if the pointer type
    supplied by the allocator is non-trivial.</li>
  <li>When a memory block becomes empty and must be removed as discussed earlier, the free list would need all nodes within that memory block removed. Because a free list will (assuming a non-linear erasure pattern) jump
    between random memory locations continuously, consolidating the free list would result
    in an operation filled with cache misses. In the context of
    jitter-sensitive work this would likely become unacceptable. It might be possible
    to work around this by using per-memory-block free lists.</li>
</ol>


<h2><a name="technical"></a>V. Technical Specifications</h2>

<p>Colony meets the requirements of the C++ <a
href="http://en.cppreference.com/w/cpp/concept/Container">Container</a>, <a
href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a>,
and <a
href="http://en.cppreference.com/w/cpp/concept/ReversibleContainer">ReversibleContainer</a>
concepts. </p>

<p>For the most part the syntax and semantics of colony functions are very
similar to current existing std:: C++ libraries. Formal description is as
follows:</p>
<code>template &lt;class T, class Allocator = std::allocator&lt;T&gt;, typename
Skipfield_Type = unsigned short&gt; class colony</code>

<p><code><b>T</b></code> - the element type. In general T must meet the
requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>, <a
href="http://en.cppreference.com/w/cpp/concept/CopyAssignable">CopyAssignable</a>
and <a
href="http://en.cppreference.com/w/cpp/concept/CopyConstructible">CopyConstructible</a>.
<br>
However, if emplace is utilized to insert elements into the colony, and no
functions which involve copying or moving are utilized, T is only required to
meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>. If
move-insert is utilized instead of emplace, T must also meet the requirements
of <a
href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a>
 .</p>
<p><code><b>Allocator</b></code> - an allocator that is used to acquire memory to
store the elements. The type must meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Allocator">Allocator</a>. The
behavior is undefined if <code>Allocator::value_type</code> is not the same as
T.</p>
<p><code><b>Skipfield_Type</b></code> - an unsigned integer type. This type is
used to form the skipfield which skips over erased T elements. The maximum size
of element memory blocks is constrained by this type's bit-depth (due to the
nature of a jump-counting skipfield). The default type, <code>unsigned
short</code>, is 16-bit on most platforms which constrains the size of
individual memory blocks to a maximum of 65535 elements. <code>unsigned
short</code> has been found to be the optimal type for performance based on
benchmarking, however making this type user-defined has performance benefits in
some scenarios. In the case of small collections (eg. &lt; 512 elements) in a
memory-constrained environment, reducing the skipfield bit depth to a Uint8
type will reduce both memory usage and cache saturation without impacting
iteration performance.</p>
<p>In the case of very large collections (millions) where memory usage is not a concern and where erasure is less common, one might think that changing the skipfield bitdepth to a larger type may lead to slightly increased iteration
performance due to the larger memory block sizes made possible by the largerbit depth and the fewer subsequent block transitions. However in practice the performance benefits appear to be little-to-none,
and introduce substantial performance issues if erasures are frequent, as with this
approach it takes more erasures for a group to become empty - increasing the frequency of large skips between
elements and subsequent cache misses, as well as skipfield update times. From this we can assume it is unlikely for a user to want to use types other than unsigned short and unsigned char. But since these scenarios are on a per-case basis, it has been considered best to leave control in the hands of the user.</p>

<h4>Basic example of usage</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;

  <span style="color: #888888">// Insert 100 ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    i_colony.insert(i);
  }

  <span style="color: #888888">// Erase half of them:</span>
  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Total the remaining ints:</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>it;
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Example demonstrating pointer stability</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;</span> p_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;::</span>iterator p_it;

  <span style="color: #888888">// Insert 100 ints to i_colony and pointers to those ints to p_colony:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    it <span style="color: #333333">=</span> i_colony.insert(i);
    p_colony.insert(<span style="color: #333333">&amp;</span>(<span style="color: #333333">*</span>it));
  }

  <span style="color: #888888">// Erase half of the ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Erase half of the int pointers:</span>
  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    p_it <span style="color: #333333">=</span> p_colony.erase(p_it);
  }

  <span style="color: #888888">// Total the remaining ints via the pointer colony:</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>(<span style="color: #333333">*</span>p_it);
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;

  <span style="color: #008800; font-weight: bold">if</span> (total <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2500</span>)
  {
    std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Pointers still valid!"</span> <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  }

  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Time complexity of main operations</h4>

<p>Insert/emplace (single): O(1) amortised unless prior erasures have occurred in the
usage lifetime of the colony instance. If prior erasures have occurred,
updating the skipfield may require a memmove operation, which creates a
variable time complexity depending on the range of skipfield needing to be
copied (though in practice this will resolve to a singular raw memory block
copy in most scenarios, and the performance impact is negligible). This is O(random) with the range of the random number
being between 1 and std::numeric_limits&lt;Skipfield_Type&gt;::max() - 2 (65534 in most instances).
Average time complexity varies based on erasure pattern. With a random
erasure pattern it will be closer to O(1) amortized.</p>

<p>Insert (multiple): O(N) unless prior erasures have occurred. See
Insertion(single) for rules in this case.</p>

<p>Erase (single): If erasures to elements consecutive with the element being
erased have not occurred, or only consecutive erasures before the element being
erased have occurred, O(1) amortised. If consecutive erasures after the element
being erased have occurred, updating of the skipfield requires a memmove
operation or vectorized update of O(N) complexity, where n is the number of
consecutive erased elements after the element being erased. This is O(random)
with the range of the random number being between from 1 and
std::numeric_limits&lt;Skipfield_Type&gt;::max() - 2. Average time complexity
varies based on erasure pattern, but with a random erasure pattern it's closer
to O(1) amortized.</p>

<p>Erase (multiple): ~O(log N)</p>

<p>std::find: O(N)</p>

<p>Iterator operations: <br>
++ and -- : O(1) amortized <br>
begin()/end(): O(1) <br>
advance/next/prev, get_iterator_from_index: between O(1) and O(N), depending on current location, end
location and state of colony. Average ~O(log N).</p>

<h4>Time complexity of other operations</h4>

<p>size(), capacity, max_size(), empty(): O(1)</p>
<p>operator =, operator == and != : O(N)</p>
<p>shrink_to_fit(): O(1)</p>
<p>change_group_sizes, change_minimum_group_size, change_maximum_group_size: O(N)</p>
<p>splice: O(1) amortised</p>
<p>sort: uses std::sort internally so roughly equivalent to the time complexity of the compiler's std::sort implementation</p>
<p>Swap, operator = (move), get_allocator(): O(1)</p>

<h4>Operations whose complexity does not have a strong correlation with number of elements:</h4>
<p>(<i>ie. other factors such as trivial destructability of elements more important</i>)</p>
<p>~colony, clear(), reinitialize(), sort(), get_iterator_from_pointer(), get_index_from_iterator(), get_index_from_reverse_iterator().</p>



<h4>Iterator Invalidation</h4>

<table border="1">
  <tbody>
    <tr>
      <td>All read-only operations, swap, std::swap, shrink_to_fit</td>
      <td>Never</td>
    </tr>
    <tr>
      <td>clear, sort, reinitialize, operator = </td>
      <td>Always</td>
    </tr>
    <tr>
      <td>reserve</td>
      <td>Only if capacity is changed</td>
    </tr>
    <tr>
      <td>change_group_sizes, change_minimum_group_size,
        change_maximum_group_size </td>
      <td>Only if supplied minimum group size is larger than smallest group in
        colony, or supplied maximum group size is smaller than largest group in
        colony. </td>
    </tr>
    <tr>
      <td>erase</td>
      <td>Only for the erased element</td>
    </tr>
    <tr>
      <td>insert, emplace</td>
      <td>If an iterator is == end() it may be invalidated by a subsequent
        insert/emplace. Otherwise it will not be invalidated. Pointers will never be invalidated.</td>
    </tr>
  </tbody>
</table>

<h4>Member types</h4>

<table border="1">
  <tbody>
    <tr>
      <td><b>Member type</b> </td>
      <td><b>Definition</b> </td>
    </tr>
    <tr>
      <td><code>value_type</code> </td>
      <td><code>T</code> </td>
    </tr>
    <tr>
      <td><code>allocator_type</code> </td>
      <td><code>Allocator</code> </td>
    </tr>
    <tr>
      <td><code>skipfield_type</code> </td>
      <td><code>Skipfield_Type</code> </td>
    </tr>
    <tr>
      <td><code>size_type</code> </td>
      <td><code>std::allocator_traits&lt;Allocator&gt;::size_type</code> </td>
    </tr>
    <tr>
      <td><code>difference_type</code> </td>
      <td><code>std::allocator_traits&lt;Allocator&gt;::difference_type</code>
      </td>
    </tr>
    <tr>
      <td><code>reference</code> </td>
      <td><code>value_type &amp;</code> </td>
    </tr>
    <tr>
      <td><code>const_reference</code> </td>
      <td><code>const value_type &amp;</code> </td>
    </tr>
    <tr>
      <td><code>pointer</code> </td>
      <td><code>std::allocator_traits&lt;Allocator&gt;::pointer</code> </td>
    </tr>
    <tr>
      <td><code>const_pointer</code> </td>
      <td><code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
      </td>
    </tr>
    <tr>
      <td><code>iterator</code> </td>
      <td><code>BidirectionalIterator</code> </td>
    </tr>
    <tr>
      <td><code>const_iterator</code> </td>
      <td><code>Constant BidirectionalIterator</code> </td>
    </tr>
    <tr>
      <td><code>reverse_iterator</code> </td>
      <td><code>BidirectionalIterator</code> </td>
    </tr>
    <tr>
      <td><code>const_reverse_iterator</code> </td>
      <td><code>Constant BidirectionalIterator</code> </td>
    </tr>
  </tbody>
</table>

<p>Colony iterators cannot be random access due to the use of a skipfield. This
constrains +, -, += or -= operators into being non-O(1). But member overloads
for the standard library functions advance(), next(), prev() and distance() are
available in the reference implementation, and are significantly faster than
O(N) in the majority of scenarios.</p>
A full list of the current reference implementation's constructors and member
functions can be found in <a href="p0447r4.html#functions">Appendix A</a>.

<h2><a name="acknowledgements"></a>VI. Acknowledgements</h2>

<p>Thank you's to Glen Fernandes and Ion Gaztanaga for restructuring
advice, Robert Ramey for documentation advice, various Boost and SG14 members
for support, Baptiste Wicht for teaching me how to construct decent benchmarks,
Jonathan Wakely for standards-compliance advice and critiques, Sean Middleditch, Patrice Roy
and Guy Davidson for critiques, support and bug reports, Jason Turner and Phil Williams for cross-processor testing, that guy from Lionhead for
annoying me enough to get me to get around to implementing the skipfield
pattern, Jon Blow for some initial advice and Mike Acton for some influence.</p>


<h2>VII. Appendixes</h2>

<h3><a id="functions"></a>Appendix A - Member functions</h3>

<h4>Constructors</h4>

<table border="1">
  <tbody>
    <tr>
      <td><code>Default</code></td>
      <td><code>colony()</code><br>
        <code>explicit colony(const allocator_type &amp;alloc)</code></td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>explicit colony(size_type n, skipfield_type min_group_size = 8,
        skipfield_type max_group_size =
        std::numeric_limits&lt;skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type())<br>
        explicit colony(size_type n, const value_type &amp;element,
        skipfield_type min_group_size = 8, skipfield_type max_group_size =
        std::numeric_limits&lt;skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type()) </code> </td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template&lt;typename InputIterator&gt; colony(const
        InputIterator &amp;first, const InputIterator &amp;last, skipfield_type
        min_group_size = 8, skipfield_type max_group_size =
        std::numeric_limits&lt;skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type())<br>
        </code> </td>
    </tr>
    <tr>
      <td>copy</td>
      <td><code>colony(const colony &amp;source)<br>
        colony(const colony &amp;source, const allocator_type
      &amp;alloc)</code></td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>colony(colony &amp;&amp;source) noexcept<br>
        colony(colony &amp;&amp;source, const allocator_type
      &amp;alloc)</code></td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>colony(const std::initializer_list&lt;value_type&gt;
        &amp;element_list, skipfield_type min_group_size = 8, skipfield_type
        max_group_size = std::numeric_limits&lt;skipfield_type&gt;::max(),
        const allocator_type &amp;alloc = allocator_type()) </code> </td>
    </tr>
  </tbody>
</table>

<h5>Some constructor usage examples</h5>
<ul>
  <li><code>colony&lt;T&gt; a_colony</code> 
    <p>Default constructor - default minimum group size is 8, default maximum
    group size is std::numeric_limits&lt;skipfield_type&gt;::max() (typically
    65535). You cannot set the group sizes from the constructor in this
    scenario, but you can call the change_group_sizes() member function after
    construction has occurred. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony;</code> </p>
  </li>
  <li><code>colony&lt;T, the_allocator&lt;T&gt; &gt; a_colony(const
    allocator_type &amp;alloc = allocator_type())</code>
    <p>Default constructor, but using a custom memory allocator eg. something
    other than std::allocator. <br>
    Example: <code style="color: brown">plf::colony&lt;int,
    tbb::allocator&lt;int&gt; &gt; int_colony;</code> <br>
    Example2: <br>
    <code style="color: brown">// Using an instance of an allocator as well as
    it's type<br>
    tbb::allocator&lt;int&gt; alloc_instance;<br>
    plf::colony&lt;int, tbb::allocator&lt;int&gt; &gt;
    int_colony(alloc_instance);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; colony(size_type n, skipfield_type min_group_size =
    8, skipfield_type max_group_size =
    std::numeric_limits&lt;skipfield_type&gt;::max())</code> 
    <p>Fill constructor with value_type unspecified, so the value_type's
    default constructor is used. <code>n</code> specifies the number of
    elements to create upon construction. If <code>n</code> is larger than
    <code>min_group_size</code>, the size of the groups created will either be
    <code>n</code> and <code>max_group_size</code>, depending on which is
    smaller. <code>min_group_size</code> (ie. the smallest possible number of
    elements which can be stored in a colony group) can be defined, as can the
    <code>max_group_size</code>. Setting the group sizes can be a performance
    advantage if you know in advance roughly how many objects are likely to be
    stored in your colony long-term - or at least the rough scale of storage.
    If that case, using this can stop many small initial groups being
    allocated. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony(62);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; colony(const
    std::initializer_list&lt;value_type&gt; &amp;element_list,<br>
    skipfield_type min_group_size = 8, skipfield_type max_group_size =
    std::numeric_limits&lt;skipfield_type&gt;::max())</code>
    <p>Using an initialiser list to insert into the colony upon construction.
    <br>
    Example: <code style="color: brown">std::initializer_list&lt;int&gt;
    &amp;el = {3, 5, 2, 1000};<br>
    plf::colony&lt;int&gt; int_colony(el, 64, 512);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(const colony &amp;source)</code>
    <p>Copy all contents from source colony, removes any empty (erased) element
    locations in the process. Size of groups created is either the total size
    of the source colony, or the maximum group size of the source colony,
    whichever is the smaller. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony_2(int_colony_1);</code> </p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(colony &amp;&amp;source)</code> 
    <p>Move all contents from source colony, does not remove any erased element
    locations or alter any of the source group sizes. Source colony is now void
    of contents and can be safely destructed. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt; int_colony_1(50,
    5, 512, 512); // Create colony with min and max group sizes set at 512
    elements. Fill with 50 instances of int = 5.<br>
    plf::colony&lt;int&gt; int_colony_2(std::move(int_colony_1)); // Move all
    data to int_colony_2. All of the above characteristics are now applied to
    int_colony2.</code> </p>
  </li>
</ul>

<h4>Iterators</h4>

<p>All iterators are bidirectional but also provide &gt;, &lt;, &gt;= and &lt;=
for convenience (for example, for comparisons against an end iterator when doing multiple
increments within for loops) and within some functions (<code>distance()</code>
uses these for example). Functions for iterator, reverse_iterator,
const_iterator and const_reverse_iterator follow:</p>

<p><code>operator * const<br>
operator -&gt; const noexcept<br>
operator ++<br>
operator --<br>
operator = noexcept<br>
operator == const noexcept<br>
operator != const noexcept<br>
operator &lt; const noexcept<br>
operator &gt; const noexcept<br>
operator &lt;= const noexcept<br>
operator &gt;= const noexcept<br>
base() const (reverse_iterator and const_reverse_iterator only)</code> </p>

<p>All operators have O(1) amortised time-complexity. Originally there were +=,
-=, + and - operators, however the time complexity of these varied from O(N) to
O(1) depending on the underlying state of the colony, averaging in at O(log N).
As such they were not includable in the iterator functions (as per C++
standards). These have been transplanted to colony's advance(), next(), prev()
and distance() member functions. Greater-than/lesser-than operator usage
indicates whether an iterator is higher/lower in position compared to another
iterator in the same colony (ie. closer to the end/beginning of the colony).</p>

<h4>Member functions</h4>

<h5>Insert</h5>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator insert (const value_type &amp;val)</code> </td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>iterator insert (size_type n, const value_type &amp;val)</code>
      </td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template &lt;class InputIterator&gt; iterator insert (const
        InputIterator &amp;first, const InputIterator &amp;last)</code> </td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>iterator insert (value_type&amp;&amp; val)</code> </td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>iterator insert (const std::initializer_list&lt;value_type&gt;
        &amp;il)</code> </td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator insert(const value_type &amp;element)</code> 
    <p>Inserts the element supplied to the colony, using the object's
    copy-constructor. Will insert the element into a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(23);</code> </li>
  <li><code>iterator insert(value_type &amp;&amp;element)</code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">std::string string1 = "Some text";<br>
    <br>
    plf::colony&lt;std::string&gt; data_colony;<br>
    data_colony.insert(std::move(string1));</code> </p>
  </li>
  <li><code>void insert (const size_type n, const value_type
    &amp;val)</code>
    <p>Inserts <code>n</code> copies of <code>val</code> into the colony. Will
    insert the element into a previously erased element slot if one exists,
    otherwise will insert to back of colony. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(10, 3);</code> </li>
  <li><code>template &lt;class InputIterator&gt; void insert (const InputIterator &amp;first, const InputIterator &amp;last)</code>
    <p>Inserts a series of <code>value_type</code> elements from an external
    source into a colony holding the same <code>value_type</code> (eg. int,
    float, a particular class, etcetera). Stops inserting once it reaches
    <code>last</code>. Example:</p>
    <code style="color: brown">// Insert all contents of colony2 into
    colony1:<br>
    colony1.insert(colony2.begin(), colony2.end());</code> </li>
  <li><code>void insert (const std::initializer_list&lt;value_type&gt;
    &amp;il)</code> 
    <p>Copies elements from an initializer list into the colony. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Example:</p>
    <p><code style="color: brown">std::initializer_list&lt;int&gt; some_ints =
    {4, 3, 2, 5};<br>
    <br>
    plf::colony&lt;int&gt; i_colony;<br>
    i_colony.insert(some_ints);</code> </p>
  </li>
</ul>

<h5><a id="erase"></a>Erase</h5>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator erase(const_iterator it)</code> </td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>void erase(const_iterator first, const_iterator last)</code>
      </td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator erase(const_iterator it)</code>
    <p>Removes the element pointed to by the supplied iterator, from the
    colony. Returns an iterator pointing to the next non-erased element in the
    colony (or to end() if no more elements are available). This must return an
    iterator because if a colony group becomes entirely empty, it may be
    removed from the colony, invalidating the existing iterator. A group may either be removed when it becomes empty, or moved to the back of the colony for future insertions and made inactive. The decision to either remove or move should be (largely) implementation-defined, but testing has suggested that the best performance under high-modification occurs when groups are removed unless they meet the maximum group size, or are either of the last two active groups at the back of the colony. Certainly there is no performance advantage to removing the end group, and doing so may introduce edge case performance issues (where multiple insertions/erasures occur frequently and sequentially). The reference implementation currently removes all groups when empty.
	Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    plf::colony&lt;unsigned int&gt;::iterator an_iterator;<br>
    an_iterator = data_colony.insert(23);<br>
    an_iterator = data_colony.erase(an_iterator);</code> </li>
  <li><code>void erase(const_iterator first, const_iterator last)</code> 
    <p>Erases all contents of a given colony from <code>first</code> to the
    element before the <code>last</code> iterator. The same principles from singular erasure apply to this function regards group retention/removal, etc.Example:</p>
    <code style="color: brown">plf::colony&lt;int&gt; iterator1 =
    colony1.begin();<br>
    colony1.advance(iterator1, 10);<br>
    plf::colony&lt;int&gt; iterator2 = colony1.begin();<br>
    colony1.advance(iterator2, 20);<br>
    colony1.erase(iterator1, iterator2);</code> </li>
</ul>

<h5>Other functions</h5>
<ul>
  <li><code>iterator emplace(Arguments &amp;&amp;... parameters)</code>
    <p>Constructs new element directly within colony. Will insert the element
    in a previously erased element slot if one exists, otherwise will insert to
    back of colony. Returns iterator to location of inserted element.
    "...parameters" are whatever parameters are required by the object's
    constructor. Example:</p>
    <p><code style="color: brown">class simple_class<br>
    {<br>
    private:<br>
    int number;<br>
    public:<br>
    simple_class(int a_number): number (a_number) {};<br>
    };<br>
    <br>
    plf::colony&lt;simple_class&gt; simple_classes;<br>
    simple_classes.emplace(45); </code> </p>
  </li>
  <li><code>bool empty() const noexcept</code>
    <p>Returns a boolean indicating whether the colony is currently empty of
    elements. <br>
    Example: <code style="color: brown">if (object_colony.empty())
    return;</code> </p>
  </li>
  <li><code>size_type size() const noexcept</code> 
    <p>Returns total number of elements currently stored in container. <br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.size()
    &lt;&lt; std::endl;</code> </p>
  </li>
  <li><code>size_type max_size() const noexcept</code>
    <p>Returns the maximum number of elements that the allocator can store in
    the container. This is an approximation as it does attempt to measure the
    memory overhead of the container's internal memory structures. It is not
    possible to measure the latter because a copy operation may change the
    number of groups utilized for the same amount of elements, if the maximum
    or minimum group sizes are different in the source container. <br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.max_size()
    &lt;&lt; std::endl;</code> </p>
  </li>
  <li><code>size_type capacity() const noexcept</code>
    <p>Returns total number of elements currently able to be stored in
    container without expansion. <br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.capacity()
    &lt;&lt; std::endl;</code> </p>
  </li>
  <li><code>void shrink_to_fit()</code> 
    <p>Deallocates any unused groups retained during erase() or unused since the last reserve(). This function cannot invalidate iterators or pointers to elements, nor will it necessarily shrink the capacity to match size().<br>
    Example: <code style="color: brown">i_colony.shrink_to_fit();</code> </p>
  </li>
  <li><code>void reserve(size_type reserve_amount)</code>
    <p>Preallocates memory space sufficient to store the number of elements
    indicated by <code>reserve_amount</code>. In the implementation the maximum size for this number
    currently is limited to the maximum group size of the colony and will be truncated if
    necessary. This restriction will be lifted in a future version. This function is useful from a performance perspective when the user is inserting elements singly, but the overall number of insertions is known in advance. By reserving, colony can forgo creating many smaller memory block allocations (due to colony's growth factor) and reserve a single memory block instead.<br>
    Example: <code style="color: brown">i_colony.reserve(15);</code> </p>
  </li>
  <li><a id="clear"></a><code>void clear()</code>
    <p>Empties the colony and removes all elements, but retains the empty memory blocks rather than deallocating (current implementation deallocates all memory blocks, but in the future this should be changed to reduce needless reallocation/deallocations).<br>
    Example: <code style="color: brown">object_colony.clear();</code> </p>
  </li>
  <li><code>void change_group_sizes(const unsigned short min_group_size, const
    unsigned short max_group_size)</code> 
    <p>Changes the minimum and maximum internal group sizes, in terms of number
    of elements stored per group. If the colony is not empty and either
    min_group_size is larger than the smallest group in the colony, or
    max_group_size is smaller than the largest group in the colony, the colony
    will be internally copy-constructed into a new colony which uses the new
    group sizes, invalidating all pointers/iterators/references. <br>
    Example: <code style="color: brown">object_colony.change_group_sizes(1000,
    10000);</code> </p>
  </li>
  <li><code>void change_minimum_group_size(const unsigned short
    min_group_size)</code>
    <p>Changes the minimum internal group size only, in terms of minimum number
    of elements stored per group. If the colony is not empty and min_group_size
    is larger than the smallest group in the colony, the colony will be
    internally copy-constructed into a new colony which uses the new minimum
    group size, invalidating all pointers/iterators/references. <br>
    Example: <code
    style="color: brown">object_colony.change_minimum_group_size(100);</code>
    </p>
  </li>
  <li><code>void change_maximum_group_size(const unsigned short
    min_group_size)</code> 
    <p>Changes the maximum internal group size only, in terms of maximum number
    of elements stored per group. If the colony is not empty and either
    max_group_size is smaller than the largest group in the colony, the colony
    will be internally copy-constructed into a new colony which uses the new
    maximum group size, invalidating all pointers/iterators/references. <br>
    Example: <code
    style="color: brown">object_colony.change_maximum_group_size(1000);</code>
    </p>
  </li>
  <li><code>void reinitialize(const unsigned short min_group_size, const
    unsigned short max_group_size)</code>
    <p>Semantics of function are the same as "clear();
    change_group_sizes(min_group_size, max_group_size);", but without the
    copy-construction code of the change_group_sizes() function - this means it
    can be used with element types which are non-copy-constructible, unlike
    change_group_sizes(). <br>
    Example: <code style="color: brown">object_colony.reinitialize(1000,
    10000);</code> </p>
  </li>
  <li><code>void splice(colony &amp;source)</code> 
    <p>Transfer all elements from source colony into destination colony without invalidating pointers/iterators to either colony's elements (in other words the destination takes ownership of the source's memory blocks). After the splice, the source colony is empty. Splicing is much faster than range-moving or copying all elements from one colony to another. Colony does not guarantee a particular order of elements after splicing, for performance reasons; the insertion location of source elements in the destination colony is chosen based on the most positive performance outcome for subsequent iterations/insertions. For example if the destination colony is {1, 2, 3, 4} and the source colony is {5, 6, 7, 8} the destination colony post-splice could be {1, 2, 3, 4, 5, 6, 7, 8} or {5, 6, 7, 8, 1, 2, 3, 4}, depending on internal data.</p>
	<p>Note: if there were many erasures in the destination colony prior to splicing, post-splice insertion and iteration may be marginally slower than if all elements in the source colony had been range-moved/copied to the destination instead (due to the move/copy ability to re-use previously erased element memory locations in the destination). Note2: If the minimum group size of the source is smaller than the destination, the destination will change it's minimum group size to match the source. The same applies for maximum group sizes (if source's is larger, the destination will adjust its).<br>
    Example: <code style="color: brown">// Splice two colonies of integers together:<br>
	colony&lt;int&gt; colony1 = {1, 2, 3, 4}, colony2 = {5, 6, 7, 8};<br>
	colony1.splice(colony2);</code>
  </li>
  <li><code>void swap(colony &amp;source)
    noexcept(std::allocator_traits&lt;the_allocator&gt;::propagate_on_container_swap::value
    ||
    std::allocator_traits&lt;the_allocator&gt;::is_always_equal::value)</code>
    <p>Swaps the colony's contents with that of <code>source</code>. <br>
    Example: <code
    style="color: brown">object_colony.swap(other_colony);</code> </p>
  </li>
  <li><code>void sort();<br>
  template &lt;class comparison_function&gt;<br>
  void sort(comparison_function compare);</code> 
    <p>Sort the content of the colony. By default this compares the colony content using a less-than operator, unless the user supplies a comparison function (ie. same conditions as std::list's sort).<br>
    Example: <code
    style="color: brown">// Sort a colony of integers in ascending order:<br>
	int_colony.sort();<br>
	// Sort a colony of doubles in descending order:<br>
	double_colony.sort(std::greater<double>());</code></p>
  </li>
  <li><code>void splice(colony &amp;source);</code>
    <p>Append data from one colony container to the end of another. This operation removes all elements from the source colony. All pointers/iterators to elements within the source and destination containers retain their validity. (note: not currently implemented in reference implementation - will be in future).<br>
    Example: <code style="color: brown">// Append one colony to the end of another:<br>
	int_colony.splice(int_colony2);</code></p>
  </li>
    <li><code>colony &amp; operator = (const colony &amp;source)</code>
    <p>Copy the elements from another colony to this colony, clearing this
    colony of existing elements first. <br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++03<br>
    data_colony3 = data_colony1;<br>
    data_colony1 = data_colony2;<br>
    data_colony2 = data_colony3;</code> </p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;&amp;source)</code>
    <p>Move the elements from another colony to this colony, clearing this
    colony of existing elements first. Source colony becomes invalid but can be
    safely destructed without undefined behaviour. <br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++11<br>
    data_colony3 = std::move(data_colony1);<br>
    data_colony1 = std::move(data_colony2);<br>
    data_colony2 = std::move(data_colony3);</code> </p>
  </li>
  <li><code>bool operator == (const colony &amp;source) const noexcept</code>
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are equal. <br>
    Example: <code style="color: brown">if (object_colony == object_colony2)
    return;</code> </p>
  </li>
  <li><code>bool operator != (const colony &amp;source) const noexcept</code>
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are not equal. <br>
    Example: <code style="color: brown">if (object_colony != object_colony2)
    return;</code> </p>
  </li>
  <li><code>iterator begin() const noexcept, iterator end() const noexcept,
    const_iterator cbegin() const noexcept, const_iterator cend() const
    noexcept</code>
    <p>Return iterators pointing to, respectively, the first element of the
    colony and the element one-past the end of the colony. </p>
  </li>
  <li><code>reverse_iterator rbegin() const noexcept, reverse_iterator rend()
    const noexcept, const_reverse_iterator crbegin() const noexcept,
    const_reverse_iterator crend() const noexcept</code>
    <p>Return reverse iterators pointing to, respectively, the last element of
    the colony and the element one-before the first element of the colony.
    (note: as the reference implementation's crbegin() and rbegin() are derived
    from --end(), they will throw an exception if the colony is empty of
    elements and are not noexcept).</p>
  </li>
  <li><code>iterator get_iterator_from_pointer(const element_pointer_type
    the_pointer) const noexcept</code> 
    <p>Getting a pointer from an iterator is simple - simply dereference it
    then grab the address ie. <code>"&amp;(*the_iterator);"</code>. Getting an
    iterator from a pointer is typically not so simple. This function enables
    the user to do exactly that. This is expected to be useful in the use-case
    where external containers are storing pointers to colony elements instead
    of iterators (as iterators for colonies have 3 times the size of an element
    pointer) and the program wants to erase the element being pointed to or
    possibly change the element being pointed to. Converting a pointer to an
    iterator using this method and then erasing, is about 20% slower on average
    than erasing when you already have the iterator. This is less dramatic than
    it sounds, as it is still faster than all other std:: container erasure
    times. If the function doesn't find a non-erased element within the colony,
    based on that pointer, it returns <code>end()</code>. Otherwise it returns
    an iterator pointing to the element in question. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    a_struct *struct_pointer = &amp;(*an_iterator);<br>
    iterator another_iterator =
    data_colony.get_iterator_from_pointer(struct_pointer);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is
    correct" &lt;&lt; std::endl;</code> </p>
  </li>
  <li><code>template &lt;iterator_type&gt;size_type
    get_index_from_iterator(iterator_type &amp;the_iterator) const</code> 
    <p>While colony is a container with unordered insertion (and is therefore
    unordered), it still has a (transitory) order which may change upon erasure
    or insertion. <i>Temporary</i> index numbers are therefore obtainable.
    These can be useful, for example, when creating a saved-game file in a
    computer game, where certain elements in a container may need to be
    re-linked to other elements in other container upon reloading the save
    file. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    unsigned int index = data_colony.get_index_from_iterator(an_iterator);<br>
    if (index == 2) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>template &lt;iterator_type&gt;size_type
    get_index_from_reverse_iterator(const iterator_type &amp;the_iterator)
    const</code>
    <p>The same as get_index_from_iterator, but for reverse_iterators and
    const_reverse_iterators. Index is measured from front of colony (same as
    iterator), not back of colony. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::reverse_iterator r_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    r_iterator = data_colony.rend();<br>
    unsigned int index =
    data_colony.get_index_from_reverse_iterator(r_iterator);<br>
    if (index == 1) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>iterator get_iterator_from_index(const size_type index)
    const</code>
    <p>As described above, there may be situations where obtaining iterators to
    specific elements based on an index can be useful, for example, when
    reloading save files. This function is basically a shorthand to avoid
    typing <code>"iterator it = colony.begin(); colony.advance(it,
    50);"</code>. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    iterator an_iterator = data_colony.insert(struct_instance);<br>
    iterator another_iterator = data_colony.get_iterator_from_index(2);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is
    correct" &lt;&lt; std::endl;</code> </p>
  </li>
  <li><code>allocator_type get_allocator() const noexcept</code>
    <p>Returns a copy of the allocator used by the colony instance.</p>
  </li>
</ul>

<h4>Non-member functions</h4>

<p><em>Note: these are in fact member functions in the reference implementation
in order to avoid an unfixed template bug in MSVC2013 (this bug is not present
in any other compiler including MSVC2010/15/17).</em></p>
<ul>
  <li><code>template &lt;iterator_type&gt; void advance(iterator_type iterator,
    distance_type distance)</code>
    <p>Increments/decrements the iterator supplied by the positive or negative
    amount indicated by <i>distance</i>. Speed of incrementation will almost
    always be faster than using the ++ operator on the iterator for increments
    greater than 1. In some cases it may be O(1). The iterator_type can be an
    iterator, const_iterator, reverse_iterator or const_reverse_iterator. <br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.begin();<br>
    i_colony.advance(it, 20); </code> </p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type next(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then increments/decrements this
    iterator by the positive or negative amount indicated by <i>distance</i>.
    <br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);</code> </p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type prev(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then decrements/increments this
    iterator by the positive or negative amount indicated by <i>distance</i>.
    <br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it2 =
    i_colony.prev(i_colony.end(), 20);</code> </p>
  </li>
  <li><code>template &lt;iterator_type&gt; difference_type distance(const
    iterator_type &amp;first, const iterator_type &amp;last) const</code>
    <p>Measures the distance between two iterators, returning the result, which
    will be negative if the second iterator supplied is before the first
    iterator supplied in terms of it's location in the colony. If either
    iterator is uninitialized, behaviour is undefined.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);<br>
    colony&lt;int&gt;::iterator it2 = i_colony.prev(i_colony.end(), 20);<br>
    std::cout "Distance: " i_colony.distance(it, it2) std::endl;</code> </p>
  </li>
</ul>

<h4>Non-member functions</h4>
<ul>
  <li><code>template &lt;class T, class allocator_type, typename
    skipfield_type&amp;gt<br>
    void swap (colony&lt;T, allocator_type, skipfield_type&gt; &amp;A,
    colony&lt;T, allocator_type, skipfield_type&gt; &amp;B)
    noexcept(std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value
    ||
    std::allocator_traits&lt;the_allocator&gt;::is_always_equal::value)</code>
    <p>Swaps colony A's contents with that of colony B. <br>
    Example: <code style="color: brown">swap(object_colony,
    other_colony);</code></p>
  </li>
</ul>

<h3><a id="benchmarks"></a>Appendix B - reference implementation benchmarks</h3>

<p>Benchmark results for colony under GCC 7.1 x64 on an Intel Xeon E3-1241 (Haswell) are <a
href="http://www.plflib.org/benchmarks_haswell_gcc.htm">here</a>.</p>
<p>Older benchmark results for colony under GCC 5.1 x64 on an Intel E8500 (Core2) are <a
href="http://www.plflib.org/benchmarks_core2_gcc.htm">here</a>.</p>
<p>Older benchmark results for colony under MSVC 2015 update 3, on an Intel Xeon E3-1241 (Haswell) are <a
href="http://www.plflib.org/benchmarks_haswell_msvc.htm">here</a>. There is no commentary for
the MSVC results.</p>


<h3><a id="faq"></a>Appendix C - Frequently Asked Questions</h3>
<ol>
  <li><h4>What are some examples of situations where a colony might improve
    performance?</h4>
    <p>Some ideal situations to use a colony: cellular/atomic simulation,
    persistent octtrees/quadtrees, general game entities or destructible-objects in a
    video game, particle physics, anywhere where objects are being created and
    destroyed continuously. Also, anywhere where a vector of pointers to
    dynamically-allocated objects or a std::list would typically end up being
    used in order to preserve object references but where order is
    unimportant.</p>
  </li>
  <li><h4>What situations should you explicitly <i>not</i> use a colony
    for?</h4>
    <p>Although in practice the
    performance difference is small, a colony should not be used as a stack, ie. erasing backwards from the
    back, and then inserting, then erasing from the back, etcetera. In this case
    you should use a stack-capable container ie. plf::stack, std::vector or
    std::deque. The reason is that erasing backwards sequentially creates the
    greatest time complexity for skipfield updates, as does reinserting to the
    start of a sequentially-erased skipblock (which is what stack usage will
    entail). This effect is mitigated somewhat if an entire group is erased, in
    which case it is released to the OS and subsequent insertions will simply
    be pushing to back without the need to update a skipfield, but you'd still
    incur the skipfield update cost during erasure.</p>
  </li>
  <li><h4>If the time complexities of the insert/erase functions are (mostly)
    O(random, ranged), why are they still fast?</h4>
    <p>The time complexities are largely based on the skipfield updates
    necessary for the jump-counting skipfield pattern. The skipfield for each
    group is contiguous and separate from the skipfields for other groups, and
    so fits into the cache easily (unless the skipfield type is large), thus
    any changes to it can occur quickly - time complexity is no indicator of
    performance on a modern CPU for anything less than very large amounts of N
    (or when the type of N is large). The colony implementation uses
    <code>memmove</code> to modify the skipfield instead of iterative updates
    for all but one of the insert/erase operations, which decreases performance
    cost (<code>memmove</code> will typically be implemented as a single raw
    memory chunk copy).</p>
	 <p>There is one rarer case in erase which does not use
    <code>memmove</code>, when an element is erased and is surrounded on both
    sides by consecutive erased elements. In this case it isn't possible to
    update the skipfield using memmove because the requisite numbers do not
    exist in the skipfield and therefore cannot be copied, so it is implemented
    as a vectorized iterative update instead. Again, due to a low amount of
    branching and the small size of each skipfield the performance impact
    is minimal.</p>
  </li>
  <li><h4>Is it similar to a deque?</h4>
    <p>A deque is reasonably dissimilar to a colony - being a double-ended
    queue, it requires a different internal framework. A deque for example can't technically use a linked
    list of memory blocks because it will make some random_access iterator
    operations (eg. + operator) non-O(1). A deque and colony have no comparable performance characteristics except
    for insertion (assuming a good deque implementation). Deque erasure
    performance varies wildly depending on the implementation compared to
    std::vector, but is generally similar to vector erasure performance. A
    deque invalidates pointers to subsequent container elements when erasing
    elements, which a colony does not.</p>
    <p>As described earlier the three core aspects of colony are:</p>
    <ol type="a">
      <li>A multiple-memory-block based allocation pattern which allows for the
        removal of memory blocks when they become empty of elements.</li>
      <li>A skipfield to indicate erasures instead of reallocating elements,
        the iteration of which should typically not necessitate the use of
        branching code.</li>
      <li>A mechanism for recording erased element locations to allow for reuse
        of erased element memory space upon subsequent insertion.</li>
    </ol>
    <p>The only aspect out of these which deque also shares is a
    multiple-memory-block allocation pattern - not a strong association.</p>
  </li>
  <li><h4><a name="adt"></a>What is colony's Abstract Data Type (ADT)?</h4>
    <p>Though I am happy to be proven wrong I suspect colony is it's own
    abstract data type. While it is similar to a multiset or bag, those utilize
    key values and are not sortable (by means other than automatically by key
    value). Colony does not utilize key values, is sortable, and does not
    provide the sort of functionality one would find in a bag (eg. counting the
    number of times a specific value occurs). Some have suggested simiarities
    to deque - see FAQ item above. Similarly if we look at a
    multiset, an unordered one could be implemented on top of a colony by
    utilizing a hash table (and would in fact be more efficient than most
    non-flat implementations). But the actual fact that there is a necessity to add
    something to make it a multiset (to take and store key values) suggests colony
    is not an multiset. </p>
  </li>
  <li><h4>What are the thread-safe guarantees?</h4>
    <p>Unlike a std::vector, a colony can be read from and written to at the
    same time (assuming different locations for read and write), however it
    cannot be iterated over and written to at the same time. If we look at a
    (non-concurrent implementation of) std::vector's threadsafe matrix to see
    which basic operations can occur at the same time, it reads as follows
    (please note push_back() is the same as insertion in this regard):</p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>std::vector</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p>In other words, multiple reads and iterations over iterators can happen
    simultaneously, but the potential reallocation and pointer/iterator
    invalidation caused by insertion/push_back and erasure means those
    operations cannot occur at the same time as anything else. </p>
    <p>Colony on the other hand does not invalidate pointers/iterators to
    non-erased elements during insertion and erasure, resulting in the
    following matrix: </p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>plf::colony</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>Mostly*</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>Yes</td>
          <td>Mostly*</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p><span style="font-size: 10pt">* Erasures will not invalidate iterators
    unless the iterator points to the erased element. </span></p>
    <p>In other words, reads may occur at the same time as insertions and
    erasures (provided that the element being erased is not the element being
    read), multiple reads and iterations may occur at the same time, but
    iterations may not occur at the same time as an erasure or insertion, as
    either of these may change the state of the skipfield which's being
    iterated over. Note that iterators pointing to end() may be invalidated by
    insertion.</p>
    <p>So, colony could be considered more inherently threadsafe than a
    (non-concurrent implementation of) std::vector, but still has some areas
    which would require mutexes or atomics to navigate in a multithreaded
    environment.</p>
    <p>For a more fully concurrent version of colony, an atomic boolean
    skipfield could be utilized instead of a jump-counting one, if one were
    allowed to ignore time complexity rules for iterator operations. This would
    enable largely lock-free operation of a colony, at the expense of iteration
    speed.</p>
  </li>
  <li><h4>Any pitfalls to watch out for?</h4>
    <ol type="1">
      <li>Because erased-element memory locations will be reused by
        <code>insert()</code> and <code>emplace()</code>, insertion position is
        essentially random unless no erasures have been made, or an equal
        number of erasures and insertions have been made.</li>
      <li>In the current reference implementation reserve()
        can only reserve a number of elements up to the maximum number afforded by
        the skipfield type. Hopefully there will be time to rework colony in future so that it more fully supports reserve.</li>
    </ol>
  </li>
  <li><h4>Am I better off storing iterators or pointers to colony elements?</h4>
    <p>Testing so far indicates that storing pointers and then using
    <code>get_iterator_from_pointer()</code> when or if you need to do an erase
    operation on the element being pointed to, yields better performance than
    storing iterators and performing erase directly on the iterator. This is
    simply due to the size of iterators (3 pointers) in the reference
    implementation. </p>
  </li>
  <li><h4>Any special-case uses?</h4>
    <p>In the special case where many, many elements are being continually
    erased/inserted in realtime, you might want to experiment with limiting the
    size of your internal memory groups in the constructor. The form of this is
    as follows: <br>
    <code>plf::vector&lt;object&gt; a_vector;<br>
    a_vector.change_group_sizes(500, 5000);</code> <br>
    where the first number is the minimum size of the internal memory groups
    and the second is the maximum size. Note these can be the same size,
    resulting in an unchanging group size for the lifetime of the colony
    (unless <code>change_group_sizes</code> is called again or operator = is
    called).</p>
    <p>One reason to do this is that it is slightly slower to pop an element
    location off the internal erased-location-recycling stack, than it is to
    insert a new element to the end of the colony (the default behaviour when
    there are no previously-erased elements). If there are any erased elements
    in the colony, the colony will recycle those memory locations, unless the
    entire group is empty, at which point it is freed to memory. So if a group
    size is large and many, many erasures occur but the group is not completely
    emptied, (a) the number of erased element locations in the recycling stack
    could get large and increase memory usage and (b) iteration performance may
    suffer due to large memory gaps between any two non-erased elements. In
    that scenario you may want to exeriment with benchmarking and limiting the
    minimum/maximum sizes of the groups, and find the optimal size for a
    specific use case.</p>
    <p>Please note that the the fill, range and initializer-list constructors
    can also take group size parameters, making it possible to construct filled
    colonies using custom group sizes.</p>
  </li>
  <li><h4><a name="remove_when_empty"></a>Why must groups be removed when
    empty, or moved to the back of the chain?</h4>
    <p>Two reasons:</p>
    <ol type="a">
      <li>Standards compliance: if groups aren't removed then <code>++</code>
        and <code>--</code> iterator operations become O(random) in terms of
        time complexity, making them non-compliant with the C++ standard. At
        the moment they are O(1) amortised, typically one update for both
        skipfield and element pointers, but two if a skipfield jump takes the
        iterator beyond the bounds of the current group and into the next
        group. But if empty groups are allowed, there could be anywhere between
        1 and <code>size_type</code> empty groups between the current element
        and the next. Essentially you get the same scenario as you do when
        iterating over a boolean skipfield. While it is possible to move these to the back of the colony as trailing groups, and remove their entries from the erased locations stack, this may create performance issues if any of the groups are not at their maximum size (see below).</li>
      <li>Performance: iterating over empty groups is slower than them not
        being present, cache wise - but also if you have to allow for empty
        groups while iterating, then you have to include a while loop in every
        iteration operation, which increases cache misses and code size. The strategy of removing groups when they become empty also removes (assuming randomized erasure) smaller groups from the colony before larger groups, which has a net result of improving iteration (as with a larger group, more iterations within the group can occur before the end-of-group condition is reached and a transfer to the next group (and subsequent cache miss) occurs). Lastly, pushing to the back of a colony is faster than recycling memory
        locations as each insertion occurs to a similar memory location and less work is necessary. When a group is removed or moved to the back of the group chain (past end()), it's recyclable memory locations are
        also removed from memory, hence subsequent insertions are more
        likely to be pushed to the back of the colony.</li>
    </ol>
   </li>
  <li><h4>Group sizes - what are they based on, how do they expand, etc</h4>
    <p>In the reference implementation group sizes start from the either the
    default minimum size (8 elements, larger if the type stored is small) or an
    amount defined by the programmer (with a minimum of 3 elements). Subsequent
    group sizes then increase the <i>total capacity</i> of the colony by a
    factor of 2 (so, 1st group 8 elements, 2nd 8 elements, 3rd 16 elements, 4th
    32 elements etcetera) until the maximum group size is reached. The default
    maximum group size is the maximum possible number that the skipfield
    bitdepth is capable of representing
    (std::numeric_limits&lt;skipfield_type&gt;::max()). By default the
    skipfield type is unsigned short so on most platforms the maximum size of a
    group would be 65535 elements. Unsigned short (guaranteed to be at least 16
    bit, equivalent to C++11's uint_least16_t type) was found to have the best
    performance in real-world testing due to the balance between memory
    contiguousness, memory waste and the restriction on skipfield update time
    complexity. Initially the design also fitted the use-case of gaming better
    (as games tend to utilize lower numbers of elements than some other
    fields), and that was the primary development field at the time.</p>
  </li>
</ol>



<h3><a id="responses"></a>Appendix D - Specific responses to previous committee feedback</h3>
<ol>
<li><h4>Why not 'bag'? Colony is too selective etcetera, etcetera</h4>
<p>'bag' is problematic as it's partially synonymous with multiset (and colony is <a href="p0447r4.html#adt">not</a> one of those) and partially because it's vague - it doesn't describe how the container works. I have not come up with an alternate name that fits as well, nor has anyone as yet. 'colony' is an intuitive name if you understand the container, and allows for easy conveyance of how it works. The suggestion that the use of the word is selective in terms of it's meaning, is also true for vector, set, 'bag', and many other C++ names. Largely, misgivings appear to stem from unfamiliarity with the term. Non-verbose alternatives which don't lead to incorrect assumptions are always appreciated.</p>
<p>It is true that 'colony' says more about it's structure than it's usage, however I think it is valuable to understand how colony works, in this case. If someone were to erase an element, then insert a new object, they might be surprised to discover that pointers to the erased element may now point to the newly-inserted one, unless they had a basic understanding of how the container works. Also if they inserted an element and subsequently discover the element is at index four in the iterative sequence rather than at the back of the colony, this could be confusing to a newcomer, however it is easily explained via the metaphorical explanation in the introduction of this document. Personally I would rather have 'suitcase' than bag - it's only slightly more silly, and implies location stability, which is what a bag container typically lacks.</p>
</li>
<li><h4>"Unordered and no associative lookup, so this only supports use cases where you're going to do something to every element."</h4>
<p>As noted the container is designed for highly object-oriented situations where you have many elements in different containers referring to many other elements in other containers. This can be done with pointers or iterators in colony (insert returns an iterator which can be dereferenced to get a pointer, pointers can be converted into iterators with the supplied functions  (for erase etc)) and because pointers/iterators stay stable regardless of insertion/erasure, this usage is unproblematic. You could say the pointer is equivalent to a key in this case (but without the overhead). That is the first access pattern, the second is straight iteration over the container, as you say. Secondly, the container does have (typically better than O(N)) advance/next/prev implementations, so elements can be skipped.</p></li>
<li><h4>"Do we really need the skipfield_type template argument?"</h4>
<p>If it is possible to relegate this to a constructor argument (I'm not sure how exactly) I would welcome it, but this argument currently promotes use of the container in heavily-constrained memory environments, and in high-performance small-N collections. Unfortunately it also means <code>operator =</code> and some other functions won't work between colonies of the same type but differing skipfield types. See more explanation in V. Technical Specifications. This is something I am flexible on, as a singular skipfield type will cover the majority of scenarios.</p></li>
<li><h4>"Prove this is not an allocator"</h4>
<p>I'm not really sure how to answer this, as I don't see the resemblance, unless you count maps, vectors etc as being allocators also. The only aspect of it which resembles what an allocator might do, is the memory re-use mechanism. However, this could not be used by any container which was not set up specifically to iterate with a skipfield (or which had a non-contiguous iterative mechanism), and so is reasonably specific. I don't claim that the way colony re-uses memory is anything unique - slot_map also performs this operation - but it <i>is necessary to the structure as a whole</i>, and will not function without it, just as it will not function without the jump-counting skipfield pattern or a block-based memory allocation pattern. Each of these is in service of colony's core goals: fast insertion and erasure, reasonable iteration speed and a lack of invalidation of pointers to non-erased elements upon insertion and erasure.</p>
</li>
</ol>



<h3><a id="questions"></a>Appendix E - Open Questions from the author</h3>
<ol>
<li>Should "shrink_to_fit()" follow the semantics of vector or deque? Deque shrink_to_fit() is geared more towards freeing unused memory blocks, not invalidating existing pointers-to-elements, whereas vector shrink_to_fit() consolidates all elements into a memory block which exactly fits size(). If we follow the semantics of vector, a secondary "free_unused_memory()" function will be necessary. If we follow deque semantics, we lose optimization strategies for consolidating the colony (see code for shrink_to_fit() in current implementation). Currently this proposal uses deque semantics.</li>
<li>Should reserve() be implemented at all? Since there is no reallocation upon instantiation of a new memory block, insert is not a costly operation when size == capacity. The main advantage I can see for retaining it is for high-performance/game programming, where allocation operations can be moved to non-timing-critical code.</li>
<li>Name? I can't come up with a better one. I am more or less resigned to the fact that the eventual name will be 'bag', but I just want to go on record as saying: 'That's terrible. You should not do that.' for the reasons stated above.</li>
</ol>


<h3><a id="revisions"></a>Appendix F - Paper revision history</h3>
<ul>
<li>R4: Addition of revision history and review feedback appendices. General rewording. Update of benchmarks to v4 of colony, using max 1000000 N for most benchmarks, and using GCC 7.1 as compiler on a Haswell-core machine. Previous benchmarks also still available at external links. Expansion of initial metaphorical explanation. Cutting of some dead wood. Addition of some more dead wood. Reversion to HTML, benchmarks moved to external URL, based on feedback. Change of font to Times New Roman based on looking at what other papers were using, though I did briefly consider Comic Sans. Change to insert specifications.</li>
<li>R3: Jonathan Wakely's extensive technical critique has been actioned on, in both documentation and the reference implementation. "Be clearer about what operations this supports, early in the paper." - done (V. Technical Specifications). "Be clear about the O() time of each operation, early in the paper." - done (for main operations V. Technical Specifications). Responses to some other feedbacks included in the foreword.</li>
<li>R2: Rewording.</li>
</ol>


</body>
</html>
