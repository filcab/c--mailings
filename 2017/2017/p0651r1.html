<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Switch the Ranges TS to Use Variable Concepts</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style type="text/css">
  ins {
    color:#009a9a; text-decoration:underline;
  }
  
  del {
    color:red; text-decoration:line-through;
  }
  
  ednote {
    color:blue;
  }
  
  table {
    border-collapse: collapse;
  }
  
  table, th, td {
    border: 1px solid black;
  }
  </style>
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
  <tr>
    <td width="172" align="left" valign="top">Document number:</td>
    <td width="435">
      P0651R1
    </td>
  </tr>
  <tr>
    <td width="172" align="left" valign="top">Date:</td>
    <td width="435">2017-07-10</td>
  </tr>
  <tr>
    <td width="172" align="left" valign="top">Project:</td>
    <td width="435">C++ Extensions for Ranges</td>
  </tr>
  <tr>
    <td width="172" align="left" valign="top">Reply-to:</td>
    <td width="435">
      Eric Niebler &lt;<a href="mailto:eniebler@boost.org">eniebler@boost.org</a>&gt;
    </td>
  </tr>
  <tr>
    <td width="172" align="left" valign="top">Audience:</td>
    <td width="435">
      Library Working Group
    </td>
  </tr>
</table>
<div id="header">
<h1 class="title">Switch the Ranges TS to Use Variable Concepts</h1>
</div>
<div id="TOC">
<ul>
<li><a href="p0651r1.html#synopsis"><span class="toc-section-number">1</span> Synopsis</a></li>
<li><a href="p0651r1.html#revision-history"><span class="toc-section-number">2</span> Revision History</a><ul>
<li><a href="p0651r1.html#r1"><span class="toc-section-number">2.1</span> R1</a></li>
</ul></li>
<li><a href="p0651r1.html#proposed-solution"><span class="toc-section-number">3</span> Proposed Solution</a><ul>
<li><a href="p0651r1.html#non-overloaded-concepts"><span class="toc-section-number">3.1</span> Non-overloaded concepts</a></li>
<li><a href="p0651r1.html#cross-type-concepts"><span class="toc-section-number">3.2</span> Cross-type concepts</a></li>
<li><a href="p0651r1.html#variable-argument-concepts"><span class="toc-section-number">3.3</span> Variable-argument concepts</a></li>
</ul></li>
<li><a href="p0651r1.html#discussion"><span class="toc-section-number">4</span> Discussion</a><ul>
<li><a href="p0651r1.html#alternative-solutions"><span class="toc-section-number">4.1</span> Alternative Solutions</a><ul>
<li><a href="p0651r1.html#leave-function-style-intact"><span class="toc-section-number">4.1.1</span> Leave Function-Style Intact</a></li>
</ul></li>
</ul></li>
<li><a href="p0651r1.html#implementation-experience"><span class="toc-section-number">5</span> Implementation Experience</a></li>
<li><a href="p0651r1.html#proposed-design"><span class="toc-section-number">6</span> Proposed Design</a><ul>
<li><a href="p0651r1.html#section-concepts-library-concepts.lib"><span class="toc-section-number">6.1</span> Section “Concepts library” ([concepts.lib])</a></li>
<li><a href="p0651r1.html#section-general-utilities-library-utilities"><span class="toc-section-number">6.2</span> Section “General utilities library” ([utilities])</a></li>
<li><a href="p0651r1.html#section-iterators-library-iterators"><span class="toc-section-number">6.3</span> Section “Iterators library” ([iterators])</a></li>
<li><a href="p0651r1.html#section-algorithms-library-algorithms"><span class="toc-section-number">6.4</span> Section “Algorithms library” [algorithms]</a></li>
</ul></li>
<li><a href="p0651r1.html#acknowledgements"><span class="toc-section-number">7</span> Acknowledgements</a></li>
</ul>
</div>
<h1 id="synopsis"><span class="header-section-number">1</span> Synopsis</h1>
<p>Currently, the Ranges TS uses function-style concepts. That’s because in a few places, concept names<br />
are “overloaded”. Rather than have some variable concepts and some function concepts, the Ranges TS<br />
opted for function concepts everywhere. The has proven unsatisfactory, because it fills function<br />
signatures with useless syntactic noise (e.g., <code>()</code>).</p>
<p>Also, committee in Kona (2016) expressed concern at there being multiple ways to define a concept.<br />
There seemed interest in eliminating function-style concept definitions. The Ranges TS was given as<br />
an example of where function-style concepts were used. But the Ranges TS does not need them and<br />
would in fact probably be better off without them.</p>
<p>The reasons for dropping function-style concepts from the Ranges TS then are:</p>
<ol>
<li>To eliminate syntactic noise.</li>
<li>To eliminate user confusion that comes at a concept’s point-of-use, where sometimes parens are<br />
needed (in <code>requires</code> clauses) and sometimes not (when the concept is used as a placeholder).</li>
<li>To avoid depending on a feature that may get dropped.</li>
<li>To avoid becoming a reason to keep a little-loved feature.</li>
</ol>
<p>There is really only one reason for keeping function-style concepts in the Ranges TS:</p>
<ol>
<li>In several places, the Ranges TS defines concepts with similar semantic meaning but different<br />
numbers of parameters; function-style concepts neatly captures this intent by allowing these<br />
concepts to share a name.</li>
</ol>
<h1 id="revision-history"><span class="header-section-number">2</span> Revision History</h1>
<h2 id="r1"><span class="header-section-number">2.1</span> R1</h2>
<ul>
<li>Restore the <code>()</code> that were inadvertently ommitted from the <code>Swappable</code> constraints on the members of class <code>tagged</code>, and then strike them.</li>
</ul>
<h1 id="proposed-solution"><span class="header-section-number">3</span> Proposed Solution</h1>
<p>We propose respecifying the Ranges TS in terms of variable-style concepts. There are three cases<br />
to handle:</p>
<ol>
<li>Non-overloaded concepts</li>
<li>Cross-type concepts</li>
<li>Variable-argument concepts</li>
</ol>
<h2 id="non-overloaded-concepts"><span class="header-section-number">3.1</span> Non-overloaded concepts</h2>
<p>In the case of concepts that are not overloaded, changing to variable concepts is purely a<br />
syntactic rewrite. For example, the following function-style concept:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
concept <span class="dt">bool</span> Movable() {
  <span class="cf">return</span> MoveConstructible&lt;T&gt;() &amp;&amp;
    Assignable&lt;T&amp;, T&gt;() &amp;&amp;
    Swappable&lt;T&amp;&gt;();
}</code></pre></div>
<p>would become:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
concept <span class="dt">bool</span> Movable =
  MoveConstructible&lt;T&gt; &amp;&amp;
  Assignable&lt;T&amp;, T&gt; &amp;&amp;
  Swappable&lt;T&amp;&gt;;</code></pre></div>
<p>Obviously, all uses of this concept would also need to be changed to drop the trailing empty parens<br />
(“<code>()</code>”), if any.</p>
<h2 id="cross-type-concepts"><span class="header-section-number">3.2</span> Cross-type concepts</h2>
<p>Some binary concepts offer a unary form to mean “same type”, such that <code>Concept&lt;A&gt;()</code> is<br />
semantically identical to <code>Concept&lt;A, A&gt;()</code> (e.g., <code>EqualityComparable</code>). In these cases, a simple<br />
rewrite into a variable form will not result in valid code, since variable concepts cannot be<br />
overloaded. In these cases, we must find a different spelling for the unary and binary forms.</p>
<p>The suggestion is to use the suffix <code>With</code> for the binary form. So, <code>EqualityComparable&lt;int&gt;</code> would<br />
be roughly equivalent to <code>EqualityComparableWith&lt;int, int&gt;</code>. This follows the precedent set by the<br />
type traits <code>is_swappable</code> and <code>is_swappable_with</code>.</p>
<p>The concepts in the Ranges TS to which this applies are:</p>
<ul>
<li><code>EqualityComparable</code></li>
<li><code>Swappable</code></li>
<li><code>StrictTotallyOrdered</code></li>
</ul>
<p>This pattern also appears in the relation concepts:</p>
<ul>
<li><code>Relation</code></li>
<li><code>StrictWeakOrder</code></li>
</ul>
<p>However, the forms <code>Relation&lt;R, T&gt;()</code> and <code>StrictWeakOrder&lt;R, T&gt;()</code> are used nowhere in the Ranges<br />
TS and can simply be dropped with no impact.</p>
<h2 id="variable-argument-concepts"><span class="header-section-number">3.3</span> Variable-argument concepts</h2>
<p>The concepts that have to do with callables naturally permit a variable number of arguments and<br />
are best expressed using variadic parameters packs. However, the <em>indirect</em> callable concepts used<br />
to constrain the higher-order STL algorithms are fixed-arity (not variadic) so as to be able to<br />
check callability with the cross-product of the iterators’ associated types. The STL algorithms<br />
only ever deal with unary and binary callables, so the indirect callable concepts are “overloaded”<br />
on zero, one, or two arguments.</p>
<p>The affected concepts are:</p>
<ul>
<li><code>IndirectInvocable</code></li>
<li><code>IndirectRegularInvocable</code></li>
<li><code>IndirectPredicate</code></li>
</ul>
<p>(The concepts <code>IndirectRelation</code> and <code>IndirectStrictWeakOrder</code> are unaffected because they are not<br />
overloaded.)</p>
<p>The concept <code>IndirectInvocable</code> is used to constrain the <code>for_each</code> algorithm, where the function<br />
object it constrains is unary. So, we suggest dropping the nullary and binary forms of this concept<br />
and renaming <code>IndirectInvocable</code> to <code>IndirectUnaryInvocable</code>.</p>
<p>Likewise, the concept <code>IndirectRegularInvocable</code> is used to constrain the <code>projected</code> class<br />
template, where the function object it constrains is unary. So, we suggest dropping the nullary and<br />
binary forms of this concept and renaming <code>IndirectRegularInvocable</code> to<br />
<code>IndirectRegularUnaryInvocable</code>.</p>
<p>We observe that <code>IndirectPredicate</code> is only ever used to constrain unary predicates (once we fix<br />
<a href="https://github.com/ericniebler/stl2/issues/411">ericniebler/stl2#411</a>), so we suggest dropping the binary form and renaming <code>IndirectPredicate</code><br />
to <code>IndirectUnaryPredicate</code>.</p>
<h1 id="discussion"><span class="header-section-number">4</span> Discussion</h1>
<p>Should the committee ever decide to permit variable-style concepts to be overloaded, we could<br />
decide to revert the name changes proposed in this document. For example, we could offer<br />
<code>EqualityComparable&lt;A, B&gt;</code> as an alternate syntax for <code>EqualityComparableWith&lt;A, B&gt;</code>, and deprecate<br />
<code>EqualityComparableWith</code>.</p>
<h2 id="alternative-solutions"><span class="header-section-number">4.1</span> Alternative Solutions</h2>
<p>The following solutions have been considered and dismissed.</p>
<h3 id="leave-function-style-intact"><span class="header-section-number">4.1.1</span> Leave Function-Style Intact</h3>
<p>There is nothing wrong <em>per se</em> with leaving the concepts as function-style. The Ranges TS<br />
is based on the Concepts TS as published, which supports the syntax. Giving up function-style<br />
concepts forces us to come up with unique names for semantically similar things, including the<br />
admittedly awful <code>IndirectUnaryInvocable</code> and friends.</p>
<p>This option comes with a few lasting costs, already discussed above. We feel the costs of sticking<br />
with function-style concepts outweigh the benefits of being able to “overload” concept names.</p>
<h1 id="implementation-experience"><span class="header-section-number">5</span> Implementation Experience</h1>
<p>All the interface changes suggested in this document have been implemented and tested in the<br />
Ranges TS’s reference implementation at <a href="https://github.com/CaseyCarter/cmcstl2" class="uri">https://github.com/CaseyCarter/cmcstl2</a>. The change was<br />
straightforward and unsurprising.</p>
<h1 id="proposed-design"><span class="header-section-number">6</span> Proposed Design</h1>
<p><ednote>[ <em>Editorial note:</em> In places where a purely mechanical transformation is sufficient, rather<br />
than show all the diffs (which would be overwhelming and tend to obsure the more meaningful edits),<br />
we describe the transformation, give an example, and instruct the editor to make the mechanical<br />
change everywhere applicable. In other cases, where concepts change name or need to be respecified,<br />
the changes are shown explicitly with diff marks. ]</ednote></p>
<p>In all places in the document where concept checks are applied with a trailing set of empty parens<br />
(“<code>()</code>”), remove the parens.</p>
<h2 id="section-concepts-library-concepts.lib"><span class="header-section-number">6.1</span> Section “Concepts library” ([concepts.lib])</h2>
<p>In “Header <code>&lt;experimental/ranges/concepts&gt;</code> synopsis” ([concepts.lib.synopsis]), except where noted<br />
below, change all the concept definitions from function-style concepts to variable-style concepts,<br />
following the pattern for <code>Same</code> shown below:</p>
<blockquote><tt>
template &lt;class T, class U&gt;<br/>
concept bool Same<del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> <i>see below</i>;<br/>
<del>}</del>
</tt></blockquote>
<p>Change the second (binary) forms of <code>Swappable</code>, <code>EqualityComparable</code>, and <code>StrictTotallyOrdered</code> as<br />
follows:</p>
<blockquote><tt>
template &lt;class T, class U&gt;<br/>
concept bool Swappable<ins>With</ins><del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> <i>see below</i>;<br/>
<del>}</del>
</tt></blockquote>
<blockquote><tt>
template &lt;class T, class U&gt;<br/>
concept bool EqualityComparable<ins>With</ins><del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> <i>see below</i>;<br/>
<del>}</del>
</tt></blockquote>
<blockquote><tt>
template &lt;class T, class U&gt;<br/>
concept bool StrictTotallyOrdered<ins>With</ins><del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> <i>see below</i>;<br/>
<del>}</del>
</tt></blockquote>
<p>In addition, remove the following two concept declarations:</p>
<blockquote><tt><del>
template &lt;class R, class T&gt;<br/>
concept bool Relation() {<br/>
&nbsp;&nbsp;return see below;<br/>
}<br/>
<br/>
template &lt;class R, class T&gt;<br/>
concept bool StrictWeakOrder() {<br/>
&nbsp;&nbsp;return see below;<br/>
}
</del></tt></blockquote>
<p>Make the corresponding edits in sections 7.3 [concepts.lib.corelang] through section 7.6<br />
[Callable concepts], except as follows.</p>
<p>In the section “Concept <code>Movable</code> ([concepts.lib.object.movable]), change the definition of<br />
<code>Movable</code> as follows (includes changes from <a href="http://wg21.link/P0547R1">P0547R1</a> and<br />
<a href="https://github.com/ericniebler/stl2/issues/174">ericniebler/stl2#174 “Swappable concept and P0185 swappable traits”</a>):</p>
<blockquote><tt>
template &lt;class T&gt;</br>
concept bool Movable<del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del> std::is_object&lt;T&gt;::value &amp;&amp; // <i>see below</i></br>
&nbsp;&nbsp;&nbsp;&nbsp;MoveConstructible&lt;T&gt; &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Assignable&lt;T&amp;, T&gt; &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Swappable&lt;T<del>&amp;</del>&gt;;</br>
<del>}</del><br/>
</tt></blockquote>
<p>In section “Concept <code>Swappable</code>” ([concepts.lib.corelang.swappable]), change the name of the binary<br />
form of <code>Swappable</code> to <code>SwappableWith</code> as follows:</p>
<p><ednote>[ <i>Editorial note:</i> This includes the resolutions of <a href="https://github.com/ericniebler/stl2/issues/155">ericniebler/stl2#155 “Comparison<br />
concepts and reference types”</a> and<br />
<a href="https://github.com/ericniebler/stl2/issues/174">ericniebler/stl2#174 “Swappable concept and P0185 swappable traits”</a>. ]</ednote></p>
<blockquote><tt>
template &lt;class T&gt;<br/>
concept bool Swappable<del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> requires(T&amp;<del>&amp;</del> a, T&amp;<del>&amp;</del> b) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ranges::swap(<del>std::forward&lt;T&gt;(</del>a<del>)</del>, <del>std::forward&lt;T&gt;(</del>b<del>)</del>);<br/>
&nbsp;&nbsp;};<br/>
<del>}</del><br/>
<br/>
template &lt;class T, class U&gt;<br/>
concept bool Swappable<ins>With =</ins><del>() {</del><br/>
&nbsp;&nbsp;<del>return Swappable&lt;T&gt;() &amp;&amp;</del><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<del>Swappable&lt;U&gt;() &amp;&amp;</del><br/>
&nbsp;&nbsp;&nbsp;&nbsp;CommonReference&lt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;T&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp;&gt;<del>()</del> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;requires(T&amp;&amp; t, U&amp;&amp; u) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<ins>ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;T&gt;(t));</ins><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<ins>ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;U&gt;(u));</ins><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<del>}</del>
</tt></blockquote>
<p>In [concepts.lib.corelang.swappable]/p2, change the two occurrences of <code>Swappable&lt;T, U&gt;()</code> to<br />
<code>SwappableWith&lt;T, U&gt;</code>.</p>
<p>Change section “Concept <code>EqualityComparable</code>” ([concepts.lib.compare.equalitycomparable])/p3-4 as<br />
follows:</p>
<blockquote>
3 [ <i>Note:</i> The requirement that the expression <tt>a == b</tt> is equality preserving implies that</br>
<tt>==</tt> is reflexive, transitive, and symmetric. <i>-- end note</i> ]</br>
</br>
<blockquote><tt>
template &lt;class T, class U&gt;</br>
concept bool EqualityComparable<ins>With</ins><del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del></br>
&nbsp;&nbsp;&nbsp;&nbsp;EqualityComparable&lt;T&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;EqualityComparable&lt;U&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CommonReference&lt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;T&gt;&amp;,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp;><del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;EqualityComparable&lt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;common_reference_t&lt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;T&gt;&amp;,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp;&gt;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;WeaklyEqualityComparable&lt;T, U&gt;<del>()</del>;</br>
<del>}</del></br>
</tt></blockquote>
</br>
4 Let <tt>a</tt> be a <tt>const</tt> lvalue of type <tt>remove_reference_t&lt;T&gt;</tt>, <tt>b</tt> be a <tt>const</tt> lvalue of type</br>
<tt>remove_reference_t&lt;U&gt;</tt>, and <tt>C</tt> be <tt>common_reference_t&lt;const remove_reference_t&lt;T&gt;&amp;,</br>
const remove_reference_t&lt;U&gt;&amp;&gt;</tt>. Then <tt>EqualityComparable<ins>With</ins>&lt;T, U&gt;<del>()</del></tt> is satisfied if</br>
and only if:</br>
</br>
(4.1) -- <tt>bool(t == u) == bool(C(t) == C(u))</tt>.</br>
</blockquote>
<p><ednote>[<i>Note:</i>This includes the resolution of <a href="https://github.com/ericniebler/stl2/issues/155">ericniebler/stl2#155</a>. ] </ednote></p>
<p>In section “Concept <code>StrictTotallyOrdered</code>” ([concepts.lib.corelang.stricttotallyordered]), change the name of the binary<br />
form of <code>StrictTotallyOrdered</code> to <code>StrictTotallyOrderedWith</code> as follows:</p>
<p><ednote>[ <i>Editorial note:</i> This includes the resolution of <a href="https://github.com/ericniebler/stl2/issues/155">ericniebler/stl2#155 “Comparison<br />
concepts and reference types”</a>. ]</ednote></p>
<blockquote><tt>
template &lt;class T&gt;<br/>
concept bool StrictTotallyOrdered<ins>With</ins><del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del><br/>
&nbsp;&nbsp;&nbsp;&nbsp;StrictTotallyOrdered&lt;T&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;StrictTotallyOrdered&lt;U&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CommonReference&lt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;T&gt;&amp;,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;StrictTotallyOrdered&lt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;common_reference_t&lt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;T&gt;&amp;,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp;&gt;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;EqualityComparable<ins>With</ins>&lt;T, U&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires(const remove_reference_t&lt;T&gt;&amp; t,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp; u) {</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ t &lt; u } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ t &gt; u } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ t &lt;= u } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ t &gt;= u } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ u &lt; t } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ u &gt; t } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ u &lt;= t } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ u &gt;= t } -&gt; Boolean&amp;&amp;;</br>
&nbsp;&nbsp;&nbsp;&nbsp;};</br>
<del>}</del>
</tt></blockquote>
<p>In [concepts.lib.corelang.stricttotallyordered]/p2, change the occurrence of<br />
<code>StrictTotallyOrdered&lt;T, U&gt;()</code> to <code>StrictTotallyOrderedWith&lt;T, U&gt;</code>.</p>
<p>Change section “Concept <code>Relation</code>” ([concepts.lib.callable.relation]) as follows:</p>
<p><ednote>[ <i>Editorial note:</i> This includes the resolution of <a href="https://github.com/ericniebler/stl2/issues/155">ericniebler/stl2#155 “Comparison<br />
concepts and reference types”</a>. ]</ednote></p>
<blockquote><tt><del>
template &lt;class R, class T&gt;<br/>
concept bool Relation() {<br/>
&nbsp;&nbsp;return Predicate&lt;R, T, T&gt;;<br/>
}<br/></del>
<br/>
template &lt;class R, class T, class U&gt;<br/>
concept bool Relation<del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return Relation</del><ins>Predicate</ins>&lt;R, T<ins>, T</ins>&gt;<del>()</del> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<del>Relation</del><ins>Predicate</ins>&lt;R, U<ins>, U</ins>&gt;<del>()</del> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CommonReference&lt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;T&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp;&gt;<del>()</del> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<del>Relation</del><ins>Predicate</ins>&lt;R,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<ins>common_reference_t&lt;</ins><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<ins>const remove_reference_t&lt;T&gt;&amp;,</ins><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<ins>const remove_reference_t&lt;U&gt;&amp;&gt;,</ins><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;common_reference_t&lt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;T&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const remove_reference_t&lt;U&gt;&amp;&gt;&gt;<del>()</del> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;R, T, U&gt;<del>()</del> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;R, U, T&gt;<del>()</del>;<br/>
<del>}</del>
</tt></blockquote>
<p>Change section “Concept <code>StrictWeakOrder</code>” ([concepts.lib.callable.strictweakorder]) as follows:</p>
<blockquote><tt><del>
template &lt;class R, class T&gt;<br/>
concept bool StrictWeakOrder() {<br/>
&nbsp;&nbsp;return Relation&lt;R, T&gt;();<br/>
}<br/></del>
<br/>
template &lt;class R, class T, class U&gt;<br/>
concept bool StrictWeakOrder<del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> Relation&lt;R, T, U&gt;<del>()</del>;<br/>
<del>}</del>
</tt></blockquote>
<h2 id="section-general-utilities-library-utilities"><span class="header-section-number">6.2</span> Section “General utilities library” ([utilities])</h2>
<p>Change section “Header <code>&lt;experimental/ranges/utility&gt;</code> synopsis” ([utility]/p2) as follows<br />
(includes the resolution of <a href="https://github.com/ericniebler/stl2/issues/174">ericniebler/stl2#174 “Swappable concept and P0185 swappable traits”</a>):</p>
<blockquote><tt>
// 8.5.2, struct with named accessors<br/>
template &lt;class T&gt;<br/>
concept bool TagSpecifier<del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> <i>see below</i> ;<br/>
<del>}</del><br/>
<br/>
template &lt;class F&gt;<br/>
concept bool TaggedType<del>() {</del><ins> =</ins><br/>
&nbsp;&nbsp;<del>return</del> <i>see below</i> ;<br/>
<del>}</del><br/>
<br/>
template &lt;class Base, TagSpecifier... Tags&gt;<br/>
&nbsp;&nbsp;requires sizeof...(Tags) &lt;= tuple_size&lt;Base&gt;::value<br/>
struct tagged : <br/>
&nbsp;&nbsp;[...]<br/>
&nbsp;&nbsp;tagged&amp; operator=(U&amp;&amp; u) noexcept(<i>see below</i>);<br/>
&nbsp;&nbsp;void swap(tagged&amp; that) noexcept(<i>see below</i>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;requires Swappable&lt;Base<del>&amp;</del>&gt;<del>()</del>;<br/>
&nbsp;&nbsp;friend void swap(tagged&amp;, tagged&amp;) noexcept(<i>see below</i>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;requires Swappable&lt;Base<del>&amp;</del>&gt;<del>()</del>;<br/>
};<br/>
</tt></blockquote>
<p>Make the accompanying edit to the definitions of <code>TagSpecifier</code> and <code>TaggedType</code> in section<br />
“Class template <code>tagged</code>” [taggedtup.tagged]/p2, and to the detailed specifications of<br />
<code>tagged::swap</code> and the non-member <code>swap(tagged&amp;, tagged&amp;)</code> overload in<br />
[taggedtup.tagged]/p20 and p23</p>
<p>In the declarations of <code>equal_to&lt;void&gt;::operator()</code> and <code>not_equal_to&lt;void&gt;::operator()</code> in section<br />
“Comparisons” [comparisons]/p8-9, change <code>EqualityComparable&lt;T, U&gt;()</code> to<br />
<code>EqualityComparableWith&lt;T, U&gt;</code>.</p>
<p>In the declarations of <code>greater&lt;void&gt;::operator()</code>, <code>less&lt;void&gt;::operator()</code>,<br />
<code>greater_equal&lt;void&gt;::operator()</code>, and <code>less_equal&lt;void&gt;::operator()</code> in section<br />
“Comparisons” [comparisons]/p10-13, change <code>StrictTotallyOrdered&lt;T, U&gt;()</code> to<br />
<code>StrictTotallyOrderedWith&lt;T, U&gt;</code>.</p>
<h2 id="section-iterators-library-iterators"><span class="header-section-number">6.3</span> Section “Iterators library” ([iterators])</h2>
<p>In “Header <code>&lt;experimental/ranges/iterators&gt;</code> synopsis” ([concepts.lib.synopsis]), except where noted<br />
below, change all the function-style concept definitions to variable-style concepts.</p>
<p>In section “Header <code>&lt;experimental/ranges/iterator&gt;</code> synopsis” ([iterator.synopsis]), make the<br />
following changes:</p>
<blockquote><tt>
// 9.4, indirect callable requirements:</br>
// 9.4.2, indirect callables:</br>
<del>template &lt;class F&gt;</br>
concept bool IndirectInvocable() {</br>
&nbsp;&nbsp;return <i>see below</i> ;</br>
}</del></br>
template &lt;class F, class I&gt;</br>
concept bool Indirect<ins>Unary</ins>Invocable<del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del> <i>see below</i> ;</br>
<del>}</del></br>
<del>template &lt;class F, class I1, class I2&gt;</br>
concept bool IndirectInvocable() {</br>
&nbsp;&nbsp;return <i>see below</i> ;</br>
}</del></br>
<del>template &lt;class F&gt;</br>
concept bool IndirectRegularInvocable() {</br>
&nbsp;&nbsp;return <i>see below</i> ;</br>
}</del></br>
template &lt;class F, class I&gt;</br>
concept bool IndirectRegular<ins>Unary</ins>Invocable<del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del> <i>see below</i> ;</br>
<del>}</del></br>
<del>template &lt;class F, class I1, class I2&gt;</br>
concept bool IndirectRegularInvocable() {</br>
&nbsp;&nbsp;return <i>see below</i> ;</br>
}</del></br>
template &lt;class F, class I&gt;</br>
concept bool Indirect<ins>Unary</ins>Predicate<del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del> <i>see below</i> ;</br>
<del>}</del></br>
<del>template &lt;class F, class I1, class I2&gt;</br>
concept bool IndirectPredicate() {</br>
&nbsp;&nbsp;return <i>see below</i> ;</br>
}</del></br>
</br>
[...]</br>
</br>
// 9.4.3, projected:</br>
template &lt;Readable I, IndirectRegular<ins>Unary</ins>Invocable&lt;I&gt; Proj&gt;</br>
struct projected;</br>
</br>
[...]</br>
</br>
// 9.7, predefined iterators and sentinels:</br>
// 9.7.1, reverse iterators:</br>
template &lt;BidirectionalIterator I&gt; class reverse_iterator;</br>
</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires EqualityComparable<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator==(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I1&gt;&amp; x,</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires EqualityComparable<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator!=(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I1&gt;&amp; x,</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&lt;(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I1&gt;&amp; x,</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&gt;(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I1&gt;&amp; x,</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&gt;=(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I1&gt;&amp; x,</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&lt;=(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I1&gt;&amp; x,</br>
&nbsp;&nbsp;&nbsp;&nbsp;const reverse_iterator&lt;I2&gt;&amp; y);</br>
</br>
[...]</br>
</br>
// 9.7.3, move iterators and sentinels:</br>
template &lt;InputIterator I&gt; class move_iterator;</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires EqualityComparable<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator==(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires EqualityComparable<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator!=(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&lt;(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&lt;=(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&gt;(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);</br>
template &lt;class I1, class I2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires StrictTotallyOrdered<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator&gt;=(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);</br>
</br>
[...]</br>
</br>
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;</br>
&nbsp;&nbsp;bool operator==(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);</br>
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;requires EqualityComparable<ins>With</ins>&lt;I1, I2&gt;<del>()</del></br>
&nbsp;&nbsp;bool operator==(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);</br>
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;</br>
&nbsp;&nbsp;bool operator!=(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);</br>
</tt></blockquote>
<p><ednote>[<i>Editorial note:</i> The resolution of <a href="https://github.com/ericniebler/stl2/issues/286">ericniebler/stl2#286</a> changes <code>indirect_result_of</code> to no longer use<br />
<code>IndirectInvocable</code>, so no change is necessary there. – <i>end note</i>]</ednote></p>
<p>Change section “Indirect callables” [indirectcallable.indirectinvocable] as follows:</p>
<blockquote><tt>
<del>template &lt;class F&gt;</br>
concept bool IndirectInvocable() {</br>
&nbsp;&nbsp;return CopyConstructible&lt;F&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;&gt;();</br>
}</del></br>
template &lt;class F, class I&gt;</br>
concept bool Indirect<ins>Unary</ins>Invocable<del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del> Readable&lt;I&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CopyConstructible&lt;F&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, value_type_t&lt;I&gt;&amp;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, reference_t&lt;I&gt;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;<del>()</del>;</br>
<del>}</del></br>
<del>template &lt;class F, class I1, class I2&gt;</br>
concept bool IndirectInvocable() {</br>
&nbsp;&nbsp;return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CopyConstructible&lt;F&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Invocable&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();</br>
}</br>
</br>
template &lt;class F&gt;</br>
concept bool IndirectRegularInvocable() {</br>
&nbsp;&nbsp;return CopyConstructible&lt;F&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;&gt;();</br>
}</del></br>
template &lt;class F, class I&gt;</br>
concept bool IndirectRegular<ins>Unary</ins>Invocable<del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del> Readable&lt;I&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CopyConstructible&lt;F&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, value_type_t&lt;I&gt;&amp;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, reference_t&lt;I&gt;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;<del>()</del>;</br>
<del>}</del></br>
<del>template &lt;class F, class I1, class I2&gt;</br>
concept bool IndirectRegularInvocable() {</br>
&nbsp;&nbsp;return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CopyConstructible&lt;F&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;RegularInvocable&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();</br>
}</del></br>
</br>
template &lt;class F, class I&gt;</br>
concept bool Indirect<ins>Unary</ins>Predicate<del>() {</del><ins> =</ins></br>
&nbsp;&nbsp;<del>return</del> Readable&lt;I&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CopyConstructible&lt;F&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, value_type_t&lt;I&gt;&amp;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, reference_t&lt;I&gt;&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;<del>()</del>;</br>
<del>}</del></br>
<del>template &lt;class F, class I1, class I2&gt;</br>
concept bool IndirectPredicate() {</br>
&nbsp;&nbsp;return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;CopyConstructible&lt;F&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();</br>
}</del></br>
</tt></blockquote>
<p>In section “Class template <code>projected</code>” ([projected]), change the occurrence of<br />
<code>IndirectRegularInvocable</code> to <code>IndirectRegularUnaryInvocable</code>.</p>
<p>In [commonalgoreq.general]/p2, change the note to read:</p>
<blockquote>
<p>[…] <code>equal_to&lt;&gt;</code> requires its arguments satisfy <tt>EqualityComparable<ins>With</ins></tt> (7.4.3), and<br />
<code>less&lt;&gt;</code> requires its arguments satisfy <tt>StrictTotallyOrdered<ins>With</ins></tt> (7.4.4). […]</p>
</blockquote>
<p>In section “Class template <code>reverse_iterator</code>” ([reverse.iterator]), in the synopsis and in definitions<br />
of the relational operators ([reverse.iter.op==] through [reverse.iter.op&lt;=]), change<br />
<code>EqualityComparable&lt;I1, I2&gt;()</code> to <code>EqualityComparableWith&lt;I1, I2&gt;</code>, and change<br />
<code>StrictTotallyOrdered&lt;I1, I2&gt;()</code> to <code>StrictTotallyOrderedWith&lt;I1, I2&gt;</code> as shown above in the<br />
<code>&lt;experimental/ranges/iterator&gt;</code> synopsis ([iterator.synopsis]).</p>
<p>In section “Class template <code>move_iterator</code>” ([move.iterator]), in the synopsis (p2) and in definitions<br />
of the relational operators ([[move.iter.op.comp]]), change <code>EqualityComparable&lt;I1, I2&gt;()</code> to<br />
<code>EqualityComparableWith&lt;I1, I2&gt;</code>, and change <code>StrictTotallyOrdered&lt;I1, I2&gt;()</code> to<br />
<code>StrictTotallyOrderedWith&lt;I1, I2&gt;</code> as shown above in the <code>&lt;experimental/ranges/iterator&gt;</code> synopsis<br />
([iterator.synopsis]).</p>
<p>In section “Class template <code>move_sentinel</code>” ([move.sentinel]), in the <code>move_if</code> example in para 2,<br />
change <code>IndirectPredicate</code> to <code>IndirectUnaryPredicate</code>.</p>
<p>In section “Class template <code>common_iterator</code>” ([common.iterator]), in the synopsis (p2) and in definitions<br />
of the relational operators ([[common.iter.op.comp]]), change <code>EqualityComparable&lt;I1, I2&gt;()</code> to<br />
<code>EqualityComparableWith&lt;I1, I2&gt;</code> as shown above in the <code>&lt;experimental/ranges/iterator&gt;</code> synopsis<br />
([iterator.synopsis]).</p>
<p>In section “Range requirements” ([ranges.requirements]), change all function-style concept definitions<br />
to variable-style concept definitions.</p>
<h2 id="section-algorithms-library-algorithms"><span class="header-section-number">6.4</span> Section “Algorithms library” [algorithms]</h2>
<p>In “Header <code>&lt;experimental/ranges/algorithm&gt;</code> synopsis” ([algorithms.general]/p2), make the following<br />
changes:</p>
<blockquote><tt>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool all_of(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool all_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool any_of(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool any_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool none_of(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool none_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Invocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;</br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;for_each(I first, S last, Fun f, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Invocable&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Fun&gt;</br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::fun(Fun)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;for_each(Rng&amp;&amp; rng, Fun f, Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;I find_if(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;safe_iterator_t&lt;Rng&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;find_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;safe_iterator_t&lt;Rng&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;find_if_not(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;difference_type_t&lt;I&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;count_if(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;difference_type_t&lt;iterator_t&lt;Rng&gt;&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;count_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;I, O&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(I), tag::out(O)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Writable&lt;I, const T&amp;&gt;<del>()</del></br>
&nbsp;&nbsp;I</br>
&nbsp;&nbsp;&nbsp;&nbsp;replace_if(I first, S last, Pred pred, const T&amp; new_value, Proj proj = Proj{});</br>
template &lt;ForwardRange Rng, class T, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Writable&lt;iterator_t&lt;Rng&gt;, const T&amp;&gt;<del>()</del></br>
&nbsp;&nbsp;safe_iterator_t&lt;Rng&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;replace_if(Rng&amp;&amp; rng, Pred pred, const T&amp; new_value, Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, OutputIterator&lt;const T&amp;&gt; O,</br>
&nbsp;&nbsp;&nbsp;&nbsp;class Proj = identity, Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;I, O&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(I), tag::out(O)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proj proj = Proj{});</br>
template &lt;InputRange Rng, class T, OutputIterator&lt;const T&amp;&gt; O, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;replace_copy_if(Rng&amp;&amp; rng, O result, Pred pred, const T&amp; new_value,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Permutable&lt;I&gt;<del>()</del></br>
&nbsp;&nbsp;I remove_if(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;ForwardRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;<del>()</del></br>
&nbsp;&nbsp;safe_iterator_t&lt;Rng&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;remove_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,</br>
&nbsp;&nbsp;&nbsp;&nbsp;class Proj = identity, Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;I, O&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(I), tag::out(O)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;remove_copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});</br>
</br>
[...]</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;InputRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;bool</br>
&nbsp;&nbsp;is_partitioned(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Permutable&lt;I&gt;<del>()</del></br>
&nbsp;&nbsp;I partition(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;ForwardRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;<del>()</del></br>
&nbsp;&nbsp;safe_iterator_t&lt;Rng&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Permutable&lt;I&gt;<del>()</del></br>
&nbsp;&nbsp;I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;BidirectionalRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;<del>()</del></br>
&nbsp;&nbsp;safe_iterator_t&lt;Rng&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;stable_partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O1, WeaklyIncrementable O2,</br>
&nbsp;&nbsp;&nbsp;&nbsp;class Proj = identity, Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;I, O1&gt;<del>()</del> &amp;&amp; IndirectlyCopyable&lt;I, O2&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_tuple&lt;tag::in(I), tag::out1(O1), tag::out2(O2)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proj proj = Proj{});</br>
template &lt;InputRange Rng, WeaklyIncrementable O1, WeaklyIncrementable O2,</br>
&nbsp;&nbsp;&nbsp;&nbsp;class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O1&gt;<del>()</del> &amp;&amp;</br>
&nbsp;&nbsp;&nbsp;&nbsp;IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O2&gt;<del>()</del></br>
&nbsp;&nbsp;tagged_tuple&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out1(O1), tag::out2(O2)&gt;</br>
&nbsp;&nbsp;&nbsp;&nbsp;partition_copy(Rng&amp;&amp; rng, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});</br>
</br>
template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;I partition_point(I first, S last, Pred pred, Proj proj = Proj{});</br>
template &lt;ForwardRange Rng, class Proj = identity,</br>
&nbsp;&nbsp;&nbsp;&nbsp;Indirect<ins>Unary</ins>Predicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;</br>
&nbsp;&nbsp;safe_iterator_t&lt;Rng&gt;</br>
&nbsp;&nbsp;partition_point(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});</br>
</tt></blockquote>
<p>In section “All of” ([alg.all_of]), change the signature of the <code>all_of</code> algorithm to match those<br />
shown in <code>&lt;experimental/ranges/algorithm&gt;</code> synopsis ([algorithms.general]/p2) above.</p>
<p>Likewise, do the same for the following algorithms:</p>
<ul>
<li><code>any_of</code> in section “Any of” ([alg.any_of])</li>
<li><code>none_of</code> in section “None of” ([alg.none_of])</li>
<li><code>for_each</code> in section “For each” ([alg.for_each])</li>
<li><code>find_if</code> in section “Find” ([alg.find])</li>
<li><code>find_if_not</code> in section “Find” ([alg.find])</li>
<li><code>count_if</code> in section “Count” ([alg.count])</li>
<li><code>copy_if</code> in section “Copy” ([alg.copy])</li>
<li><code>replace_if</code> in section “Replace” ([alg.replace])</li>
<li><code>replace_copy_if</code> in section “Replace” ([alg.replace])</li>
<li><code>remove_if</code> in section “Remove” ([alg.remove])</li>
<li><code>remove_copy_if</code> in section “Remove” ([alg.remove])</li>
<li><code>is_partitioned</code> in section “Partitions” ([alg.partitions])</li>
<li><code>partition</code> in section “Partitions” ([alg.partitions])</li>
<li><code>stable_partition</code> in section “Partitions” ([alg.partitions])</li>
<li><code>partition_copy</code> in section “Partitions” ([alg.partitions])</li>
<li><code>partition_point</code> in section “Partitions” ([alg.partitions])</li>
</ul>
<h1 id="acknowledgements"><span class="header-section-number">7</span> Acknowledgements</h1>
<p>I would like to thank Casey Carter for his review feedback.</p>
</body>
</html>
