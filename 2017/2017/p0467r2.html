<html>

<head>
<title>Iterator Concerns for Parallel Algorithms</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.</td>
  <td align="left">P0467R2</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2017-03-02</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">Programming Language C++</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Alisdair Meredith &lt;<a href="mailto:ameredith1@bloomberg.net">ameredith1@bloomberg.net</a>&gt;</td>
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">SG1, Library</td>
</tr>
</table>

<h1>Iterator Concerns for Parallel Algorithms</h1>

<h2><a name="0.0">Revision History</a></h2>

<h3><a name="0.1">Revision 0</a></h3>
<p>
Original version of the paper for the 2016 pre-Issaquah mailing.
</p>

<h3><a name="0.2">Revision 1</a></h3>
<p>
Following approval from SG1 at Issaquah, normative wording added for the 2016
post-Issaquah mailing.
</p>

<p>
(It seems the document was not forwarded in time for the post-meeting mailing,
and should make the pre-Kona mailing instead.  This draft does not reflect
changes to the draft since then - notably, all the parallel algorithm
declarations have been duplicated in the body of the specifictation, so each
edit should now be applied in two places.)
</p>

<h3><a name="0.3">Revision 2</a></h3>
<p>
Update following LWG review:
</p>

<p>
Note which NB comments this paper addresses.
</p>

<p>
Highlight the editors' note that there are implicit changes to the signatures
repeated for each function specification.
</p>

<p>
Remove redundant specification of functions covered under the editors' note.
</p>

<p>
Update <i>Complexity</i> clause of <tt>equal</tt> to reflect the change
of iterator type names.
</p>

<p>
Update <i>Requires</i> clause of <tt>unique_copy</tt> to reflect the change
of iterator type names.  Integrate Anthony Williams's note on performance hints.
</p>

<p>
Update <i>Requires</i> clause of <tt>is_partitioned</tt> to reflect the change
of iterator type names.  Integrate Anthony Williams's note on performance hints.
</p>

<p>
Update <i>Requires</i> clause of <tt>partition_copy</tt> to reflect the change
of iterator type names.  Integrate Anthony Williams's note on performance hints.
</p>

<p>
Update the <i>Effects</i> clause for parallel <tt>reduce</tt> to reflect the change
of iterator type names.
</p>

<p>
Update <i>Requires</i> clause of <tt>adjacent_difference</tt> to reflect the change
of iterator type names.  Integrate Anthony Williams's reformulation to better
specify a parallel implementation.
</p>


<h2>Table of Contents</h2>
<ol start="0">
<li><a href="p0467r2.html#0.0">Revision History</a></li>
  <ul>
  <li><a href="p0467r2.html#0.1">Revision 0</a></li>
  <li><a href="p0467r2.html#0.2">Revision 1</a></li>
  <li><a href="p0467r2.html#0.3">Revision 2</a></li>
  </ul>
<li><a href="p0467r2.html#1.0">Introduction</a></li>
<li><a href="p0467r2.html#2.0">Problems to be addressed</a></li>
  <ul>
  <li><a href="p0467r2.html#2.1">The Standard Algorithms Are Underspecified</a></li>
  <li><a href="p0467r2.html#2.2">Input Iterators Invalidate Too Frequently</a></li>
  <li><a href="p0467r2.html#2.3">Copying an Input Range Requires Memory, and Copy Semantics</a></li>
  <li><a href="p0467r2.html#2.4">Writing to an Output Iterator Implies a Serialization Stage</a></li>
  </ul>
<li><a href="p0467r2.html#3.0">Proposed Resolution</a></li>
  <ul>
  <li><a href="p0467r2.html#3.1">Which Algorithms Are Affected?</a></li>
  </ul>
<li><a href="p0467r2.html#4.0">Alternatives Considered</a></li>
  <ul>
  <li><a href="p0467r2.html#4.1">Do Nothing</a></li>
  <li><a href="p0467r2.html#4.1a">Add the Missing Parallel Overloads</a></li>
  <li><a href="p0467r2.html#4.2">Revise Requirements on all Algorithms</a></li>
  <li><a href="p0467r2.html#4.3">Blanket Wording Permitting Copies in Parallel Algorithms</a></li>
  </ul>
<li><a href="p0467r2.html#5.0">Implementation Experience</a></li>
   <ul>
   <li><a href="p0467r2.html#5.1">Force Serial Execution</a></li>
   <li><a href="p0467r2.html#5.2">Copy Elements into Subranges</a></li>
   <li><a href="p0467r2.html#5.3">Ignore the Issue (bug?)</a></li>
   </ul>
<li><a href="p0467r2.html#6.0">Formal Wording</a></li>
<li><a href="p0467r2.html#7.0">Acknowledgements</a></li>
<li><a href="p0467r2.html#8.0">References</a></li>
</ol>


<h2><a name="1.0">1. Introduction</a></h2>
<p>
This paper addresses NB comments US-156, 162.
</p>

<p>
The C++17 CD,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4604">N4604</a>,
provides additional overloads for most of the algorithms in the <tt>&lt;algorithm&gt;</tt>
and <tt>&lt;numeric&gt;</tt> headers, generally by repeating the declaration of the
non-parallel form with a leading parallel-policy parameter.  It is not clear that
sufficient thought was given to the iterator category when providing such additions,
and this paper looks into some of the resulting issues.  As there are several reasonable
directions to proceed from here, formal wording will not be provided until the first
revision of this paper, following LEWG review.
</p>

<h2><a name="2.0">2. Problems to be addressed</a></h2>
<p>
The main problem is that the parallel algorithms are underspecified.  This paper
claims that the poor specification naturally leads to those same algorithms
being under-constrained, and suggests that different constraints may be
appropriate for the serial and parallel forms of the same algorithm.
</p>

<h3><a name="2.1">2.1 The Standard Algorithms Are Underspecified</a></h3>
<p>
To start, we must realize that many of the existing standard algorithms are
under-constrained, at least when we want to extend their specification to
cover the otherwise-unspecified parallel case.
</p>

<p>
Good examples of algorithms that have had their specification honed over
several standard revisions are <tt>adjecent_difference</tt> and
<tt>partial_sum</tt> in the <tt>&lt;numeric&gt;</tt> header.  However, most
algorithms are more like <tt>copy</tt>, and have poorly stated requirements
that must be implicitly reverse-engineered from their <i>Effects:</i> clause.
</p>

<h3><a name="2.2">2.2 Input Iterators Invalidate Too Frequently</a></h3>
<p>
The basic problem with an Input Iterator is that it does not provide the
multi-pass guarantee.  This makes it impossible for a parallel algorithm to
work with different subsequences at the same time, as it is not possible to
advance the iterator to refer to such subsequences without invalidating the
iterators used by other threads.
</p>

<h3><a name="2.3">2.3 Copying an Input Range Requires Memory, and Copy Semantics</a></h3>
<p>
One workaround for the lack of a multi-pass guarantee is to make copies of
subsets of the input range, and dispatch work on those subsets.  If this is
the intended semantic, which is the understanding of the author, then it would
be helpful to call this out in the parallel algorithms wording at the front of
clause 25, so that future discussion in the Library Working Group dealing with
parallel algorithms is informed of a deliberate design decision, calling out
the runtime trade-offs and overheads accepted for the parallel forms.  However,
permission to create copies is not sufficient, as the algorithms do not
currently require those elements to be <tt>CopyConstructible</tt>.  For example,
it is expected that the <tt>move</tt> algorithm work with <tt>move_iterator</tt>s,
possibly over sequences of <tt>unique_ptr</tt>s.
</p>

<h3><a name="2.4">2.4 Writing to an Output Iterator Implies a Serialization Stage</a></h3>
<p>
Algorithms that write to Output Iterators do not currently require
<tt>CopyConstrutible</tt> elements; for example, an <tt>ostream_iterator</tt>
requires just a reference in order to write the result to a stream.
</p>

<p>
Consider the following example:
</p>
<pre>
template &lt;typename T&gt;
void WriteVector(std::vector&lt;T&gt; const & v, std::ostream & os)  {
   copy(v.begin(), v.end(), std::ostream_iterator(os, ", "));
}
</pre>

<p>
Despite the name of the algorithm being <tt>copy</tt>, we do not expect
to make any actual copies executing with these iterators.  For a clearer
example, consider the following:
</p>

<pre>
template &lt;typename T&gt;
void WriteVector(std::vector&lt;std::unique_ptr&lt;T&gt;&gt; const & v, std::ostream & os)  {
   std::transform(v.begin(), v.end(),
                  std::ostream_iterator(os, ", "),
                  [](auto const &ptr){ return ptr.get(); });
}
</pre>
<p>
In this case, we cannot copy elements from the source range, as
<tt>unique_ptr</tt> does not have a usable copy constructor, but there is
still an expectation that the algorithm should compile and run.
</p>

<p>
An output sequence supplied through a simple output iterator, such as the
aforementioned <tt>ostream_iterator</tt>, does not offer the multi-pass
guarantee; so again, output must be collected and output serially.  It would
be very surprising for the <tt>copy</tt> algorithms to write a permuted
sequence, or for <tt>merge</tt> to produce a non-sorted output.
</p>


<h2><a name="3.0">3. Proposed Resolution: Promote All Iterators to At Least Forward Iterators</a></h2>
<p>
The simplest short-term fix is to require that no iterator for a parallel
algorithm has a category less capable than a Forward Iterator.  This change
guarantees that all iterators in parallel algorithms return a true reference,
i.e., no copies are ever required, and the multi-pass guarantee allows the
implementation to <tt>advance</tt> the destination (output) iterators without
requiring additional storage to queue results for serialization.
</p>

<p>
This solution is recommended as it preserves the ability to weaken the constraints
on iterators in a future library, once the implementation requirements are clear.
It also grants time to the Library Working Group to properly document the constraints
on the existing non-parallel algorithms.
</p>

<h3><a name="3.1">3.1 Which Algorithms Are Affected?</a></h3>
<p>
Roughly 40 parallel algorithms use either input or output iterators in their
interface, most of which use both.
</p>

<h4>Parallel Algorithms with Input Iterators and an Implicit Specification</h4>
<p>
The following algorithms all consume input ranges, may write to a simple output
iterator, and make no clear requirement that the element type be copyable.
Their specification is entirely implicit, not appearing beyond their corresponding
header synopsis.
</p>
<pre>
	all_of
	any_of
	none_of
	find
	find_if
	find_if_not
	find_first_of
	count
	count_if
	mismatch
	equal
	copy_n
	copy_if
	transform
	replace_copy
	replace_copy_if
	remove_copy
	remove_copy_if
	partial_sort_copy
	merge
	includes
	set_union
	set_intersection
	set_difference
	set_symmetric_difference
	lexicographical_compare
	reduce
	transform_reduce
	inner_product
	exclusive_scan
	inclusive_scan
	transform_exclusive_scan
	transform_inclusive_scan
</pre>

<h4>Parallel Algorithms with Input Iterators and an Explicit Specification</h4>
<p>
The following algorithms all consume input ranges, may write to a simple output
iterator, and do not make a clear requirement that the element type be copyable.
They do provide a distinct specification for the parallel form having a subtly
different interface, such as<tt>for_each</tt>, or slightly different requirements,
such as <tt>copy</tt>.
</p>
<pre>
	for_each
	for_each_n
	copy
	move
</pre>

<h4>Parallel Algorithms Writing Through Output Iterators</h4>
<p>
The following algorithms not already mentioned as consuming an input sequence
require a serial (potentially copying) stage to write through an output iterator.
</p>
<pre>
	fill_n
	generate_n
	reverse_copy
	rotate_copy
</pre>

<h4>Potentially Well-specified Algorithms</h4>
<p>
The following algorithms over input ranges have implicitly specified parallel
overloads, but may have a strong enough serial specification that the requirements
are sufficient to allow for some parallel execution.  However, even in these cases,
careful review will likely suggest a minimal tweaking for clear support.
<pre>
	unique_copy
	partition_copy
	partial_sum
	adjacent_difference
</pre>

<h2><a name="4.0">4. Alternatives Solutions</a></h2>
<p>
Several other resolutions were considered preparing this paper, and should be
considered alongside the recommended resolution above.
</p>

<h3><a name="4.1">4.1 Do Nothing</a></h3>
<p>
There is an intent that it should be very simple to turn serial C++ code into
parallel code by simply adding a parallel-policy argument to the call of an
algorithm.  This becomes more troublesome if the user has to consider the
potential for different requirements on the serial and parallel forms.
</p>
<p>
In particular, the standard gives no mandate that even those algorithms called
with iterators that reveal embarrassing potential for parallelism should actually
distribute the work, not least because the standard does not exclude environments
that support only a single thread of execution.  From this perspective, the
parallel execution policies are no more than a hint to the library, like the
<tt>inline</tt> keyword is a hint to the compiler.  They allow for the relaxation
of certain constraints (such as the ODR in the case of <tt>inline</tt>), subject to
further constraints (e.g., identical definitions) that will retain proper behavior.
</p>
<p>
In this case, the promise made, beyond being a hint to the library that concurrent
execution is desired, is the guarantee that passed function objects and iterators
do not introduce data races when executed on different (unsynchronized) threads.
This guarantee is a constraint on the user of the algorithm, rather than on the
library implementation.
</p>

<p>
The author rejects this direction, as making a false offer of parallelism
where serial implementations are effectively mandated is even more misleading.
It would be better for the caller to confront the issues with their data
structures that inhibit effective parallelism.  Also, to some extent this risk
is already assumed in the several algorithms that already have a different
interface or contract for the serial and parallel forms, such as <tt>for_each</tt>
and <tt>copy</tt>.
</p>
<p>
A further concern with this approach is that it has not been applied consistently
through the library, as there are several algorithms with no parallel overloads,
which could easily be given parallel overloads on the assumption that all known
implementations would be sequential, but open to QoI enhancement in the future.
</p>

<h3><a name="4.1a">4.1a Add the Missing Parallel Overloads</a></h3>
<p>
This is an extension of the <i>do nothing</i> solution, which addresses the
concern that the abstraction of parallel policy as a hint does not work as
long as there are some algorithms lacking the parallel policy overloads.
Therefore, the policy parameter would be added to the remaining algorithms
called out as <i>not</i> supported in the Parallelism Extensions TS.
</p>

<h3><a name="4.2">4.2 Revise Requirements on all Algorithms</a></h3>
<p>
This resolution would likely require more effort from the Library Working Group
than is available within the ballot resolution period for C++17.  It would
involve first correctly specifying all of the existing serial algorithms with a
level of detail that is missing today.  Once those specifications are complete,
the parallel form of those same algorithms can be reviewed, and specified with
additional constraints where necessary, such as the ability to take copies in
order to create sub-tasks.
</p>
<p>
This resolution is the preferred long-term goal of the paper author, but seems
beyond the scope of what can be achieved in two standard meetings, while
addressing all of the other outstanding ballot comments.  One possible result
of this approach might be weaker requirements and a mandate to avoid undue
serialization in the event of algorithms being called with Forward Iterators
(or better) rather than simple Input or Output Iterators.  At the least, it is
an opportunity for the standard to acknowledge the greater capabilities that
would come from such iterators.
</p>

<h3><a name="4.3">4.3 Blanket Wording Permitting Copies in Parallel Algorithms</a></h3>
<p>
A half-way house would be to add additional blanket wording to the parallel
algorithms front-matter, that says that any algorithm with a parallel policy
overload taking input or output iterators as parameters, requires that the
element type for such iterators be <tt>CopyConstructible</tt>.
</p>

<p>
While this direction would the progress from the status-quo, it suffers from
still being an awkward specification for readers of the standard, who must be
aware that there are now requirements on algorithms documented in several other
places than the algorithm itself is specified, especially for parallel forms
that are not otherwise specified at all.  This could be partially alleviated
by applying a blanket edit to actually specify those algorithms below the
serial form, adding the <tt>CopyConstructible</tt> constraints in each case.
Such a solution would still suffer from interactions with the under-specification
of the serial forms though.
</p>
<p>
A trickier problem is that Output Iterators do not actually have an element
type, so it is not clear what <tt>CopyConstructible</tt> constraint should
apply to.
</p>

<h2><a name="5.0">5. Implementation Experience</a></h2>
<p>
<a href="http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2016/p0024r1">P0024r1</a>
provide links to existing practice prior to standardization.  How do these
implementations handle the problems highlighted in this paper?
</p>

<h3><a name="5.1">5.1 Force Serial Execution</a></h3>
<p>
The Microsoft implementation at CodePlex simply forces all calls with input
iterators into the sequential policy overloads - I did not find special handling
for output iterators, but could easily have missed it in the time I had for this
review.
</p>

<h3><a name="5.2">5.2 Copy Elements into Subranges</a></h3>
<p>
The Khronos Sycl Parallel STL appears to try to copy elements into subranges,
and performs parallel execution with the sub-ranges.  The additional requirements
for copyable elements do not appear to be documented, and as far as I can tell,
calling with an incompatible element type would lead to a failure instantiating
the template, deep in the implementation details.  Libraries using this approach
are best place to provide insights into the missing requirements, if that is the
preferred direction.
</p>

<h3><a name="5.3">5.3 Ignore the Issue (bug?)</a></h3>
<p>
Other libraries seemed to simply ignore the issue, working with potentially
invalidated input (or output) iterators and risking undefined behavior.  i.e.,
they have bugs, and lend no insight for a likely solution.
</p>
<p>
I am not calling out which of the unreferenced libraries fall into the categories
above, as I did not have time for a detailed review, but these three categories
appear to cover the range of the behavior I encountered.
</p>


<h2><a name="6.0">6. Formal Wording</a></h2>

<p>
Make the following changes to the sypopses for both the
<tt>&lt;algorithm&gt;</tt> and <tt>&lt;numeric&gt;</tt>
headers.  Diff-marks are as compared to
The C++17 CD,
<a href="n4640">N4640</a>.
</p>
<blockquote class="note">
Editor's note: Matching changes should be made to the corresponding function
specifications, but detailed changes are provided only where the text of the
formal specification must also be changed.  For the majority of cases, as only
the iterator type names are changed, and not the function parameter names, the
current specification needs no further change.
</blockquote>

<p>
Note that we do not explicitly add a requriment that a <tt>ForwardIterator</tt>
be a <i>mutable</i> <tt>ForwardIterator</tt> where we upgrade from an
<tt>OutputIterator</tt> as there is already blanket wording covering that case
in [algorithms.requirements]p4.
</p>

<blockquote>

<h4>Header &lt;algorithm&gt;</h4>
<h5>synopsis</h5>
<blockquote><pre>
#include &lt;initializer_list&gt;

namespace std {
  <i>// 25.5, non-modifying sequence operations</i>
  template &lt;class InputIterator, class Predicate&gt;
    bool all_of(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
    bool all_of(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, Predicate pred);
  template &lt;class InputIterator, class Predicate&gt;
    bool any_of(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
    bool any_of(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, Predicate pred);
  template &lt;class InputIterator, class Predicate&gt;
    bool none_of(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
    bool none_of(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                 <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, Predicate pred);

  template&lt;class InputIterator, class Function&gt;
    Function for_each(InputIterator first, InputIterator last, Function f);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Function&gt;
     void for_each(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                   <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, Function f);
  template&lt;class InputIterator, class Size, class Function&gt;
    InputIterator for_each_n(InputIterator first, Size n, Function f);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Size, class Function&gt;
    <del>Input</del><ins>Forward</ins>Iterator for_each_n(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                             <del>Input</del><ins>Forward</ins>Iterator first, Size n, Function f);

  template&lt;class InputIterator, class T&gt;
    InputIterator find(InputIterator first, InputIterator last,
                       const T&amp; value);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class T&gt;
    <del>Input</del><ins>Forward</ins>Iterator find(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                       <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
                       const T&amp; value);
  template&lt;class InputIterator, class Predicate&gt;
    InputIterator find_if(InputIterator first, InputIterator last,
                          Predicate pred);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
    <del>Input</del><ins>Forward</ins>Iterator find_if(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                          <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
                          Predicate pred);
  template&lt;class InputIterator, class Predicate&gt;
    InputIterator find_if_not(InputIterator first, InputIterator last,
                              Predicate pred);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
    <del>Input</del><ins>Forward</ins>Iterator find_if_not(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                              <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
                              Predicate pred);
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1
      find_end(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1
      find_end(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  template&lt;class InputIterator, class ForwardIterator&gt;
    InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2);
  template&lt;class InputIterator, class ForwardIterator, class BinaryPredicate&gt;
    InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class ForwardIterator<ins>2</ins>&gt;
    <del>InputIterator</del><ins>ForwardIterator1</ins> find_first_of(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                <del>InputIterator</del><ins>ForwardIterator1</ins> first1, <del>InputIterator</del><ins>ForwardIterator1</ins> last1,
                                ForwardIterator<ins>2</ins> first2, ForwardIterator<ins>2</ins> last2);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>,
             class ForwardIterator<ins>2</ins>, class BinaryPredicate&gt;
    <del>InputIterator</del><ins>ForwardIterator1</ins>
        find_first_of(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                      <del>InputIterator</del><ins>ForwardIterator1</ins> first1, <del>InputIterator</del><ins>ForwardIterator1</ins> last1,
                      ForwardIterator<ins>2</ins> first2, ForwardIterator<ins>2</ins> last2,
                      BinaryPredicate pred);

  template&lt;class ForwardIterator&gt;
    ForwardIterator adjacent_find(ForwardIterator first,
                                  ForwardIterator last);
  template&lt;class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator adjacent_find(ForwardIterator first,
                                  ForwardIterator last,
                                  BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator adjacent_find(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  ForwardIterator first,
                                  ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator adjacent_find(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  ForwardIterator first,
                                  ForwardIterator last,
                                  BinaryPredicate pred);

  template&lt;class InputIterator, class T&gt;
    typename iterator_traits&lt;InputIterator&gt;::difference_type
      count(InputIterator first, InputIterator last, const T&amp; value);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class T&gt;
    typename iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::difference_type
      count(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
            <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, const T&amp; value);
  template&lt;class InputIterator, class Predicate&gt;
    typename iterator_traits&lt;InputIterator&gt;::difference_type
      count_if(InputIterator first, InputIterator last, Predicate pred);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
    typename iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::difference_type
      count_if(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, Predicate pred);

  template&lt;class InputIterator1, class InputIterator2&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template&lt;class InputIterator1, class InputIterator2&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
    pair&lt;<del>Input</del><ins>Forward</ins>Iterator1, <del>Input</del><ins>Forward</ins>Iterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class BinaryPredicate&gt;
    pair&lt;<del>Input</del><ins>Forward</ins>Iterator1, <del>Input</del><ins>Forward</ins>Iterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
    pair&lt;<del>Input</del><ins>Forward</ins>Iterator1, <del>Input</del><ins>Forward</ins>Iterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class BinaryPredicate&gt;
    pair&lt;<del>Input</del><ins>Forward</ins>Iterator1, <del>Input</del><ins>Forward</ins>Iterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
               BinaryPredicate pred);

  template&lt;class InputIterator1, class InputIterator2&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template&lt;class InputIterator1, class InputIterator2&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class BinaryPredicate&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class BinaryPredicate&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
               <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
               <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
               BinaryPredicate pred);

  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2);
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2, BinaryPredicate pred);
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2, ForwardIterator2 last2,
                        BinaryPredicate pred);

  <i>// 25.5.13, search</i>
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1 search(
    ForwardIterator1 first1, ForwardIterator1 last1,
    ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1 search(
      ForwardIterator1 first1, ForwardIterator1 last1,
      ForwardIterator2 first2, ForwardIterator2 last2,
      BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1 search(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      ForwardIterator1 first1, ForwardIterator1 last1,
      ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    ForwardIterator1 search(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2,
                            BinaryPredicate pred);
  template&lt;class ForwardIterator, class Size, class T&gt;
    ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value);
  template&lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;
    ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value,
                             BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class T&gt;
    ForwardIterator search_n(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                             ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class T,
           class BinaryPredicate&gt;
    ForwardIterator search_n(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i> 
                             ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value,
                             BinaryPredicate pred);

  template &lt;class ForwardIterator, class Searcher&gt;
    ForwardIterator search(ForwardIterator first, ForwardIterator last,
                           const Searcher &amp;searcher);

  <i>// 25.6, modifying sequence operations</i>
  <i>// 25.6.1, copy</i>
  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator copy(InputIterator first, InputIterator last,
                        OutputIterator result);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> copy(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                        <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                        <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
  template&lt;class InputIterator, class Size, class OutputIterator&gt;
    OutputIterator copy_n(InputIterator first, Size n,
                          OutputIterator result);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class Size,
           class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> copy_n(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                          <del>InputIterator</del><ins>ForwardIterator1</ins> first, Size n,
                          <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
  template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
    OutputIterator copy_if(InputIterator first, InputIterator last,
                           OutputIterator result, Predicate pred);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class Predicate&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> copy_if(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                           <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                           <del>OutputIterator</del><ins>ForwardIterator2</ins> result, Predicate pred);
  template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
    BidirectionalIterator2 copy_backward(
      BidirectionalIterator1 first, BidirectionalIterator1 last,
      BidirectionalIterator2 result);

  <i>// 25.6.2, move:</i>
  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator move(InputIterator first, InputIterator last,
                        OutputIterator result);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>,
           class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
  <del>OutputIterator</del><ins>ForwardIterator2</ins> move(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                      <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                      <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
  template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
    BidirectionalIterator2 move_backward(
      BidirectionalIterator1 first, BidirectionalIterator1 last,
      BidirectionalIterator2 result);

  <i>// 25.6.3, swap</i>
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 swap_ranges(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                 ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

  template&lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
    OutputIterator transform(InputIterator first, InputIterator last,
                             OutputIterator result, UnaryOperation op);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation&gt;
    OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, OutputIterator result,
                             BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class UnaryOperation&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> transform(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                             <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                             <del>OutputIterator</del><ins>ForwardIterator2</ins> result, UnaryOperation op);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator, class BinaryOperation&gt;
    <del>Output</del><ins>Forward</ins>Iterator transform(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                             <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                             <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Output</del><ins>Forward</ins>Iterator result,
                             BinaryOperation binary_op);

  template&lt;class ForwardIterator, class T&gt;
    void replace(ForwardIterator first, ForwardIterator last,
                 const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    void replace(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                 ForwardIterator first, ForwardIterator last,
                 const T&amp; old_value, const T&amp; new_value);
  template&lt;class ForwardIterator, class Predicate, class T&gt;
    void replace_if(ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate, class T&gt;
    void replace_if(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T&amp; new_value);
  template&lt;class InputIterator, class OutputIterator, class T&gt;
    OutputIterator replace_copy(InputIterator first, InputIterator last,
                                OutputIterator result,
                                const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>, class T&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> replace_copy(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                const T&amp; old_value, const T&amp; new_value);
  template&lt;class InputIterator, class OutputIterator, class Predicate, class T&gt;
     OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                   OutputIterator result,
                                   Predicate pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class Predicate, class T&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> replace_copy_if(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                   <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                   <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                   Predicate pred, const T&amp; new_value);

  template&lt;class ForwardIterator, class T&gt;
    void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIterator,
           class T&gt;
    void fill(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
              ForwardIterator first, ForwardIterator last, const T&amp; value);
  template&lt;class OutputIterator, class Size, class T&gt;
    OutputIterator fill_n(OutputIterator first, Size n, const T&amp; value);
  template&lt;class ExecutionPolicy, class <del>Output</del><ins>Forward</ins>Iterator,
           class Size, class T&gt;
    <del>Output</del><ins>Forward</ins>Iterator fill_n(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                          <del>Output</del><ins>Forward</ins>Iterator first, Size n, const T&amp; value);

  template&lt;class ForwardIterator, class Generator&gt;
    void generate(ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Generator&gt;
    void generate(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                  ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template&lt;class OutputIterator, class Size, class Generator&gt;
    OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
  template&lt;class ExecutionPolicy, class <del>Output</del><ins>Forward</ins>Iterator, class Size, class Generator&gt;
    <del>Output</del><ins>Forward</ins>Iterator generate_n(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                              <del>Output</del><ins>Forward</ins>Iterator first, Size n, Generator gen);

  template&lt;class ForwardIterator, class T&gt;
    ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                           const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    ForwardIterator remove(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                           ForwardIterator first, ForwardIterator last,
                           const T&amp; value);
  template&lt;class ForwardIterator, class Predicate&gt;
    ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                              Predicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator remove_if(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);
  template&lt;class InputIterator, class OutputIterator, class T&gt;
    OutputIterator remove_copy(InputIterator first, InputIterator last,
                               OutputIterator result, const T&amp; value);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class T&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> remove_copy(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                               <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                               <del>OutputIterator</del><ins>ForwardIterator2</ins> result, const T&amp; value);
  template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
    OutputIterator remove_copy_if(InputIterator first, InputIterator last,
                                  OutputIterator result, Predicate pred);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class Predicate&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> remove_copy_if(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                  <del>OutputIterator</del><ins>ForwardIterator2</ins> result, Predicate pred);

  template&lt;class ForwardIterator&gt;
    ForwardIterator unique(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator unique(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                           ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator unique(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);
  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator unique_copy(InputIterator first, InputIterator last,
                               OutputIterator result);
  template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
    OutputIterator unique_copy(InputIterator first, InputIterator last,
                               OutputIterator result, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> unique_copy(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                               <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                               <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class BinaryPredicate&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> unique_copy(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                               <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                               <del>OutputIterator</del><ins>ForwardIterator2</ins> result, BinaryPredicate pred);

  template&lt;class BidirectionalIterator&gt;
    void reverse(BidirectionalIterator first, BidirectionalIterator last);
  template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
    void reverse(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                 BidirectionalIterator first, BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class OutputIterator&gt;
    OutputIterator reverse_copy(BidirectionalIterator first,
                                BidirectionalIterator last,
                                OutputIterator result);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class <del>Output</del><ins>Forward</ins>Iterator&gt;
    <del>Output</del><ins>Forward</ins>Iterator reverse_copy(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                BidirectionalIterator first,
                                BidirectionalIterator last,
                                <del>Output</del><ins>Forward</ins>Iterator result);

  template&lt;class ForwardIterator&gt;
    ForwardIterator rotate(ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator rotate(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                           ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
  template&lt;class ForwardIterator, class OutputIterator&gt;
    OutputIterator rotate_copy(
      ForwardIterator first, ForwardIterator middle,
      ForwardIterator last, OutputIterator result);
  template&lt;class ExecutionPolicy, class ForwardIterator<ins>1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> rotate_copy(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      ForwardIterator<ins>1</ins> first, ForwardIterator<ins>1</ins> middle,
      ForwardIterator<ins>1</ins> last, <del>OutputIterator</del><ins>ForwardIterator2</ins> result);

  <i>// 25.6.12, sample</i>
  template&lt;class PopulationIterator, class SampleIterator,
           class Distance, class UniformRandomBitGenerator&gt;
    SampleIterator sample(PopulationIterator first, PopulationIterator last,
                          SampleIterator out, Distance n,
                          UniformRandomBitGenerator&amp;&amp; g);

  <i>// 25.6.13, shuffle</i>
  template&lt;class RandomAccessIterator, class UniformRandomBitGenerator&gt;
    void shuffle(RandomAccessIterator first,
                 RandomAccessIterator last,
                 UniformRandomBitGenerator&amp;&amp; g);

  <i>// 25.6.14, partitions</i>
  template &lt;class InputIterator, class Predicate&gt;
    bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
    bool is_partitioned(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                        <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, Predicate pred);

  template&lt;class ForwardIterator, class Predicate&gt;
    ForwardIterator partition(ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator partition(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                              ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
  template&lt;class BidirectionalIterator, class Predicate&gt;
    BidirectionalIterator stable_partition(BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class Predicate&gt;
    BidirectionalIterator stable_partition(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                           BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template &lt;class InputIterator, class OutputIterator1,
            class OutputIterator2, class Predicate&gt;
    pair&lt;OutputIterator1, OutputIterator2&gt;
    partition_copy(InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false,
                   Predicate pred);
  template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class <del>Output</del><ins>Forward</ins>Iterator1,
            class <del>Output</del><ins>Forward</ins>Iterator2, class Predicate&gt;
    pair&lt;<del>Output</del><ins>Forward</ins>Iterator1, <del>Output</del><ins>Forward</ins>Iterator2&gt;
    partition_copy(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                   <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
                   <del>Output</del><ins>Forward</ins>Iterator1 out_true, <del>Output</del><ins>Forward</ins>Iterator2 out_false,
                   Predicate pred);
  template&lt;class ForwardIterator, class Predicate&gt;
    ForwardIterator partition_point(ForwardIterator first,
                                    ForwardIterator last,
                                    Predicate pred);

  <i>// 25.7, sorting and related operations</i>
  <i>// 25.7.1, sorting</i>
  template&lt;class RandomAccessIterator&gt;
    void sort(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void sort(RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void sort(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
              RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void sort(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
              RandomAccessIterator first, RandomAccessIterator last, Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                     RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
  template&lt;class InputIterator, class RandomAccessIterator&gt;
    RandomAccessIterator partial_sort_copy(
      InputIterator first, InputIterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last);
  template&lt;class InputIterator, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator partial_sort_copy(
      InputIterator first, InputIterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last,
      Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class RandomAccessIterator&gt;
    RandomAccessIterator partial_sort_copy(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator partial_sort_copy(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last,
      Compare comp);
  template&lt;class ForwardIterator&gt;
    bool is_sorted(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    bool is_sorted(ForwardIterator first, ForwardIterator last,
                   Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                   ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                   ForwardIterator first, ForwardIterator last,
                   Compare comp);
  template&lt;class ForwardIterator&gt;
    ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last,
                                    Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator is_sorted_until(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                    ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator is_sorted_until(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                    ForwardIterator first, ForwardIterator last,
                                    Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);

  <i>// 25.7.3, binary search</i>
  template&lt;class ForwardIterator, class T&gt;
    ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value, Compare comp);

  template&lt;class ForwardIterator, class T&gt;
    ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value, Compare comp);

  template&lt;class ForwardIterator, class T&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T&amp; value, Compare comp);

  template&lt;class ForwardIterator, class T&gt;
    bool binary_search(ForwardIterator first, ForwardIterator last,
                       const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    bool binary_search(ForwardIterator first, ForwardIterator last,
                       const T&amp; value, Compare comp);

  <i>// 25.7.4, merge</i>
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator,
           class Compare&gt;
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator&gt;
    <del>Output</del><ins>Forward</ins>Iterator merge(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                         <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                         <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
                         <del>Output</del><ins>Forward</ins>Iterator result);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator, class Compare&gt;
    <del>Output</del><ins>Forward</ins>Iterator merge(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                         <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                         <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
                         <del>Output</del><ins>Forward</ins>Iterator result, Compare comp);

  template&lt;class BidirectionalIterator&gt;
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class Compare&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);

  <i>// 25.7.5, set operations</i>
  template&lt;class InputIterator1, class InputIterator2&gt;
    bool includes(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
    bool includes(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2, Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                  <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                  <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2, class Compare&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                  <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                  <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_union(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                             <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                             <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
                             <del>Output</del><ins>Forward</ins>Iterator result);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator, class Compare&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_union(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                             <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                             <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
                             <del>Output</del><ins>Forward</ins>Iterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_intersection(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_intersection(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_intersection(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
      <del>Output</del><ins>Forward</ins>Iterator result);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator, class Compare&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_intersection(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
      <del>Output</del><ins>Forward</ins>Iterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_difference(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
      <del>Output</del><ins>Forward</ins>Iterator result);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator, class Compare&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_difference(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
      <del>Output</del><ins>Forward</ins>Iterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_symmetric_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_symmetric_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_symmetric_difference(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
      <del>Output</del><ins>Forward</ins>Iterator result);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
           class <del>Output</del><ins>Forward</ins>Iterator, class Compare&gt;
    <del>Output</del><ins>Forward</ins>Iterator set_symmetric_difference(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
      <del>Output</del><ins>Forward</ins>Iterator result, Compare comp);

  <i>// 25.7.6, heap operations</i>
  template&lt;class RandomAccessIterator&gt;
    void push_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void make_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template&lt;class RandomAccessIterator&gt;
    bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    bool is_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                 RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                 RandomAccessIterator first, RandomAccessIterator last, Compare comp);
  template&lt;class RandomAccessIterator&gt;
    RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                                       Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    RandomAccessIterator is_heap_until(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                       RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator is_heap_until(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                       RandomAccessIterator first, RandomAccessIterator last,
                                       Compare comp);

  <i>// 25.7.7, minimum and maximum</i>
  template&lt;class T&gt; constexpr const T&amp; min(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T min(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T min(initializer_list&lt;T&gt; t, Compare comp);

  template&lt;class T&gt; constexpr const T&amp; max(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T max(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T max(initializer_list&lt;T&gt; t, Compare comp);

  template&lt;class T&gt; constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);

  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator min_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator min_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);

  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator max_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator max_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);

  template&lt;class ForwardIterator&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                     ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                     ForwardIterator first, ForwardIterator last, Compare comp);

  <i>// 25.7.8, bounded value</i>
  template&lt;class T&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Compare comp);

  <i>// 25.7.9, lexicographical comparison</i>
  template&lt;class InputIterator1, class InputIterator2&gt;
    bool lexicographical_compare(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
    bool lexicographical_compare(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      Compare comp);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
    bool lexicographical_compare(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2, class Compare&gt;
    bool lexicographical_compare(
      ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
      <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
      <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
      Compare comp);

  <i>// 25.7.10, permutations</i>
  template&lt;class BidirectionalIterator&gt;
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp);
  template&lt;class BidirectionalIterator&gt;
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp);
}
</pre></blockquote>


<h4>25.5.11 Equal [alg.equal]</h4>
<blockquote><pre>
template&lt;class InputIterator1, class InputIterator2&gt;
  bool equal(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2);
template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
  bool equal(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, BinaryPredicate pred);
template&lt;class InputIterator1, class InputIterator2&gt;
  bool equal(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2);
template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
  bool equal(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2,
             BinaryPredicate pred);
template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
  bool equal(ExecutionPolicy&amp;&amp; exec,
             <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
             <del>Input</del><ins>Forward</ins>Iterator2 first2);
template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
         class BinaryPredicate&gt;
  bool equal(ExecutionPolicy&amp;&amp; exec,
             <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
             <del>Input</del><ins>Forward</ins>Iterator2 first2, BinaryPredicate pred);
template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2&gt;
  bool equal(ExecutionPolicy&amp;&amp; exec,
             <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
             <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2);
template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
         class BinaryPredicate&gt;
  bool equal(ExecutionPolicy&amp;&amp; exec,
             <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
             <del>Input</del><ins>Forward</ins>Iterator2 first2, <del>Input</del><ins>Forward</ins>Iterator2 last2,
             BinaryPredicate pred);
</pre></blockquote>

<ol>
<li>
<i>Remarks:</i> If <tt>last2</tt> was not given in the argument list, it denotes <tt>first2 + (last1 - first1)</tt> below.
</li>
<li>
<i>Returns:</i> If <tt>last1 - first1 != last2 - first2</tt>, return <tt>false</tt>. Otherwise return <tt>true</tt> if for every iterator <tt>i</tt> in the range <tt>[first1, last1)</tt> the following corresponding conditions hold: <tt>*i == *(first2 + (i - first1))</tt>, <tt>pred(*i, *(first2 + (i - first1))) != false</tt>. Otherwise, returns <tt>false</tt>.
</li>
<li>
<i>Complexity:</i> <ins>For the overloads with no <tt>ExecutionPolicy</tt>, n</ins><del>N</del>o applications of the corresponding predicate if <tt>InputIterator1</tt> and <tt>InputIterator2</tt> meet the requirements of random access iterators and <tt>last1 - first1 != last2 - first2</tt><del>. O</del><ins>; o</ins>therwise, at most <tt>min(last1 - first1, last2 - first2)</tt> applications of the corresponding predicate.

<ins>For the overloads with an <tt>ExecutionPolicy</tt>, no applications of the corresponding predicate if <tt>ForwardIterator1</tt> and <tt>ForwardIterator2</tt> meet the requirements of random access iterators and <tt>last1 - first1 != last2 - first2</tt>; otherwise, <tt>O(min(last1 - first1, last2 - first2))</tt> applications of the corresponding predicate.</ins>

</li>
</ol>


<h4>25.6.9 Unique [alg.unique]</h4>
<blockquote><pre>
template&lt;class InputIterator, class OutputIterator&gt;
  OutputIterator unique_copy(InputIterator first, InputIterator last,
                             OutputIterator result);
template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
  OutputIterator unique_copy(InputIterator first, InputIterator last,
                             OutputIterator result, BinaryPredicate pred);
template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
  <del>OutputIterator</del><ins>ForwardIterator2</ins> unique_copy(ExecutionPolicy&amp;&amp; exec,
                             <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                             <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
         class BinaryPredicate&gt;
  <del>OutputIterator</del><ins>ForwardIterator2</ins> unique_copy(ExecutionPolicy&amp;&amp; exec,
                             <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                             <del>OutputIterator</del><ins>ForwardIterator2</ins> result, BinaryPredicate pred);
</pre></blockquote>
<ol start="5">
<li>
<i>Requires:</i> The comparison function shall be an equivalence relation. The
ranges <tt>[first, last)</tt> and <tt>[result, result+(last-first))</tt> shall
not overlap. The expression <tt>*result = *first</tt> shall be valid. <ins>For
the overloads with no <tt>ExecutionPolicy</tt>, l</ins><del>L</del>et
<tt>T</tt> be the value type of <tt>InputIterator</tt>. If
<tt>InputIterator</tt> meets the forward iterator requirements, then there are
no additional requirements for <tt>T</tt>. Otherwise, if
<tt>OutputIterator</tt> meets the forward iterator requirements and its value
type is the same as <tt>T</tt>, then <tt>T</tt> shall be
<tt>CopyAssignable</tt> (Table 26). Otherwise, <tt>T</tt> shall be both
<tt>CopyConstructible</tt> (Table 24) and <tt>CopyAssignable</tt>. <ins>[
<i>Note:</i> For the overloads with an <tt>ExecutionPolicy</tt>, there may be a
performance cost if the value type of <tt>ForwardIterator1</tt> is not both <tt>CopyConstructible</tt> (Table
24) and <tt>CopyAssignable</tt>. &mdash; <i>end note</i>]</ins>
</li>
<li>
<i>Effects:</i> Copies only the first element from every consecutive group of
equal elements referred to by the iterator <tt>i</tt> in the range
<tt>[first, last)</tt> for which the following corresponding conditions hold:
<tt>*i == *(i - 1)</tt> or <tt>pred(*i, *(i - 1)) != false</tt>.
</li>
<li>
<i>Returns:</i> The end of the resulting range.
</li>
<li>
<i>Complexity:</i> For nonempty ranges, exactly <tt>last - first - 1</tt>
applications of the corresponding predicate.
</li>
</ol>


<h4>25.7.4 Partitions [alg.partitions]</h4>
<blockquote><pre>
template &lt;class InputIterator, class Predicate&gt;
  bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class Predicate&gt;
  bool is_partitioned(ExecutionPolicy&amp;&amp; exec,
                      <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, Predicate pred);
</pre></blockquote>
<ol>
<li>
<i>Requires:</i> <ins>For the overload with no <tt>ExecutionPolicy</tt>,</ins>
<tt>InputIterator</tt>'s value type shall be convertible to
<tt>Predicate</tt>'s argument type.  <ins>For the overload with an
<tt>ExecutionPolicy</tt>, <tt>ForwardIterator</tt>'s value type shall be
convertible to <tt>Predicate</tt>'s argument type.</ins>
</li>
<li>
<i>Returns:</i> <tt>true</tt> if <tt>[first, last)</tt> is empty or if
<tt>[first, last)</tt> is partitioned by <tt>pred</tt>, i.e. if all elements
that satisfy <tt>pred</tt> appear before those that do not.
</li>
<li>
<i>Complexity:</i> Linear. At most <tt>last - first</tt> applications of pred.
</li>
</ol>

<blockquote><pre>
template &lt;class InputIterator, class OutputIterator1,
          class OutputIterator2, class Predicate&gt;
  pair&lt;OutputIterator1, OutputIterator2&gt;
  partition_copy(InputIterator first, InputIterator last,
                 OutputIterator1 out_true, OutputIterator2 out_false,
                 Predicate pred);
template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class <del>Output</del><ins>Forward</ins>Iterator1,
          class <del>Output</del><ins>Forward</ins>Iterator2, class Predicate&gt;
  pair&lt;<del>Output</del><ins>Forward</ins>Iterator1, <del>Output</del><ins>Forward</ins>Iterator2&gt;
  partition_copy(ExecutionPolicy&amp;&amp; exec,	
                 <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
                 <del>Output</del><ins>Forward</ins>Iterator1 out_true, <del>Output</del><ins>Forward</ins>Iterator2 out_false,
                 Predicate pred);
</pre></blockquote>
<ol start="12">
<li>
<i>Requires:</i> <ins>For the overload with no <tt>ExecutionPolicy</tt>,</ins>
<tt>InputIterator</tt>'s value type shall be <tt>CopyAssignable</tt>, and shall
be writable (24.2.1) to the <tt>out_true</tt> and <tt>out_false</tt>
<tt>OutputIterator</tt>s, and shall be convertible to <tt>Predicate</tt>'s
argument type.  <ins>For the overload with an <tt>ExecutionPolicy</tt>,
<tt>ForwardIterator</tt>'s value type shall be <tt>CopyAssignable</tt>, and
shall be writable (24.2.1) to the <tt>out_true</tt> and <tt>out_false</tt>
<tt>ForwardIterator</tt>s, and shall be convertible to <tt>Predicate</tt>'s
argument type.</ins>
<ins>For both overloads, t</ins><del>T</del>he input range shall not overlap
with either of the output ranges.
<ins>[ <i>Note:</i> For the overload with an <tt>ExecutionPolicy</tt>, there
may be a performance cost if <tt>ForwardIterator</tt>'s value type is not
<tt>CopyConstructible</tt>. &mdash; <i>end note</i> ]</ins>
</li>
<li>
<i>Effects:</i> For each iterator <tt>i</tt> in <tt>[first, last)</tt>, copies
<tt>*i</tt> to the output range beginning with <tt>out_true</tt> if
<tt>pred(*i)</tt> is <tt>true</tt>, or to the output range beginning with
<tt>out_false</tt> otherwise.
</li>
<li>
<i>Returns:</i> A pair <tt>p</tt> such that <tt>p.first</tt> is the end of the
output range beginning at <tt>out_true</tt> and <tt>p.second</tt> is the end of
the output range beginning at <tt>out_false</tt>.
</li>
<li>
<i>Complexity:</i> Exactly <tt>last - first</tt> applications of <tt>pred</tt>.

</li>
</ol>


<h4>26.8 Generalized numeric operations [numeric.ops]</h4>
<h4>26.8.1 Header &lt;numeric&gt; synopsis [numeric.ops.overview]</h4>
<blockquote><pre>
namespace std {
  template &lt;class InputIterator, class T&gt;
    T accumulate(InputIterator first, InputIterator last, T init);
  template &lt;class InputIterator, class T, class BinaryOperation&gt;
    T accumulate(InputIterator first, InputIterator last, T init,
                 BinaryOperation binary_op);

  template&lt;class InputIterator&gt;
    typename iterator_traits&lt;InputIterator&gt;::value_type
      reduce(InputIterator first, InputIterator last);
  template&lt;class InputIterator, class T&gt;
    T reduce(InputIterator first, InputIterator last, T init);
  template&lt;class InputIterator, class T, class BinaryOperation&gt;
    T reduce(InputIterator first, InputIterator last, T init,
             BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator&gt;
    typename iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::value_type
      reduce(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
           <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class T&gt;
    T reduce(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
             <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, T init);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator, class T, class BinaryOperation&gt;
    T reduce(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
             <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last, T init,
             BinaryOperation binary_op);

  template&lt;class InputIterator, class UnaryFunction, class T, class BinaryOperation&gt;
    T transform_reduce(InputIterator first, InputIterator last,
                       UnaryOperation unary_op, T init, BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator,
           class UnaryFunction, class T, class BinaryOperation&gt;
    T transform_reduce(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                       <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last,
                       UnaryOperation unary_op, T init, BinaryOperation binary_op);

  template &lt;class InputIterator1, class InputIterator2, class T&gt;
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init);
  template &lt;class InputIterator1, class InputIterator2, class T,
            class BinaryOperation1, class BinaryOperation2&gt;
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init,
                    BinaryOperation1 binary_op1,
                    BinaryOperation2 binary_op2);
  template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
            class T&gt;
    T inner_product(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                    <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                    <del>Input</del><ins>Forward</ins>Iterator2 first2, T init);
  template &lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator1, class <del>Input</del><ins>Forward</ins>Iterator2,
            class T, class BinaryOperation1, class BinaryOperation2&gt;
    T inner_product(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                  <del>Input</del><ins>Forward</ins>Iterator1 first1, <del>Input</del><ins>Forward</ins>Iterator1 last1,
                  <del>Input</del><ins>Forward</ins>Iterator2 first2, T init,
                  BinaryOperation1 binary_op1,
                  BinaryOperation2 binary_op2);

  template &lt;class InputIterator, class OutputIterator&gt;
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result);
  template &lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result,
                               BinaryOperation binary_op);

  template&lt;class InputIterator, class OutputIterator, class T&gt;
    OutputIterator exclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  T init);
  template&lt;class InputIterator, class OutputIterator, class T, class BinaryOperation&gt;
    OutputIterator exclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  T init, BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>, class T&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> exclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                  <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                  T init);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>, class T,
           class BinaryOperation&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> exclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                  <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                  T init, BinaryOperation binary_op);
  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template&lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  BinaryOperation binary_op);
  template&lt;class InputIterator, class OutputIterator, class BinaryOperation, class T&gt;
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  BinaryOperation binary_op, T init);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> inclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                  <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
class BinaryOperation&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> inclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                  <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                  BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class BinaryOperation, class T&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> inclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                  <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                  <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                  BinaryOperation binary_op, T init);

  template&lt;class InputIterator, class OutputIterator,
           class UnaryOperation,
           class T, class BinaryOperation&gt;
    OutputIterator transform_exclusive_scan(InputIterator first, InputIterator last,
                                            OutputIterator result,
                                            UnaryOperation unary_op,
                                            T init, BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class UnaryOperation,
           class T, class BinaryOperation&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> transform_exclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                            <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                            <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                            UnaryOperation unary_op,
                                            T init, BinaryOperation binary_op);
  template&lt;class InputIterator, class OutputIterator,
           class UnaryOperation,
           class BinaryOperation&gt;
    OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last,
                                            OutputIterator result,
                                            UnaryOperation unary_op,
                                            BinaryOperation binary_op);
  template&lt;class InputIterator, class OutputIterator,
           class UnaryOperation,
           class BinaryOperation, class T&gt;
    OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last,
                                            OutputIterator result,
                                            UnaryOperation unary_op,
                                            BinaryOperation binary_op, T init);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class UnaryOperation,
           class BinaryOperation&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> transform_inclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                            <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                            <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                            UnaryOperation unary_op,
                                            BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
           class UnaryOperation,
           class BinaryOperation, class T&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> transform_inclusive_scan(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                            <del>InputIterator</del><ins>ForwardIterator1</ins> first, <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                            <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                            UnaryOperation unary_op,
                                            BinaryOperation binary_op, T init);

  template &lt;class InputIterator, class OutputIterator&gt;
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result);
  template &lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result,
                                       BinaryOperation binary_op);
  template &lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> adjacent_difference(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                       <del>InputIterator</del><ins>ForwardIterator1</ins> first,
                                       <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                       <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
  template &lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
            class BinaryOperation&gt;
    <del>OutputIterator</del><ins>ForwardIterator2</ins> adjacent_difference(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
                                       <del>InputIterator</del><ins>ForwardIterator1</ins> first,
                                       <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                       <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                       BinaryOperation binary_op);

  template &lt;class ForwardIterator, class T&gt;
    void iota(ForwardIterator first, ForwardIterator last, T value);

  <i>// 26.8.13, greatest common divisor</i>
  template &lt;class M, class N&gt;
    constexpr common_type_t&lt;M,N&gt; gcd(M m, N n);

  <i>// 26.8.14, least common multiple</i>
  template &lt;class M, class N&gt;
    constexpr common_type_t&lt;M,N&gt; lcm(M m, N n);
}
</pre></blockquote>


<h4>26.8.3 Reduce [reduce]</h4>
<blockquote><pre>
template&lt;class ExecutionPolicy, class <del>Input</del><ins>Forward</ins>Iterator&gt;
  typename iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::value_type
    reduce(ExecutionPolicy&amp;&amp; exec, <i>// see 25.4.5</i>
         <del>Input</del><ins>Forward</ins>Iterator first, <del>Input</del><ins>Forward</ins>Iterator last);
</pre></blockquote>
<ol start="2">
<li>
<i>Effects:</i> Equivalent to:
<blockquote><pre>
return reduce(std::forward&lt;ExecutionPolicy&gt;(exec), first, last,
	      typename iterator_traits&lt;<del>Input</del><ins>Forward</ins>Iterator&gt;::value_type{});
</pre></blockquote>
</li>
</ol>

<h4>26.8.11 Adjacent difference [adjacent.difference]</h4>
<blockquote><pre>
template &lt;class InputIterator, class OutputIterator&gt;
  OutputIterator adjacent_difference(InputIterator first,
                                     InputIterator last,
                                     OutputIterator result);
template &lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
  OutputIterator adjacent_difference(InputIterator first,
                                     InputIterator last,
                                     OutputIterator result,
                                     BinaryOperation binary_op);
template &lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>&gt;
  <del>OutputIterator</del><ins>ForwardIterator2</ins> adjacent_difference(ExecutionPolicy&amp;&amp; exec,
                                     <del>InputIterator</del><ins>ForwardIterator1</ins> first,
                                     <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                     <del>OutputIterator</del><ins>ForwardIterator2</ins> result);
template &lt;class ExecutionPolicy, class <del>InputIterator</del><ins>ForwardIterator1</ins>, class <del>OutputIterator</del><ins>ForwardIterator2</ins>,
          class BinaryOperation&gt;
  <del>OutputIterator</del><ins>ForwardIterator2</ins> adjacent_difference(ExecutionPolicy&amp;&amp; exec,
                                     <del>InputIterator</del><ins>ForwardIterator1</ins> first,
                                     <del>InputIterator</del><ins>ForwardIterator1</ins> last,
                                     <del>OutputIterator</del><ins>ForwardIterator2</ins> result,
                                     BinaryOperation binary_op);
</pre></blockquote>
<ol>
<li>
<i>Requires:</i>
<ins>For the overloads with no <code>ExecutionPolicy</code></ins>
<tt>InputIterator</tt>'s value type shall be <tt>MoveAssignable</tt> (Table 25)
and shall be constructible from the type of <tt>*first</tt>.  <tt>acc</tt>
<ins>(defined below)</ins> shall be writable (24.2.1) to the <tt>result</tt>
output iterator. The result of the expression <tt>val - acc</tt> or
<tt>binary_op(val, acc)</tt> shall be writable to the <tt>result</tt> output
iterator.
</li>
<li><ins>
<ins>For the overloads with an <tt>ExecutionPolicy</tt> the value
type of <tt>ForwardIterator1</tt> shall be <tt>CopyConstructible</tt> (Table
24), constructible from the expression <tt>*first - *first</tt> or
<tt>binary_op(*first, *first)</tt>, and assignable to the value type of
<tt>ForwardIterator2</tt>.
</ins></li>
<li>
<ins>For all overloads, i</ins><del>I</del>n the ranges <tt>[first, last]</tt>
and <tt>[result, result + (last - first)]</tt>, <tt>binary_op</tt> shall
neither modify elements nor invalidate iterators or subranges.<sup>285</sup>
</ins></li>
<li>
<i>Effects:</i>
<ins>For the overloads with no <tt>ExecutionPolicy</tt> and</ins><del>For</del>
a non-empty range, the function creates an accumulator <tt>acc</tt> whose type
is <tt>InputIterator</tt>'s value type, initializes it with <tt>*first</tt>,
and assigns the result to <tt>*result</tt>. For every iterator <tt>i</tt> in
[<tt>first + 1</tt>,<tt> last</tt>) in order, creates an object <tt>val</tt>
whose type is <tt>InputIterator</tt>'s value type, initializes it with
<tt>*i</tt>, computes <tt>val - acc</tt> or <tt>binary_op(val, acc)</tt>,
assigns the result to <tt>*(result + (i - first))</tt>, and move
assigns from <tt>val</tt> to <tt>acc</tt>.
</li>
<li><ins>
For the overloads with an <tt>ExecutionPolicy</tt> and a non-empty range, first
the function creates an object whose type is <tt>ForwardIterator1</tt>'s value
type, initializes it with <tt>*first</tt>, and assigns the result to
<tt>*result</tt>.  Then for every <tt>d</tt> in <tt>[1, last - first - 1]</tt>,
creates an object <tt>val</tt> whose type is <tt>ForwardIterator1</tt>'s value
type, initializes it with <tt>*(first + d) - *(first + d - 1)</tt> or
<tt>binary_op(*(first + d), *(first + d - 1))</tt>, and assigns the result to
<tt>*(result + d)</tt>.
</ins></li>
<li>
<i>Returns:</i> <tt>result + (last - first)</tt>.
</li>
<li>
<i>Complexity:</i> Exactly <tt>(last - first) - 1</tt> applications of the binary operation.
</li>
<li>
<i>Remarks:</i> <tt>result</tt> may be equal to <tt>first</tt>.
</li>
</ol>

</blockquote>


<h2><a name="7.0">7. Acknowledgements</h2>
<p>
Thanks to David Sankel and Dietmar Khl for early reviews of this paper,
without necessarily endorsing it.  Special thanks to Antony Polukhin for
performing tne exhaustive line-by-line review to catch several omissions
before the final LWG review, and to Bryce Lelbach for support and
encouragemnet to see this through to the end!
</p>
<p>
Extra thanks to the folks in the Library Working Group who patiently
re-reviewed drafts of this paper until it was ready.  Now get some sleep!
</p>


<h2><a name="8.0">8. References</h2>
<ul>
  <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606">N4606</a> (Proposed) Working Draft for C++</li>
  <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4507">N4507</a> C++ Extensions for Parallelism TS</li>
  <li><a href="http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2016/p0024r1">P0024r1</a> The Parallelism TS Should be Standardized, Jared Hoberock</li>
  <li><a href="http://parallelstl.codeplex.com">http://parallelstl.codeplex.com</a> Parallel STL at CodePlex</li>
  <li><a href="https://github.com/KhronosGroup/SyclParallelSTL">https://github.com/KhronosGroup/SyclParallelSTL</a> Khronos Group SyclParallelStl</li>
</ul>


</body>
</html>
