<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 

<head>

<title>Text_view: A C++ concepts and range based character encoding and code
       point enumeration library</title>
<style type="text/css">
table#header th,
table#header td
{
    text-align: left;
}
</style>

</head>


<body>

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>P0244R0</td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2016-02-10</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>Library Evolution Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>

<h1>Text_view: A C++ concepts and range based character encoding and code
    point enumeration library</h1>

<ul>
  <li><a href="p0244r0.html#introduction">
      Introduction</a></li>
  <li><a href="p0244r0.html#motivation">
      Motivation and Scope</a></li>
  <li><a href="p0244r0.html#terminology">
      Terminology</a></li>
  <ul>
    <li><a href="p0244r0.html#term_code_unit">
        Code Unit</a></li>
    <li><a href="p0244r0.html#term_code_point">
        Code Point</a></li>
    <li><a href="p0244r0.html#term_character_set">
        Character Set</a></li>
    <li><a href="p0244r0.html#term_character">
        Character</a></li>
    <li><a href="p0244r0.html#term_encoding">
        Encoding</a></li>
  </ul>
  <li><a href="p0244r0.html#design_considerations">
      Design Considerations</a></li>
  <ul>
    <li><a href="p0244r0.html#iterator_conformance">
        Iterator Requirement Conformance</a></li>
    <li><a href="p0244r0.html#error_handling">
        Error Handling</a></li>
    <li><a href="p0244r0.html#encoding_orientation">
        Encoding Forms vs Encoding Schemes</a></li>
    <li><a href="p0244r0.html#streaming">
        Streaming</a></li>
  </ul>
  <li><a href="p0244r0.html#implementation_exp">
      Implementation Experience</a></li>
  <li><a href="p0244r0.html#technical_specifications">
      Technical Specifications</a></li>
  <ul>
    <li><a href="p0244r0.html#header_synopsis">
        Header &lt;text_view&gt; synopsis</a></li>
    <li><a href="p0244r0.html#concepts">
        Concepts</a></li>
    <li><a href="p0244r0.html#character_sets">
        Character Sets</a></li>
    <li><a href="p0244r0.html#character_set_identification">
        Character Set Identification</a></li>
    <li><a href="p0244r0.html#character_set_information">
        Character Set Information</a></li>
    <li><a href="p0244r0.html#characters">
        Characters</a></li>
    <li><a href="p0244r0.html#encodings">
        Encodings</a></li>
    <li><a href="p0244r0.html#text_iterators">
        Text Iterators</a></li>
    <li><a href="p0244r0.html#text_view">
        Text View</a></li>
  </ul>
  <li><a href="p0244r0.html#acknowledgements">
      Acknowledgements</a></li>
  <li><a href="p0244r0.html#references">
      References</a></li>
</ul>

<h1 id="introduction">Introduction</h1>

<p>C++11 <sup><a href="p0244r0.html#ref_cxx11">[C++11]</a></sup> added support for new
character types
<sup><a href="p0244r0.html#ref_n2249">[N2249]</a></sup> and Unicode string literals
<sup><a href="p0244r0.html#ref_n2442">[N2442]</a></sup>, but neither C++11, nor more recent
standards have provided means of efficiently and conveniently enumerating code
points in Unicode or legacy encodings.  While it is possible to implement such
enumeration using interfaces provided in the standard
<code>&lt;locale&gt;</code> and <code>&lt;codecvt&gt;</code> libraries, doing
so is awkward, requires that text be provided as pointers to contiguous memory,
and inefficent due to virtual function call overhead.

<p>The described library provides iterator and range based interfaces for
encoding and decoding strings in a variety of character encodings.  The
interface is intended to support all modern and legacy character encodings,
though implementations are expected to only provide support for a limited set
of encodings.

<p>An example usage follows. Note that \u00F8 (LATIN SMALL LETTER O WITH STROKE)
is encoded as UTF-8 using two code units (\xC3\xB8), but iterator based
enumeration sees just the single code point.

<pre><code>
using CT = utf8_encoding::character_type;
auto tv = make_text_view<utf8_encoding>(u8"J\u00F8erg");
auto it = tv.begin();
assert(*it++ == CT{0x004A}); // 'J'
assert(*it++ == CT{0x00F8}); // 'Ã¸'
assert(*it++ == CT{0x0065}); // 'e'
</code></pre>

The provided iterators and views are compatible with the non-modifying sequence
utilities provided by the standard C++ <code>&lt;algorithm&gt;</code> library.
This enables use of standard algorithms to search encoded text.

<pre><code>
it = std::find(tv.begin(), tv.end(), CT{0x00F8});
assert(it != tv.end());
</code></pre>

<p>The iterators also provide access to the underlying code unit sequence.

<pre><code>
auto base_it = it.base_range().begin();
assert(*base_it++ == '\xC3');
assert(*base_it++ == '\xB8');
assert(base_it == it.base_range().end());
</code></pre>

These ranges satisfy the requirements for use in C++11 range-based for
statements.  This support is currently limited to views constructed for
stateless encodings as a sentinel type is used as the end iterator for
stateful encodings.  The enhancements to the range-based for statement
in the ranges proposal
<sup><a href="p0244r0.html#ref_ranges">[Ranges]</a></sup> will remove this limitation.

<pre><code>
for (const auto&amp; ch : tv) {
  ...
}
</code></pre>

<h1 id="motivation">Motivation and Scope</h1>

<p>Consider the following code to search for the occurrence of U+00F8 in the
UTF-8 encoded string using C++ standard provided interfaces.

<pre><code>
std::string s = u8"J\u00F8erg";
std::mbstate_t state = std::mbstate_t{};
codecvt_utf8&lt;char32_t&gt; utf8_converter;
const char *from_begin = s.data();
const char *from_end = s.data() + s.size();
const char *from_current;
const char *from_next = from_begin;
char32_t to[1];
std::codecvt_base::result r;
do {
    from_current = from_next;
    char32_t *to_begin = &amp;to[0];
    char32_t *to_end = &amp;to[1];
    char32_t *to_next;
    r = utf8_converter.in(
        state,
        from_current, from_end, from_next,
        to_begin, to_end, to_next); 
} while (r != std::codecvt_base::error &amp;&amp; to[0] != char32_t{0x00F8});
if (r != std::codecvt_base::error &amp;&amp; to[0] == char32_t{0x00F8}) {
    cout &lt;&lt; "Found at offset " &lt;&lt; (from_current - from_begin) &lt;&lt; endl;
} else {
    cout &lt;&lt; "Not found" &lt;&lt; endl;
}
</code></pre>

<p>There are a number of issues with the above code:

<ul>
  <li>It is verbose.</li>
  <li>It is limited to working with strings that are stored in contiguous
      memory.</li>
  <li>It is inefficient.  All <code>codecvt</code> public member functions
      dispatch to virtual member functions.
  <li>It is not generic.  Use of the <code>codecvt_utf8</code> facet makes it
      specific to handling of UTF-8 encoded text.  Making this code generic
      would require some other means of identifying an appropriate facet to
      use.</li>
  <li>It is not applicable to non-Unicode encodings; <code>codecvt</code>
      doesn't provide means to retrieve a code point for the encodings used
      for ordinary and wide strings.  The above code only accomplishes this
      by depending on transcoding to UTF-32 and the fact that UTF-32 is a
      trivial encoding.</li>
</ul>

<p>The above method is not the only method available to identify a search term
in an encoded string.  For some encodings, it is feasible to encode the search
term in the encoding and to search for a matching code unit sequence.  This
approach works for UTF-8, UTF-16, and UTF-32, but not for many other encodings.
Consider the Shift-JIS encoding of U+6D6C.  This is encoded as 0x8A 0x5C.
Shift-JIS is a multibyte encoding that is almost ASCII compatible.  The code
unit sequence 0x5C encodes the ASCII '\' character.  But note that 0x5C appears
as the second byte of the code unit sequence for U+6D6C.  Naively searching for
the matching code unit sequence for '\' would incorrectly match the trailing
code unit sequence for U+6D6C.

<p>The library described here is intended to solve the above issues while also
providing a modern interface that is intuitive to use and can be used with
other standard provided facilities; in particular, the C++ standard
<code>&lt;algorithm&gt;</code> library.

<h1 id="terminology">Terminology</h1>

<p>The terminology used in this document is intended to be consistent with
industry standards and, in particular, the Unicode standard.  Any
inconsistencies in the use of this terminology and that in the Unicode standard
is unintentional.  The terms described in this document comprise a subset of the
terminology used within the Unicode standard; only those terms necessary to
specify functionality exhibited by the proposed library are included here.
Those who would like to learn more about general text processing terminology in
computer systems are encouraged to read chapter 2, "General Structure" of the
Unicode standard.

<h2 id="term_code_unit">Code Unit</h2>

<p>A single, indivisible, integral element of an encoded sequence of characters.
A sequence of one or more code units specifies a code point or encoding state
transition as defined by a character encoding.  A code unit does not, by itself,
identify any particular character or code point; the meaning ascribed to a
particular code unit value is derived from a character encoding definition.

<p>The <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, and
<code>char32_t</code> types are most commonly used as code unit types.

<p>The string literal <code>u8"J\u00F8erg"</code> contains 7 code units and 6
code unit sequences; <code>"\u00F8"</code> is encoded in UTF-8 using two code
units and string literals contain a trailing NUL code unit.

<p>The string literal <code>"J\u00F8erg"</code> contains an implementation
defined number of code units.  The standard does not specify the encoding of
ordinary and wide string literals, so the number of code units encoded by
<code>"\u00F8"</code> depends on the implementation defined encoding used for
ordinary string literals.

<h2 id="term_code_point">Code Point</h2>

<p>An integral value denoting an abstract character as defined by a character
set.  A code point does not, by itself, identify any particular character; the
meaning ascribed to a particular code point value is derived from a character
set definition.

<p>The <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, and
<code>char32_t</code> types are most commonly used as code point types.

<p>The string literal <code>u8"J\u00F8erg"</code> describes a sequence of 6
code point values; string literals implicitly specify a trailing NUL code point.

<p>The string literal <code>"J\u00F8erg"</code> describes a sequence of an
implementation defined number of code point values.  The standard does not
specify the encoding of ordinary and wide string literals, so the number of
code points encoded by <code>"\u00F8"</code> depends on the implementation
defined encoding used for ordinary string literals.  Implementations are
permitted to translate a single code point in the source or Unicode character
sets to multiple code points in the execution encoding.

<h2 id="term_character_set">Character Set</h2>

<p>A mapping of code point values to abstract characters.  A character set need
not provide a mapping for every possible code point value representable by the
code point type.

<p>C++ does not specify the use of any particular character set or encoding for
ordinary and wide character and string literals, though it does place some
restrictions on them.  Unicode character and string literals are governed by the
Unicode standard.

<p>Common character sets include ASCII, Unicode, and Windows code page 1252.

<h2 id="term_character">Character</h2>

<p>An element of written language, for example, a letter, number, or symbol.  A
character is identified by the combination of a character set and a code point
value.

<h2 id="term_encoding">Encoding</h2>

<p>A method of representing a sequence of characters as a sequence of code unit
sequences.

<p>An encoding may be stateless or stateful.  In stateless encodings, characters
may be encoded or decoded starting from the beginning of any code unit sequence.
In stateful encodings, it may be necessary to record certain affects of
previously encoded characters in order to correctly encode additional
characters, or to decode preceding code unit sequences in order to correctly
decode following code unit sequences.

<p>An encoding may be fixed width or variable width.  In fixed width encodings,
all characters are encoded using a single code unit sequence and all code unit
sequences have the same length.  In variable width encodings, different
characters may require multiple code unit sequences, or code unit sequences of
varying length.

<p>An encoding may support bidirectional or random access decoding of code unit
sequences.  In bidirectional encodings, characters may be decoded by traversing
code unit sequences in reverse order.  Such encodings must support a method to
identify the start of a preceding code unit sequence.  In random access
encodings, characters may be decoded from any code unit sequence within the
sequence of code unit sequences, in constant time, without having to decode any
other code unit sequence.  Random access encodings are necessarily stateless
and fixed length.  An encoding that is neither bidirectional, nor random
access, may only be decoded by traversing code unit sequences in forward order.

<p>An encoding may support encoding characters from multiple character sets.
Such an encoding is either stateful and defines code unit sequences that switch
the active character set, or defines code unit sequences that implicitly
identify a character set, or both.

<p>A trivial encoding is one in which all encoded characters correspond to a
single character set and where each code unit encodes exactly one character
using the same value as the code point for that character.  Such an encoding is
stateless, fixed width, and supports random access decoding.

<p>Common encodings include the Unicode UTF-8, UTF-16, and UTF-32 encodings, the
ISO/IEC 8859 series of encodings including ISO/IEC 8859-1, and many trivial
encodings such as Windows code page 1252.

<h1 id="design_considerations">Design Considerations</h1>

<h2 id="iterator_conformance">Iterator Requirement Conformance</h2>

<p>The iterators provided by this library do not conform to all of the
C++ standard requirements for forward and random access iterators.

<p>Each iterator holds its own copy of decoded code point values, two iterators
that compare equally will return different addresses when dereferenced.  The
standard requires that equivalent iterators return equivalent reference and
pointer addresses when dereferenced.  For random access iterators,
<code>operator[]</code> returns a value type since any returned reference type
would immediately become dangling.

<p>The above conformance issues will be resolved if the proxy iterators
proposal <sup><a href="p0244r0.html#ref_proxy_iterators">P0022R1</a></sup> is accepted.

<h2 id="error_handling">Error Handling</h2>

<p>The reference implementation currently throws exceptions when underflow
occurs or when invalid code unit sequences are encountered.  Use of exceptions
is not acceptable by many members of the C++ community.

<p>An alternative to exceptions has not yet been settled on.  One possibility
is to add an additional template parameter to the basic_text_view and
itext_iterator class templates that enables alternative error handling to
be implemented.  Custom error handlers could then substitute replacement
characters and/or record errors via some other mechanism.

<h2 id="encoding_orientation">Encoding Forms vs Encoding Schemes</h2>

<p>The Unicode standard differentiates code unit oriented and byte oriented
encodings.  The former are termed encoding forms; the latter, encoding schemes.
This library provides support for some of each.  For example,
<code>utf16_encoding</code> is code unit oriented; the value type of its
iterators is <code>char16_t</code>.  The <code>utf16be_encoding</code>,
<code>utf16le_encoding</code>, and <code>utf16bom_encoding</code> encodings
are byte oriented; the value type of their iterators is <code>char</code>.

<h2 id="streaming">Streaming</h2>

<p>Decoding from a streaming source without unacceptably blocking on underflow
requires the ability to decode a partial code unit sequence, save state,
and then resume decoding the remainder of the code unit sequence when more
data becomes available.  This requirement presents challenges for an iterator
based approach.  The specification presented in this paper does not provide
a good solution for this use case.

<p>One possibility is to add additional state tracking that is stored with
each iterator.  Support for the possibility of trailing non-code-point
encoding code unit sequences (escape sequences in some encodings) already
requires that code point iterators greedily consume code units.  This enables
an iterator to compare equal to the end iterator even when its current base
code unit iterator does not equal the end iterator of the underlying code
unit range.  Storing partial code unit sequence state with an iterator that
compares equal to the end iterator would enable users to write code like the
following.

<pre><code>
using encoding = utf8_encoding;
auto state = encoding::initial_state();
do {
  std::string b = get_more_data();
  auto tv = make_text_view&lt;encoding&gt;(state, begin(b), end(b));
  auto it = begin(tv);
  while (it != end(tv))
    ...;
  state = it; // Trailing state is preserved in the end iterator.  Save it
              // to seed state for the next loop iteration.
} while (!b.empty());
</code></pre>

<p>However, this leaves open the possibility for trailing code units at the
end of an encoded text to go unnoticed.  In a non-buffering scenario, an
iterator might silently compare equal to the end iterator even though there
are (possibly invalid) code units remaining.

<p>It might be feasible to address this by adding a policy template parameter
to basic_text_view and itext_iterator similiar to what is discussed in the
<a href="p0244r0.html#error_handling">error handling</a> section.

<h1 id="implementation_exp">Implementation Experience</h1>

<p>A reference implementation of the described library is publicly available at
<a href="https://github.com/tahonermann/text_view">
https://github.com/tahonermann/text_view</a>
<sup><a href="p0244r0.html#ref_text_view">[Text_view]</a></sup>.
The implementation requires a compiler that implements the C++ Concepts
technical specification
<sup><a href="p0244r0.html#ref_concepts">[Concepts]</a></sup>.
The only compiler known to do so at the time of this
writing is the in-development gcc 6.0 release.

<p>The reference implementation currently depends on Andrew Sutton's 
<a href="http://asutton.github.io/origin">Origin</a>
<sup><a href="p0244r0.html#ref_origin">[Origin]</a></sup> libraries for concept
definitions.  Origin's concept definitions do not match the concept
definitions specified in the proposed ranges technical specification
<sup><a href="p0244r0.html#ref_ranges">[Ranges]</a></sup> and used as the specification
of the described library in this document.  As a result, the interface
declarations in the reference implementation differ from those presented
here.  The expectation is that code written to the specification presented
here will work with the reference implementation, but there may be some
corner cases that make the differences apparent.  Any such differences should
be considered defects or limitations of the reference implementation and
reported at <a href="https://github.com/tahonermann/text_view/issues">
https://github.com/tahonermann/text_view/issues</a>.

<h1 id="technical_specifications">Technical Specifications</h1>

<h2 id="header_synopsys">Header &lt;text_view&gt; synopsis</h2>

<pre><code>
namespace std {
namespace experimental {
inline namespace text {

// concepts:
template&lt;typename T&gt; concept bool CodeUnit();
template&lt;typename T&gt; concept bool CodePoint();
template&lt;typename T&gt; concept bool CharacterSet();
template&lt;typename T&gt; concept bool Character();
template&lt;typename T&gt; concept bool CodeUnitIterator();
template&lt;typename T, typename V&gt; concept bool CodeUnitOutputIterator();
template&lt;typename T&gt; concept bool TextEncodingState();
template&lt;typename T&gt; concept bool TextEncodingStateTransition();
template&lt;typename T&gt; concept bool TextEncoding();
template&lt;typename T, typename I&gt; concept bool TextEncoder();
template&lt;typename T, typename I&gt; concept bool TextDecoder();
template&lt;typename T, typename I&gt; concept bool TextForwardDecoder();
template&lt;typename T, typename I&gt; concept bool TextBidirectionalDecoder();
template&lt;typename T, typename I&gt; concept bool TextRandomAccessDecoder();
template&lt;typename T&gt; concept bool TextIterator();
template&lt;typename T&gt; concept bool TextOutputIterator();
template&lt;typename T, typename I&gt; concept bool TextSentinel();
template&lt;typename T&gt; concept bool TextView();

// character sets:
class any_character_set;
class basic_execution_character_set;
class basic_execution_wide_character_set;
class unicode_character_set;

// implementation defined character set type aliases:
using execution_character_set = /* implementation-defined */ ;
using execution_wide_character_set = /* implementation-defined */ ;
using universal_character_set = /* implementation-defined */ ;

// character set identification:
class character_set_id;

template&lt;typename CST&gt;
  inline character_set_id get_character_set_id();

// character set information:
class character_set_info;

template&lt;typename CST&gt;
  inline const character_set_info&amp; get_character_set_info();
const character_set_info&amp; get_character_set_info(character_set_id id);

// character set and encoding traits:
template&lt;typename T&gt;
  using code_unit_type_t = /* implementation-defined */ ;
template&lt;typename T&gt;
  using code_point_type_t = /* implementation-defined */ ;
template&lt;typename T&gt;
  using character_set_type_t = /* implementation-defined */ ;
template&lt;typename T&gt;
  using character_type_t = /* implementation-defined */ ;
template&lt;typename T&gt;
  using encoding_type_t /* implementation-defined */ ;

// characters:
template&lt;CharacterSet CST&gt; class character;
template &lt;&gt; class character&lt;any_character_set&gt;;

template&lt;CharacterSet CST&gt;
  bool operator==(const character&lt;any_character_set&gt; &amp;lhs,
                  const character&lt;CST&gt; &amp;rhs);
template&lt;CharacterSet CST&gt;
  bool operator==(const character&lt;CST&gt; &amp;lhs,
                  const character&lt;any_character_set&gt; &amp;rhs);
template&lt;CharacterSet CST&gt;
  bool operator!=(const character&lt;any_character_set&gt; &amp;lhs,
                  const character&lt;CST&gt; &amp;rhs);
template&lt;CharacterSet CST&gt;
  bool operator!=(const character&lt;CST&gt; &amp;lhs,
                  const character&lt;any_character_set&gt; &amp;rhs);

// encoding state and transition types:
class trivial_encoding_state;
class trivial_encoding_state_transition;
class utf8bom_encoding_state;
class utf8bom_encoding_state_transition;
class utf16bom_encoding_state;
class utf16bom_encoding_state_transition;
class utf32bom_encoding_state;
class utf32bom_encoding_state_transition;

// encodings:
class basic_execution_character_encoding;
class basic_execution_wide_character_encoding;
#if defined(__STDC_ISO_10646__)
class iso_10646_wide_character_encoding;
#endif // __STDC_ISO_10646__
class utf8_encoding;
class utf8bom_encoding;
class utf16_encoding;
class utf16be_encoding;
class utf16le_encoding;
class utf16bom_encoding;
class utf32_encoding;
class utf32be_encoding;
class utf32le_encoding;
class utf32bom_encoding;

// implementation defined encoding type aliases:
using execution_character_encoding = /* implementation-defined */ ;
using execution_wide_character_encoding = /* implementation-defined */ ;
using char8_character_encoding = /* implementation-defined */ ;
using char16_character_encoding = /* implementation-defined */ ;
using char32_character_encoding = /* implementation-defined */ ;

// itext_iterator:
template&lt;TextEncoding ET, ranges::InputRange RT&gt;
  requires TextDecoder&lt;ET, ranges::iterator_t&lt;const RT&gt;&gt;()
  class itext_iterator;

// itext_sentinel:
template&lt;TextEncoding ET, ranges::InputRange RT&gt;
  class itext_sentinel;

// otext_iterator:
template&lt;TextEncoding E, CodeUnitOutputIterator&lt;code_unit_type_t&lt;E&gt;&gt; CUIT&gt;
  class otext_iterator;

// otext_iterator factory functions:
template&lt;TextEncoding ET, CodeUnitOutputIterator&lt;code_unit_type_t&lt;ET&gt;&gt; IT&gt;
  auto make_otext_iterator(typename ET::state_type state, IT out)
  -&gt; otext_iterator&lt;ET, IT&gt;;
template&lt;TextEncoding ET, CodeUnitOutputIterator&lt;code_unit_type_t&lt;ET&gt;&gt; IT&gt;
  auto make_otext_iterator(IT out)
  -&gt; otext_iterator&lt;ET, IT&gt;;

// basic_text_view:
template&lt;TextEncoding ET, ranges::InputRange RT&gt;
  class basic_text_view;

// basic_text_view type aliases:
using text_view = basic_text_view&lt;execution_character_encoding,
                                  /* implementation-defined */ &gt;;
using wtext_view = basic_text_view&lt;execution_wide_character_encoding,
                                   /* implementation-defined */ &gt;;
using u8text_view = basic_text_view&lt;char8_character_encoding,
                                    /* implementation-defined */ &gt;;
using u16text_view = basic_text_view&lt;char16_character_encoding,
                                     /* implementation-defined */ &gt;;
using u32text_view = basic_text_view&lt;char32_character_encoding,
                                     /* implementation-defined */ &gt;;

// basic_text_view factory functions:
template&lt;TextEncoding ET, ranges::InputIterator IT, ranges::Sentinel&lt;IT&gt; ST&gt;
  auto make_text_view(typename ET::state_type state, IT first, ST last)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;
template&lt;TextEncoding ET, ranges::InputIterator IT, ranges::Sentinel&lt;IT&gt; ST&gt;
  auto make_text_view(IT first, ST last)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;
template&lt;TextEncoding ET, ranges::ForwardIterator IT&gt;
  auto make_text_view(typename ET::state_type state,
                      IT first,
                      typename std::make_unsigned&lt;ranges::difference_type_t&lt;IT&gt;&gt;::type n)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;
template&lt;TextEncoding ET, ranges::ForwardIterator IT&gt;
  auto make_text_view(IT first,
                      typename std::make_unsigned&lt;ranges::difference_type_t&lt;IT&gt;&gt;::type n)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;
template&lt;TextEncoding ET, ranges::InputRange Iterable&gt;
  auto make_text_view(typename ET::state_type state,
                      const Iterable &amp;iterable)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;
template&lt;TextEncoding ET, ranges::InputRange Iterable&gt;
  auto make_text_view(const Iterable &amp;iterable)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;
template&lt;TextIterator TIT, TextSentinel&lt;TIT&gt; TST&gt;
  auto make_text_view(TIT first, TST last)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;
template&lt;TextView TVT&gt;
  TVT make_text_view(TVT tv);

} // inline namespace text
} // namespace experimental
} // namespace std
</code></pre>

<h2 id="concepts">Concepts</h2>

<ul>
  <li><a href="p0244r0.html#concept_codeunit">
      Concept CodeUnit</a></li>
  <li><a href="p0244r0.html#concept_codepoint">
      Concept CodePoint</a></li>
  <li><a href="p0244r0.html#concept_characterset">
      Concept CharacterSet</a></li>
  <li><a href="p0244r0.html#concept_character">
      Concept Character</a></li>
  <li><a href="p0244r0.html#concept_codeunititerator">
      Concept CodeUnitIterator</a></li>
  <li><a href="p0244r0.html#concept_codeunitoutputiterator">
      Concept CodeUnitOutputIterator</a></li>
  <li><a href="p0244r0.html#concept_textencodingstate">
      Concept TextEncodingState</a></li>
  <li><a href="p0244r0.html#concept_textencodingstatetransition">
      Concept TextEncodingStateTransition</a></li>
  <li><a href="p0244r0.html#concept_textencoding">
      Concept TextEncoding</a></li>
  <li><a href="p0244r0.html#concept_textencoder">
      Concept TextEncoder</a></li>
  <li><a href="p0244r0.html#concept_textdecoder">
      Concept TextDecoder</a></li>
  <li><a href="p0244r0.html#concept_textforwarddecoder">
      Concept TextForwardDecoder</a></li>
  <li><a href="p0244r0.html#concept_textbidirectionaldecoder">
      Concept TextBidirectionalDecoder</a></li>
  <li><a href="p0244r0.html#concept_textrandomaccessdecoder">
      Concept TextRandomAccessDecoder</a></li>
  <li><a href="p0244r0.html#concept_textiterator">
      Concept TextIterator</a></li>
  <li><a href="p0244r0.html#concept_textsentinel">
      Concept TextSentinel</a></li>
  <li><a href="p0244r0.html#concept_textoutputiterator">
      Concept TextOutputIterator</a></li>
  <li><a href="p0244r0.html#concept_textview">
      Concept TextView</a></li>
</ul>

<h3 id="concept_codeunit">
      Concept CodeUnit</h3>

<p>The <code>CodeUnit</code> concept specifies requirements for a type usable as
the code unit type of a string type.

<p><code>CodeUnit&lt;T&gt;()</code> is satisfied if and only if:
<ul>
  <li><code>std::is_integral&lt;T&gt;::value</code> is true</li>
  <li>and at least one of:
    <ul>
      <li><code>std::is_unsigned&lt;T&gt;::value</code> is true.</li>
      <li><code>std::is_same&lt;std::remove_cv&lt;T&gt;::type, char&gt;::value
          </code> is true.</li>
      <li><code>std::is_same&lt;std::remove_cv&lt;T&gt;::type, wchar_t&gt;::value
          </code> is true.</li>
    </ul></li>
</ul>

<pre><code>
template&lt;typename T&gt; concept bool CodeUnit() {
  return /* implementation-defined */ ;
}
</code></pre>

<h3 id="concept_codepoint">
      Concept CodePoint</h3>

<p>The <code>CodePoint</code> concept specifies requirements for a type usable
as the code point type of a character set type.

<p><code>CodePoint&lt;T&gt;()</code> is satisfied if and only if:
<ul>
  <li><code>std::is_integral&lt;T&gt;::value</code> is true</li>
  <li>and at least one of:
    <ul>
      <li><code>std::is_unsigned&lt;T&gt;::value</code> is true.</li>
      <li><code>std::is_same&lt;std::remove_cv&lt;T&gt;::type, char&gt;::value
          </code> is true.</li>
      <li><code>std::is_same&lt;std::remove_cv&lt;T&gt;::type, wchar_t&gt;::value
          </code> is true.</li>
    </ul></li>
</ul>

<pre><code>
template&lt;typename T&gt; concept bool CodePoint() {
  return /* implementation-defined */ ;
}
</code></pre>

<h3 id="concept_characterset">
      Concept CharacterSet</h3>

<p>The <code>CharacterSet</code> concept specifies requirements for a type
that describes a character set.  Such a type has a member typedef-name
declaration for a type that satisfies <code>CodePoint</code> and a static
member function that returns a name for the character set.

<pre><code>
template&lt;typename T&gt; concept bool CharacterSet() {
  return CodePoint&lt;code_point_type_t&lt;T&gt;&gt;()
      &amp;&amp; requires () {
           { T::get_name() } noexcept -&gt; const char *;
         };
}
</code></pre>

<h3 id="concept_character">
      Concept Character</h3>

<p>The <code>Character</code> concept specifies requirements for a type that
describes a character as defined by an associated character set.  Non-static
member functions provide access to the code point value of the described
character.  Types that satisfy <code>Character</code> are regular and copyable.

<pre><code>
template&lt;typename T&gt; concept bool Character() {
  return ranges::Regular&lt;T&gt;()
      &amp;&amp; ranges::Copyable&lt;T&gt;()
      &amp;&amp; CharacterSet&lt;character_set_type_t&lt;T&gt;&gt;()
      &amp;&amp; requires (T t, code_point_type_t&lt;character_set_type_t&lt;T&gt;&gt; cp) {
           t.set_code_point(cp);
           { t.get_code_point() } -&gt; code_point_type_t&lt;character_set_type_t&lt;T&gt;&gt;;
           { t.get_character_set_id() } -&gt; character_set_id;
         };
}
</code></pre>

<h3 id="concept_codeunititerator">
      Concept CodeUnitIterator</h3>

<p>The <code>CodeUnitIterator</code> concept specifies requirements of an
iterator that has a value type that satisfies <code>CodeUnit</code>.

<pre><code>
template&lt;typename T&gt; concept bool CodeUnitIterator() {
  return ranges::Iterator&lt;T&gt;()
      &amp;&amp; CodeUnit&lt;ranges::value_type_t&lt;T&gt;&gt;();
}
</code></pre>

<h3 id="concept_codeunitoutputiterator">
      Concept CodeUnitOutputIterator</h3>

<p>The <code>CodeUnitOutputIterator</code> concept specifies requirements of
an output iterator that can be assigned from a type that satisfies
<code>CodeUnit</code>.

<pre><code>
template&lt;typename T, typename V&gt; concept bool CodeUnitOutputIterator() {
  return ranges::OutputIterator&lt;T, V&gt;()
      &amp;&amp; CodeUnit&lt;V&gt;();
}
</code></pre>

<h3 id="concept_textencodingstate">
      Concept TextEncodingState</h3>

<p>The <code>TextEncodingState</code> concept specifies requirements of types
that hold encoding state.  Such types are default constructible and copyable.

<pre><code>
template&lt;typename T&gt; concept bool TextEncodingState() {
  return ranges::DefaultConstructible&lt;T&gt;()
      &amp;&amp; ranges::Copyable&lt;T&gt;();
}
</code></pre>

<h3 id="concept_textencodingstatetransition">
      Concept TextEncodingStateTransition</h3>

<p>The <code>TextEncodingStateTransition</code> concept specifies requirements
of types that hold encoding state transitions.  Such types are default
constructible and copyable.

<pre><code>
template&lt;typename T&gt; concept bool TextEncodingStateTransition() {
  return ranges::DefaultConstructible&lt;T&gt;()
      &amp;&amp; ranges::Copyable&lt;T&gt;();
}
</code></pre>

<h3 id="concept_textencoding">
      Concept TextEncoding</h3>

<p>The <code>TextEncoding</code> concept specifies requirements of types that
define an encoding.  Such types define member types that identify the
code unit, character, encoding state, and encoding state transition types, a
static member function that returns an initial encoding state object that
defines the encoding state at the beginning of a sequence of encoded characters,
and static data members that specify the minimum and maximum number of
code units used to encode any single character.

<pre><code>
template&lt;typename T&gt; concept bool TextEncoding() {
  return requires () {
           { T::min_code_units } noexcept -&gt; int;
           { T::max_code_units } noexcept -&gt; int;
         }
      &amp;&amp; TextEncodingState&lt;typename T::state_type&gt;()
      &amp;&amp; TextEncodingStateTransition&lt;typename T::state_transition_type&gt;()
      &amp;&amp; CodeUnit&lt;code_unit_type_t&lt;T&gt;&gt;()
      &amp;&amp; Character&lt;character_type_t&lt;T&gt;&gt;()
      &amp;&amp; requires () {
           { T::initial_state() }
               -&gt; const typename T::state_type&amp;;
         };
}
</code></pre>

<h3 id="concept_textencoder">
      Concept TextEncoder</h3>

<p>The <code>TextEncoder</code> concept specifies requirements of types that
are used to encode characters using a particular code unit iterator that
satisfies <code>OutputIterator</code>.  Such a type satisifies
<code>TextEncoding</code> and defines static member functions used to encode
state transitions and characters.

<pre><code>
template&lt;typename T, typename I&gt; concept bool TextEncoder() {
  return TextEncoding&lt;T&gt;()
      &amp;&amp; ranges::OutputIterator&lt;CUIT, code_unit_type_t&lt;T&gt;&gt;()
      &amp;&amp; requires (
           typename T::state_type &amp;state,
           CUIT &amp;out,
           typename T::state_transition_type stt,
           int &amp;encoded_code_units)
         {
           T::encode_state_transition(state, out, stt, encoded_code_units);
         }
      &amp;&amp; requires (
           typename T::state_type &amp;state,
           CUIT &amp;out,
           character_type_t&lt;T&gt; c,
           int &amp;encoded_code_units)
         {
           T::encode(state, out, c, encoded_code_units);
         };
}
</code></pre>

<h3 id="concept_textdecoder">
      Concept TextDecoder</h3>

<p>The <code>TextDecoder</code> concept specifies requirements of types that
are used to decode characters using a particular code unit iterator that
satisifies <code>InputIterator</code>.  Such a type satisfies
<code>TextEncoding</code> and defines a static member function used to decode
state transitions and characters.

<pre><code>
template&lt;typename T, typename I&gt; concept bool TextDecoder() {
  return TextEncoding&lt;T&gt;()
      &amp;&amp; ranges::InputIterator&lt;CUIT&gt;()
      &amp;&amp; ranges::ConvertibleTo&lt;ranges::value_type_t&lt;CUIT&gt;,
                               code_unit_type_t&lt;T&gt;&gt;()
      &amp;&amp; requires (
           typename T::state_type &amp;state,
           CUIT &amp;in_next,
           CUIT in_end,
           character_type_t&lt;T&gt; &amp;c,
           int &amp;decoded_code_units)
         {
           { T::decode(state, in_next, in_end, c, decoded_code_units) } -&gt; bool;
         };
}
</code></pre>

<h3 id="concept_textforwarddecoder">
      Concept TextForwardDecoder</h3>

<p>The <code>TextForwardDecoder</code> concept specifies requirements of types
that are used to decode characters using a particular code unit iterator that
satisifies <code>ForwardIterator</code>.  Such a type also satisfies
<code>TextDecoder</code>.

<pre><code>
template&lt;typename T, typename I&gt; concept bool TextForwardDecoder() {
  return TextDecoder&lt;T, CUIT&gt;()
      &amp;&amp; ranges::ForwardIterator&lt;CUIT&gt;();
}
</code></pre>

<h3 id="concept_textbidirectionaldecoder">
      Concept TextBidirectionalDecoder</h3>

<p>The <code>TextBidirectionalDecoder</code> concept specifies requirements of
types that are used to decode characters using a particular code unit iterator
that satisifies <code>BidirectionalIterator</code>.  Such a type also satisfies
<code>TextForwardDecoder</code> and defines a static member function used to
decode state transitions and characters in the reverse order of their encoding.

<pre><code>
template&lt;typename T, typename I&gt; concept bool TextBidirectionalDecoder() {
  return TextForwardDecoder&lt;T, CUIT&gt;()
      &amp;&amp; ranges::BidirectionalIterator&lt;CUIT&gt;()
      &amp;&amp; requires (
           typename T::state_type &amp;state,
           CUIT &amp;in_next,
           CUIT in_end,
           character_type_t&lt;T&gt; &amp;c,
           int &amp;decoded_code_units)
         {
           { T::rdecode(state, in_next, in_end, c, decoded_code_units) } -&gt; bool;
         };
}
</code></pre>

<h3 id="concept_textrandomaccessdecoder">
      Concept TextRandomAccessDecoder</h3>

<p>The <code>TextRandomAccessDecoder</code> concept specifies requirements of
types that are used to decode characters using a particular code unit iterator
that satisifies <code>RandomAccessIterator</code>.  Such a type also satisfies
<code>TextBidirectionalDecoder</code>, requires that the minimum and maximum
number of code units used to encode any character have the same value, and that
the encoding state be an empty type.

<pre><code>
template&lt;typename T, typename I&gt; concept bool TextRandomAccessDecoder() {
  return TextBidirectionalDecoder&lt;T, CUIT&gt;()
      &amp;&amp; ranges::RandomAccessIterator&lt;CUIT&gt;()
      &amp;&amp; T::min_code_units == T::max_code_units
      &amp;&amp; std::is_empty&lt;typename T::state_type&gt;::value;
}
</code></pre>

<h3 id="concept_textiterator">
      Concept TextIterator</h3>

<p>The <code>TextIterator</code> concept specifies requirements of types that
are used to iterator over characters in an encoded sequence of code units.
Encoding state is held in each iterator instance as needed to decode the code
unit sequence and is made accessible via non-static member functions.  The value
type of a <code>TextIterator</code> satisfies <code>Character</code>.

<pre><code>
template&lt;typename T&gt; concept bool TextIterator() {
  return ranges::Iterator&lt;T&gt;()
      &amp;&amp; Character&lt;ranges::value_type_t&lt;T&gt;&gt;()
      &amp;&amp; TextEncoding&lt;encoding_type_t&lt;T&gt;&gt;()
      &amp;&amp; TextEncodingState&lt;typename T::state_type&gt;()
      &amp;&amp; requires (T t, const T ct) {
           { t.state() } noexcept
               -&gt; typename encoding_type_t&lt;T&gt;::state_type&amp;;
           { ct.state() } noexcept
               -&gt; const typename encoding_type_t&lt;T&gt;::state_type&amp;;
         };
}
</code></pre>

<h3 id="concept_textsentinel">
      Concept TextSentinel</h3>

<p>The <code>TextSentinel</code> concept specifies requirements of types that
are used to mark the end of a range of encoded characters.  A type T that
satisfies <code>TextIterator</code> also satisfies
<code>TextSentinel&lt;T&gt;</code> there by enabling <code>TextIterator</code>
types to be used as sentinels.

<pre><code>
template&lt;typename T, typename I&gt; concept bool TextSentinel() {
  return ranges::Sentinel&lt;T, I&gt;()
      &amp;&amp; TextIterator&lt;I&gt;();
}
</code></pre>

<h3 id="concept_textoutputiterator">
      Concept TextOutputIterator</h3>

<p>The <code>TextOutputIterator</code> concept specifies requirements of types
that are used to encode characters as a sequence of code units.  Encoding state
is held in each iterator instance as needed to encode the code unit sequence
and is made accessible via non-static member functions.

<pre><code>
template&lt;typename T&gt; concept bool TextOutputIterator() {
  return ranges::OutputIterator&lt;T, character_type_t&lt;encoding_type_t&lt;T&gt;&gt;&gt;()
      &amp;&amp; TextEncoding&lt;encoding_type_t&lt;T&gt;&gt;()
      &amp;&amp; TextEncodingState&lt;typename T::state_type&gt;()
      &amp;&amp; requires (T t, const T ct) {
           { t.state() } noexcept
               -&gt; typename encoding_type_t&lt;T&gt;::state_type&amp;;
           { ct.state() } noexcept
               -&gt; const typename encoding_type_t&lt;T&gt;::state_type&amp;;
         };
}
</code></pre>

<h3 id="concept_textview">
      Concept TextView</h3>

<p>The <code>TextView</code> concept specifies requirements of types that
provide view access to an underlying code unit range.  Such types satisy
<code>ranges::View</code>, provide iterators that satisfy
<code>TextIterator</code>, define member types that identify the encoding,
encoding state, and underlying code unit range and iterator types.  Non-static
member functions are provided to access the underlying code unit range and
initial encoding state.

<p>Types that satisfy <code>TextView</code> do not own the underlying code unit
range and are copyable in constant time.  The lifetime of the underlying range
must exceed the lifetime of referencing <code>TextView</code> objects.

<pre><code>
template&lt;typename T&gt; concept bool TextView() {
  return ranges::View&lt;T&gt;()
      R&amp; TextIterator&lt;ranges::iterator_t&lt;T&gt;&gt;()
      &amp;&amp; TextEncoding&lt;encoding_type_t&lt;T&gt;&gt;()
      &amp;&amp; ranges::InputRange&lt;typename T::range_type&gt;()
      &amp;&amp; TextEncodingState&lt;typename T::state_type&gt;()
      &amp;&amp; CodeUnitIterator&lt;code_unit_iterator_t&lt;T&gt;&gt;()
      R&amp; requires (T t, const T ct) {
           { t.base() } noexcept
               -&gt; typename T::range_type&amp;;
           { ct.base() } noexcept
               -&gt; const typename T::range_type&amp;;
           { t.initial_state() } noexcept
               -&gt; typename T::state_type&amp;;
           { ct.initial_state() } noexcept
               -&gt; const typename T::state_type&amp;;
         };
}
</code></pre>

<h2 id="character_sets">Character Sets</h2>

<ul>
  <li><a href="p0244r0.html#class_any_character_set">
      Class any_character_set</a></li>
  <li><a href="p0244r0.html#class_basic_execution_character_set">
      Class basic_execution_character_set</a></li>
  <li><a href="p0244r0.html#class_basic_execution_wide_character_set">
      Class basic_execution_wide_character_set</a></li>
  <li><a href="p0244r0.html#class_unicode_character_set">
      Class unicode_character_set</a></li>
  <li><a href="p0244r0.html#character_set_type_aliases">
      Character set type aliases</a></li>
</ul>

<h3 id="class_any_character_set">Class any_character_set</h3>

<pre><code>
class any_character_set {
public:
  using code_point_type = /* implementation-defined */;

  static const char* get_name() noexcept;
};
</code></pre>

<h3 id="class_basic_execution_character_set">
  Class basic_execution_character_set</h3>

<pre><code>
class basic_execution_character_set {
public:
  using code_point_type = char;

  static const char* get_name() noexcept;
};
</code></pre>

<h3 id="class_basic_execution_wide_character_set">
  Class basic_execution_wide_character_set</h3>

<pre><code>
class basic_execution_wide_character_set {
public:
  using code_point_type = wchar_t;

  static const char* get_name() noexcept;
};
</code></pre>

<h3 id="class_unicode_character_set">
  Class unicode_character_set</h3>

<pre><code>
class unicode_character_set {
public:
  using code_point_type = char32_t;

  static const char* get_name() noexcept;
};
</code></pre>

<h3 id="character_set_type_aliases">
  Character set type aliases</h3>

<pre><code>
using execution_character_set = /* implementation-defined */ ;
using execution_wide_character_set = /* implementation-defined */ ;
using universal_character_set = /* implementation-defined */ ;
</code></pre>

<h2 id="character_set_identification">Character Set Identification</h2>

<ul>
  <li><a href="p0244r0.html#class_character_set_id">
      Class character_set_id</a></li>
  <li><a href="p0244r0.html#get_character_set_id">
      get_character_set_id</a></li>
</ul>

<h3 id="class_character_set_id">
  Class character_set_id</h3>

<pre><code>
class character_set_id {
public:
  character_set_id() = delete;

  friend bool operator==(character_set_id lhs, character_set_id rhs);
  friend bool operator!=(character_set_id lhs, character_set_id rhs);

  friend bool operator&lt;(character_set_id lhs, character_set_id rhs);
  friend bool operator&gt;(character_set_id lhs, character_set_id rhs);
  friend bool operator&lt;=(character_set_id lhs, character_set_id rhs);
  friend bool operator&gt;=(character_set_id lhs, character_set_id rhs);
};
</code></pre>

<h3 id="get_character_set_id">
  get_character_set_id</h3>

<pre><code>
template&lt;typename CST&gt;
  inline character_set_id get_character_set_id();
</code></pre>

<h2 id="character_set_information">Character Set Information</h2>

<ul>
  <li><a href="p0244r0.html#class_character_set_info">
      Class character_set_info</a></li>
  <li><a href="p0244r0.html#get_character_set_info">
      get_character_set_info</a></li>
</ul>

<h3 id="class_character_set_info">
  Class character_set_info</h3>

<pre><code>
class character_set_info {
public:
  character_set_info() = delete;

  character_set_id get_id() const noexcept;

  const char* get_name() const noexcept;

private:
  character_set_id id; // exposition only
};
</code></pre>

<h3 id="get_character_set_info">
  get_character_set_info</h3>

<pre><code>
const character_set_info&amp; get_character_set_info(character_set_id id);

template&lt;typename CST&gt;
  inline const character_set_info&amp; get_character_set_info();
</code></pre>

<h2 id="characters">Characters</h2>

<ul>
  <li><a href="p0244r0.html#class_template_character">
      Class template character</a></li>
</ul>

<h3 id="class_template_character">
  Class template character</h3>

<pre><code>
template&lt;CharacterSet CST&gt;
class character {
public:
  using character_set_type = CST;
  using code_point_type = code_point_type_t&lt;character_set_type&gt;;

  character() = default;
  explicit character(code_point_type code_point);

  friend bool operator==(const character &amp;lhs, const character &amp;rhs);
  friend bool operator!=(const character &amp;lhs, const character &amp;rhs);

  void set_code_point(code_point_type code_point);
  code_point_type get_code_point() const;

  static character_set_id get_character_set_id();

private:
  code_point_type code_point; // exposition only
};

template&lt;&gt;
class character&lt;any_character_set&gt; {
public:
  using character_set_type = any_character_set;
  using code_point_type = code_point_type_t&lt;character_set_type&gt;;

  character() = default;
  explicit character(code_point_type code_point);
  character(character_set_id cs_id, code_point_type code_point);

  friend bool operator==(const character &amp;lhs, const character &amp;rhs);
  friend bool operator!=(const character &amp;lhs, const character &amp;rhs);

  void set_code_point(code_point_type code_point);
  code_point_type get_code_point() const;

  void set_character_set_id(character_set_id new_cs_id);
  character_set_id get_character_set_id() const;

private:
  character_set_id cs_id;     // exposition only
  code_point_type code_point; // exposition only
};

template&lt;CharacterSet CST&gt;
  bool operator==(const character&lt;any_character_set&gt; &amp;lhs,
                  const character&lt;CST&gt; &amp;rhs);
template&lt;CharacterSet CST&gt;
  bool operator==(const character&lt;CST&gt; &amp;lhs,
                  const character&lt;any_character_set&gt; &amp;rhs);
template&lt;CharacterSet CST&gt;
  bool operator!=(const character&lt;any_character_set&gt; &amp;lhs,
                  const character&lt;CST&gt; &amp;rhs);
template&lt;CharacterSet CST&gt;
  bool operator!=(const character&lt;CST&gt; &amp;lhs,
                  const character&lt;any_character_set&gt; &amp;rhs);
</code></pre>

<h2 id="encodings">Encodings</h2>

<ul>
  <li><a href="p0244r0.html#class_trivial_encoding_state">
      class trivial_encoding_state</a></li>
  <li><a href="p0244r0.html#class_trivial_encoding_state_transition">
      class trivial_encoding_state_transition</a></li>
  <li><a href="p0244r0.html#class_basic_execution_character_encoding">
      Class basic_execution_character_encoding</a></li>
  <li><a href="p0244r0.html#class_basic_execution_wide_character_encoding">
      Class basic_execution_wide_character_encoding</a></li>
  <li><a href="p0244r0.html#class_iso_10646_wide_character_encoding">
      Class iso_10646_wide_character_encoding</a></li>
  <li><a href="p0244r0.html#class_utf8_encoding">
      Class utf8_encoding</a></li>
  <li><a href="p0244r0.html#class_utf8bom_encoding">
      Class utf8bom_encoding</a></li>
  <li><a href="p0244r0.html#class_utf16_encoding">
      Class utf16_encoding</a></li>
  <li><a href="p0244r0.html#class_utf16be_encoding">
      Class utf16be_encoding</a></li>
  <li><a href="p0244r0.html#class_utf16le_encoding">
      Class utf16le_encoding</a></li>
  <li><a href="p0244r0.html#class_utf16bom_encoding">
      Class utf16bom_encoding</a></li>
  <li><a href="p0244r0.html#class_utf32_encoding">
      Class utf32_encoding</a></li>
  <li><a href="p0244r0.html#class_utf32be_encoding">
      Class utf32be_encoding</a></li>
  <li><a href="p0244r0.html#class_utf32le_encoding">
      Class utf32le_encoding</a></li>
  <li><a href="p0244r0.html#class_utf32bom_encoding">
      Class utf32bom_encoding</a></li>
  <li><a href="p0244r0.html#encoding-type-aliases">
      Encoding type aliases</a></li>
</ul>

<h3 id="class_trivial_encoding_state">
  Class trivial_encoding_state</h3>

<pre><code>
class trivial_encoding_state {};
</code></pre>

<h3 id="class_trivial_encoding_state_transition">
  Class trivial_encoding_state_transition</h3>

<pre><code>
class trivial_encoding_state_transition {};
</code></pre>

<h3 id="class_basic_execution_character_encoding">
  Class basic_execution_character_encoding</h3>

<pre><code>
class basic_execution_character_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;basic_execution_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 1;
  static constexpr int max_code_units = 1;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_basic_execution_wide_character_encoding">
  Class basic_execution_wide_character_encoding</h3>

<pre><code>
class basic_execution_wide_character_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;basic_execution_wide_character_set&gt;;
  using code_unit_type = wchar_t;

  static constexpr int min_code_units = 1;
  static constexpr int max_code_units = 1;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_iso_10646_wide_character_encoding">
  Class iso_10646_wide_character_encoding</h3>

<pre><code>
#if defined(__STDC_ISO_10646__)
class iso_10646_wide_character_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = wchar_t;

  static constexpr int min_code_units = 1;
  static constexpr int max_code_units = 1;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
#endif // __STDC_ISO_10646__
</code></pre>

<h3 id="class_utf8_encoding">
  Class utf8_encoding</h3>

<pre><code>
class utf8_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 1;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;std::make_unsigned_t&lt;code_unit_type&gt;&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;std::make_unsigned_t&lt;code_unit_type&gt;&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf8bom_encoding">
  Class utf8bom_encoding</h3>

<pre><code>
class utf8bom_encoding_state {
  /* implementation-defined */
};

class utf8bom_encoding_state_transition {
public:
  static utf8bom_encoding_state_transition to_initial_state();
  static utf8bom_encoding_state_transition to_bom_written_state();
  static utf8bom_encoding_state_transition to_assume_bom_written_state();
};

class utf8bom_encoding {
public:
  using state_type = utf8bom_encoding_state;
  using state_transition_type = utf8bom_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 1;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;std::make_unsigned_t&lt;code_unit_type&gt;&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;std::make_unsigned_t&lt;code_unit_type&gt;&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf16_encoding">
  Class utf16_encoding</h3>

<pre><code>
class utf16_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char16_t;

  static constexpr int min_code_units = 1;
  static constexpr int max_code_units = 2;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf16be_encoding">
  Class utf16be_encoding</h3>

<pre><code>
class utf16be_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 2;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf16le_encoding">
  Class utf16le_encoding</h3>

<pre><code>
class utf16le_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 2;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf16bom_encoding">
  Class utf16bom_encoding</h3>

<pre><code>
class utf16bom_encoding_state {
  /* implementation-defined */
};

class utf16bom_encoding_state_transition {
public:
  static utf16bom_encoding_state_transition to_initial_state();
  static utf16bom_encoding_state_transition to_bom_written_state();
  static utf16bom_encoding_state_transition to_be_bom_written_state();
  static utf16bom_encoding_state_transition to_le_bom_written_state();
  static utf16bom_encoding_state_transition to_assume_bom_written_state();
  static utf16bom_encoding_state_transition to_assume_be_bom_written_state();
  static utf16bom_encoding_state_transition to_assume_le_bom_written_state();
};

class utf16bom_encoding {
public:
  using state_type = utf16bom_encoding_state;
  using state_transition_type = utf16bom_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 2;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf32_encoding">
  Class utf32_encoding</h3>

<pre><code>
class utf32_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char32_t;

  static constexpr int min_code_units = 1;
  static constexpr int max_code_units = 1;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf32be_encoding">
  Class utf32be_encoding</h3>

<pre><code>
class utf32be_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 4;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf32le_encoding">
  Class utf32le_encoding</h3>

<pre><code>
class utf32le_encoding {
public:
  using state_type = trivial_encoding_state;
  using state_transition_type = trivial_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 4;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="class_utf32bom_encoding">
  Class utf32bom_encoding</h3>

<pre><code>
class utf32bom_encoding_state {
  /* implementation-defined */
};

class utf32bom_encoding_state_transition {
public:
  static utf32bom_encoding_state_transition to_initial_state();
  static utf32bom_encoding_state_transition to_bom_written_state();
  static utf32bom_encoding_state_transition to_be_bom_written_state();
  static utf32bom_encoding_state_transition to_le_bom_written_state();
  static utf32bom_encoding_state_transition to_assume_bom_written_state();
  static utf32bom_encoding_state_transition to_assume_be_bom_written_state();
  static utf32bom_encoding_state_transition to_assume_le_bom_written_state();
};

class utf32bom_encoding {
public:
  using state_type = utf32bom_encoding_state;
  using state_transition_type = utf32bom_encoding_state_transition;
  using character_type = character&lt;unicode_character_set&gt;;
  using code_unit_type = char;

  static constexpr int min_code_units = 4;
  static constexpr int max_code_units = 4;

  static const state_type&amp; initial_state();

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode_state_transition(state_type &amp;state,
                                        CUIT &amp;out,
                                        const state_transition_type &amp;stt,
                                        int &amp;encoded_code_units)

  template&lt;CodeUnitOutputIterator&lt;code_unit_type&gt; CUIT&gt;
    static void encode(state_type &amp;state,
                       CUIT &amp;out,
                       character_type c,
                       int &amp;encoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool decode(state_type &amp;state,
                       CUIT &amp;in_next,
                       CUST in_end,
                       character_type &amp;c,
                       int &amp;decoded_code_units)

  template&lt;CodeUnitIterator CUIT, typename CUST&gt;
    requires ranges::InputIterator&lt;CUIT&gt;()
          &amp;&amp; ranges::Convertible&lt;ranges::value_type_t&lt;CUIT&gt;, code_unit_type&gt;()
          &amp;&amp; ranges::Sentinel&lt;CUST, CUIT&gt;()
    static bool rdecode(state_type &amp;state,
                        CUIT &amp;in_next,
                        CUST in_end,
                        character_type &amp;c,
                        int &amp;decoded_code_units)
};
</code></pre>

<h3 id="encoding-type-aliases">
  Encoding type aliases</h3>

<pre><code>
using execution_character_encoding = /* implementation-defined */ ;
using execution_wide_character_encoding = /* implementation-defined */ ;
using char8_character_encoding = /* implementation-defined */ ;
using char16_character_encoding = /* implementation-defined */ ;
using char32_character_encoding = /* implementation-defined */ ;
</code></pre>

<h2 id="text_iterators">Text Iterators</h2>

<ul>
  <li><a href="p0244r0.html#class_template_itext_iterator">
      Class template itext_iterator</a></li>
  <li><a href="p0244r0.html#class_template_itext_sentinel">
      Class template itext_sentinel</a></li>
  <li><a href="p0244r0.html#class_template_otext_iterator">
      Class template otext_iterator</a></li>
  <li><a href="p0244r0.html#make_otext_iterator">
      make_otext_iterator</a></li>
</ul>

<h3 id="class_template_itext_iterator">
  Class template itext_iterator</h3>

<pre><code>
template&lt;TextEncoding ET, ranges::InputRange RT&gt;
  requires TextDecoder&lt;
             ET,
             ranges::iterator_t&lt;std::add_const_t&lt;std::remove_reference_t&lt;RT&gt;&gt;&gt;&gt;()
class itext_iterator {
public:
  using encoding_type = ET;
  using range_type = std::remove_reference_t&lt;RT&gt;;
  using state_type = typename encoding_type::state_type;

  using iterator = ranges::iterator_t&lt;std::add_const_t&lt;range_type&gt;&gt;;
  using iterator_category = /* implementation-defined */;
  using value_type = character_type_t&lt;encoding_type&gt;;
  using reference = std::add_const_t&lt;value_type&gt;&amp;;
  using pointer = std::add_const_t&lt;value_type&gt;*;
  using difference_type = ranges::difference_type_t&lt;iterator&gt;;

  itext_iterator();

  itext_iterator(const state_type &amp;state,
                 const range_type *range,
                 iterator first);

  reference operator*() const noexcept;
  pointer operator-&gt;() const noexcept;

  friend bool operator==(const itext_iterator &amp;l, const itext_iterator &amp;r);
  friend bool operator!=(const itext_iterator &amp;l, const itext_iterator &amp;r);

  friend bool operator&lt;(const itext_iterator &amp;l, const itext_iterator &amp;r)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();
  friend bool operator&gt;(const itext_iterator &amp;l, const itext_iterator &amp;r)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();
  friend bool operator&lt;=(const itext_iterator &amp;l, const itext_iterator &amp;r)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();
  friend bool operator&gt;=(const itext_iterator &amp;l, const itext_iterator &amp;r)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();

  itext_iterator&amp; operator++();
  itext_iterator&amp; operator++()
    requires TextForwardDecoder&lt;encoding_type, iterator&gt;();
  itext_iterator operator++(int);

  itext_iterator&amp; operator--()
    requires TextBidirectionalDecoder&lt;encoding_type, iterator&gt;();
  itext_iterator operator--(int)
    requires TextBidirectionalDecoder&lt;encoding_type, iterator&gt;();

  itext_iterator&amp; operator+=(difference_type n)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();
  itext_iterator&amp; operator-=(difference_type n)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();

  friend itext_iterator operator+(itext_iterator l, difference_type n)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();
  friend itext_iterator operator+(difference_type n, itext_iterator r)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();

  friend itext_iterator operator-(itext_iterator l, difference_type n)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();
  friend difference_type operator-(const itext_iterator &amp;l,
                                   const itext_iterator &amp;r)
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();

  value_type operator[](difference_type n) const
    requires TextRandomAccessDecoder&lt;encoding_type, iterator&gt;();

  const state_type&amp; state() const noexcept;
  state_type&amp; state() noexcept;

  iterator base() const;

  /* implementation-defined */ base_range() const
    requires TextDecoder&lt;encoding_type, iterator&gt;()
          &amp;&amp; ranges::ForwardIterator&lt;iterator&gt;();

  bool is_ok() const noexcept;

private:
  state_type base_state;  // exposition only
  iterator base_iterator; // exposition only
  bool ok;                // exposition only
};
</code></pre>

<h3 id="class_template_itext_sentinel">
  Class template itext_sentinel</h3>

<pre><code>
template&lt;TextEncoding ET, ranges::InputRange RT&gt;
class itext_sentinel {
public:
  using range_type = std::remove_reference_t&lt;RT&gt;;
  using sentinel = ranges::sentinel_t&lt;std::add_const_t&lt;range_type&gt;&gt;;

  itext_sentinel(sentinel s);

  itext_sentinel(const itext_iterator&lt;ET, RT&gt; &amp;ti)
    requires ranges::ConvertibleTo&lt;decltype(ti.base()), sentinel&gt;();

  friend bool operator==(const itext_sentinel &amp;l, const itext_sentinel &amp;r);
  friend bool operator!=(const itext_sentinel &amp;l, const itext_sentinel &amp;r);

  friend bool operator==(const itext_iterator&lt;ET, RT&gt; &amp;ti,
                         const itext_sentinel &amp;ts);
  friend bool operator!=(const itext_iterator&lt;ET, RT&gt; &amp;ti,
                         const itext_sentinel &amp;ts);
  friend bool operator==(const itext_sentinel &amp;ts,
                         const itext_iterator&lt;ET, RT&gt; &amp;ti);
  friend bool operator!=(const itext_sentinel &amp;ts,
                         const itext_iterator&lt;ET, RT&gt; &amp;ti);

  friend bool operator&lt;(const itext_sentinel &amp;l, const itext_sentinel &amp;r);
  friend bool operator&gt;(const itext_sentinel &amp;l, const itext_sentinel &amp;r);
  friend bool operator&lt;=(const itext_sentinel &amp;l, const itext_sentinel &amp;r);
  friend bool operator&gt;=(const itext_sentinel &amp;l, const itext_sentinel &amp;r);

  friend bool operator&lt;(const itext_iterator&lt;ET, RT&gt; &amp;ti,
                        const itext_sentinel &amp;ts)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();
  friend bool operator&gt;(const itext_iterator&lt;ET, RT&gt; &amp;ti,
                        const itext_sentinel &amp;ts)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();
  friend bool operator&lt;=(const itext_iterator&lt;ET, RT&gt; &amp;ti,
                         const itext_sentinel &amp;ts)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();
  friend bool operator&gt;=(const itext_iterator&lt;ET, RT&gt; &amp;ti,
                         const itext_sentinel &amp;ts)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();

  friend bool operator&lt;(const itext_sentinel &amp;ts,
                        const itext_iterator&lt;ET, RT&gt; &amp;ti)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();
  friend bool operator&gt;(const itext_sentinel &amp;ts,
                        const itext_iterator&lt;ET, RT&gt; &amp;ti)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();
  friend bool operator&lt;=(const itext_sentinel &amp;ts,
                         const itext_iterator&lt;ET, RT&gt; &amp;ti)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();
  friend bool operator&gt;=(const itext_sentinel &amp;ts,
                         const itext_iterator&lt;ET, RT&gt; &amp;ti)
    requires ranges::StrictWeakOrder&lt;
                 std::less&lt;&gt;,
                 typename itext_iterator&lt;ET, RT&gt;::iterator,
                 sentinel&gt;();

  sentinel base() const;

private:
  sentinel base_sentinel; // exposition only
};
</code></pre>

<h3 id="class_template_otext_iterator">
  Class template otext_iterator</h3>

<pre><code>
template&lt;TextEncoding E, CodeUnitOutputIterator&lt;code_unit_type_t&lt;E&gt;&gt; CUIT&gt;
class otext_iterator {
public:
  using encoding_type = E;
  using state_type = typename E::state_type;
  using state_transition_type = typename E::state_transition_type;

  using iterator = CUIT;
  using iterator_category = std::output_iterator_tag;
  using value_type = character_type_t&lt;encoding_type&gt;;
  using reference = value_type&amp;;
  using pointer = value_type*;
  using difference_type = ranges::difference_type_t&lt;iterator&gt;;

  otext_iterator();

  otext_iterator(state_type state, iterator current);

  otext_iterator&amp; operator*();

  otext_iterator&amp; operator++();
  otext_iterator&amp; operator++(int);

  otext_iterator&amp; operator=(const state_transition_type &amp;stt);
  otext_iterator&amp; operator=(const character_type_t&lt;encoding_type&gt; &amp;value);

  const state_type&amp; state() const noexcept;
  state_type&amp; state() noexcept;

  iterator base() const;

private:
  state_type base_state;  // exposition only
  iterator base_iterator; // exposition only
};
</code></pre>

<h3 id="make_otext_iterator">
  make_otext_iterator</h3>

<pre><code>
template&lt;TextEncoding ET, CodeUnitOutputIterator&lt;code_unit_type_t&lt;ET&gt;&gt; IT&gt;
  auto make_otext_iterator(typename ET::state_type state, IT out)
  -&gt; otext_iterator&lt;ET, IT&gt;;
template&lt;TextEncoding ET, CodeUnitOutputIterator&lt;code_unit_type_t&lt;ET&gt;&gt; IT&gt;
  auto make_otext_iterator(IT out)
  -&gt; otext_iterator&lt;ET, IT&gt;;
</code></pre>

<h2 id="text_view">Text View</h2>

<ul>
  <li><a href="p0244r0.html#class_template_basic_text_view">
      Class template basic_text_view</a></li>
  <li><a href="p0244r0.html#text_view_type_aliases">
      Text view type aliases</a></li>
  <li><a href="p0244r0.html#make_text_view">
      make_text_view</a></li>
</ul>

<h3 id="class_template_basic_text_view">
  Class template basic_text_view</h3>

<pre><code>
template&lt;TextEncoding ET, ranges::InputRange RT&gt;
class basic_text_view {
public:
  using encoding_type = ET;
  using range_type = RT;
  using state_type = typename ET::state_type;
  using code_unit_iterator = ranges::iterator_t&lt;std::add_const_t&lt;range_type&gt;&gt;;
  using code_unit_sentinel = ranges::sentinel_t&lt;std::add_const_t&lt;range_type&gt;&gt;;
  using iterator = itext_iterator&lt;ET, RT&gt;;
  using sentinel = itext_sentinel&lt;ET, RT&gt;;

  basic_text_view();

  basic_text_view(state_type state,
                  range_type r)
    requires ranges::CopyConstructible&lt;range_type&gt;();

  basic_text_view(range_type r)
    requires ranges::CopyConstructible&lt;range_type&gt;();

  basic_text_view(state_type state,
                  code_unit_iterator first,
                  code_unit_sentinel last)
    requires ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_sentinel&gt;();

  basic_text_view(code_unit_iterator first,
                  code_unit_sentinel last)
    requires ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_sentinel&gt;();

  basic_text_view(state_type state,
                  code_unit_iterator first,
                  ranges::difference_type_t&lt;code_unit_iterator&gt; n)
    requires ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_iterator&gt;();

  basic_text_view(code_unit_iterator first,
                  ranges::difference_type_t&lt;code_unit_iterator&gt; n)
    requires ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_iterator&gt;();

  template&lt;typename charT, typename traits, typename Allocator&gt;
    basic_text_view(state_type state,
                    const basic_string&lt;charT, traits, Allocator&gt; &amp;str)
    requires ranges::Constructible&lt;code_unit_iterator, const charT *&gt;()
          &amp;&amp; ranges::Constructible&lt;ranges::difference_type_t&lt;code_unit_iterator&gt;,
                                   typename basic_string&lt;charT, traits, Allocator&gt;::size_type&gt;()
          &amp;&amp; ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_sentinel&gt;();

  template&lt;typename charT, typename traits, typename Allocator&gt;
    basic_text_view(const basic_string&lt;charT, traits, Allocator&gt; &amp;str)
    requires ranges::Constructible&lt;code_unit_iterator, const charT *&gt;()
          &amp;&amp; ranges::Constructible&lt;ranges::difference_type_t&lt;code_unit_iterator&gt;,
                                   typename basic_string&lt;charT, traits, Allocator&gt;::size_type&gt;()
          &amp;&amp; ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_sentinel&gt;();

  template&lt;ranges::InputRange Iterable&gt;
    basic_text_view(state_type state,
                    const Iterable &amp;iterable)
    requires ranges::Constructible&lt;code_unit_iterator,
                                   ranges::iterator_t&lt;const Iterable&gt;&gt;()
          &amp;&amp; ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_sentinel&gt;();

  template&lt;ranges::InputRange Iterable&gt;
    basic_text_view(const Iterable &amp;iterable)
    requires ranges::Constructible&lt;code_unit_iterator,
                                   ranges::iterator_t&lt;const Iterable&gt;&gt;()
          &amp;&amp; ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_sentinel&gt;();

  basic_text_view(iterator first, sentinel last)
    requires ranges::Constructible&lt;code_unit_iterator,
                                   decltype(std::declval&lt;iterator&gt;().base())&gt;()
          &amp;&amp; ranges::Constructible&lt;range_type,
                                   code_unit_iterator,
                                   code_unit_sentinel&gt;();

  const range_type&amp; base() const noexcept;
  range_type&amp; base() noexcept;

  const state_type&amp; initial_state() const noexcept;
  state_type&amp; initial_state() noexcept;

  iterator begin() const;
  iterator end() const
    requires std::is_empty&lt;state_type&gt;::value
          &amp;&amp; ranges::Iterator&lt;code_unit_sentinel&gt;();
  sentinel end() const
    requires !std::is_empty&lt;state_type&gt;::value
          || !ranges::Iterator&lt;code_unit_sentinel&gt;();

private:
  state_type base_state; // exposition only
  range_type base_range; // exposition only
};
</code></pre>

<h3 id="text_view_type_aliases">
  Text view type aliases</h3>

<pre><code>
using text_view = basic_text_view&lt;
          execution_character_encoding,
          /* implementation-defined */ &gt;;
using wtext_view = basic_text_view&lt;
          execution_wide_character_encoding,
          /* implementation-defined */ &gt;;
using u8text_view = basic_text_view&lt;
          char8_character_encoding,
          /* implementation-defined */ &gt;;
using u16text_view = basic_text_view&lt;
          char16_character_encoding,
          /* implementation-defined */ &gt;;
using u32text_view = basic_text_view&lt;
          char32_character_encoding,
          /* implementation-defined */ &gt;;
</code></pre>

<h3 id="make_text_view">
  make_text_view</h3>

<pre><code>
template&lt;TextEncoding ET, ranges::InputIterator IT, ranges::Sentinel&lt;IT&gt; ST&gt;
  auto make_text_view(typename ET::state_type state,
                      IT first, ST last)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;


template&lt;TextEncoding ET, ranges::InputIterator IT, ranges::Sentinel&lt;IT&gt; ST&gt;
  auto make_text_view(IT first, ST last)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;

template&lt;TextEncoding ET, ranges::ForwardIterator IT&gt;
  auto make_text_view(typename ET::state_type state,
                      IT first,
                      ranges::difference_type_t&lt;IT&gt; n)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;

template&lt;TextEncoding ET, ranges::ForwardIterator IT&gt;
  auto make_text_view(IT first,
                      ranges::difference_type_t&lt;IT&gt; n)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;

template&lt;TextEncoding ET, ranges::InputRange Iterable&gt;
  auto make_text_view(typename ET::state_type state,
                      const Iterable &amp;iterable)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;

template&lt;TextEncoding ET, ranges::InputRange Iterable&gt;
  auto make_text_view(const Iterable &amp;iterable)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;

template&lt;TextIterator TIT, TextSentinel&lt;TIT&gt; TST&gt;
  auto make_text_view(TIT first, TST last)
  -&gt; basic_text_view&lt;ET, /* implementation-defined */ &gt;;

template&lt;TextView TVT&gt;
  TVT make_text_view(TVT tv);
</code></pre>

<h1 id="acknowledgements">Acknowledgements</h1>

Thank you to the std-proposals community and especially to Zhihao Yuan,
Jeffrey Yasskin, Thiago Macieira, and Nicol Bolas for their design feedback.

<h1 id="references">References</h1>

<table>
  <tr>
    <td id="ref_cxx11"><sup>[C++11]</sup></td>
    <td>
      "Information technology -- Programming languages -- C++", ISO/IEC 14882:2011.<br/>
      <a href="http://www.iso.org/iso/home/store/catalogue_ics/catalogue_detail_ics.htm?csnumber=50372">
      http://www.iso.org/iso/home/store/catalogue_ics/catalogue_detail_ics.htm?csnumber=50372</a></td>
  </tr>
  <tr>
    <td id="ref_concepts"><sup>[Concepts]</sup></td>
    <td>
      "C++ Extensions for concepts", ISO/IEC technical specification 19217:2015.<br/>
      <a href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=64031">
      http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=64031</a></td>
  </tr>
  <tr>
    <td id="ref_n2249"><sup>[N2249]</sup></td>
    <td>
      Lawrence Crowl,
      "New Character Types in C++", N2249, 2007.<br/>
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html">
      http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html</a></td>
  </tr>
  <tr>
    <td id="ref_n2442"><sup>[N2442]</sup></td>
    <td>
      Lawrence Crowl and Beman Dawes,
      "Raw and Unicode String Literals; Unified Proposal (Rev. 2)", N2442, 2007.<br/>
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">
      http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm</a></td>
  </tr>
  <tr>
    <td id="ref_origin"><sup>[Origin]</sup></td>
    <td>
      Andrew Sutton,
      Origin libraries.<br/>
      <a href="http://asutton.github.io/origin">
      http://asutton.github.io/origin</a></td>
  </tr>
  <tr>
    <td id="ref_proxy_iterators"><sup>[Proxy Iterators]</sup></td>
    <td>
      Eric Niebler,
      "Proxy Iterators for the Ranges Extensions", P0022R1, 2015.<br/>
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0022r1.html">
      http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0022r1.html</a></td>
  </tr>
  <tr>
    <td id="ref_ranges"><sup>[Ranges]</sup></td>
    <td>
      Eric Niebler and Casey Carter,
      "Working Draft, C++ Extensions for Ranges", N4560, 2015.<br/>
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf">
      http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf</a></td>
  </tr>
  <tr>
    <td id="ref_text_view"><sup>[Text_view]</sup></td>
    <td>
      Tom Honermann,
      Text_view library.<br/>
      <a href="https://github.com/tahonermann/text_view">
      https://github.com/tahonermann/text_view</a></td>
  </tr>
  <tr>
    <td id="ref_unicode"><sup>[Unicode]</sup></td>
    <td>
      "Unicode 8.0.0", 2015.<br/>
      <a href="http://www.unicode.org/versions/Unicode8.0.0">
      http://www.unicode.org/versions/Unicode8.0.0</a></td>
  </tr>
</table>

</body>
