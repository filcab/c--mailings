<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><title>One Concept Definition Syntax</title><style type="text/css">@import url('https://fonts.googleapis.com/css?family=Old+Standard+TT:400,400italic,700');@import url('https://themes.googleusercontent.com/fonts/css?kit=9_v4x5TuaSFoEihsz2xO3xScAYp-AoaG02dNyK0Yl2I');ol.lst-kix_n3p4e22p9buz-6.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-6 0}ol.lst-kix_bfiv2d8w0wj0-2{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-3{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-0{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-1{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-6{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-7{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-4{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-5{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-2.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-2 0}.lst-kix_53bkc3ixl3xk-5>li:before{content:"\0025a0  "}.lst-kix_53bkc3ixl3xk-6>li:before{content:"\0025cf  "}ol.lst-kix_bfiv2d8w0wj0-8{list-style-type:none}.lst-kix_53bkc3ixl3xk-4>li:before{content:"\0025cb  "}.lst-kix_53bkc3ixl3xk-8>li:before{content:"\0025a0  "}.lst-kix_hljxosjr8wl4-8>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-8}ul.lst-kix_53bkc3ixl3xk-8{list-style-type:none}ul.lst-kix_53bkc3ixl3xk-7{list-style-type:none}ul.lst-kix_53bkc3ixl3xk-6{list-style-type:none}ol.lst-kix_hljxosjr8wl4-1.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-1 0}ul.lst-kix_53bkc3ixl3xk-5{list-style-type:none}ul.lst-kix_53bkc3ixl3xk-4{list-style-type:none}ul.lst-kix_53bkc3ixl3xk-3{list-style-type:none}.lst-kix_53bkc3ixl3xk-7>li:before{content:"\0025cb  "}ul.lst-kix_53bkc3ixl3xk-2{list-style-type:none}ul.lst-kix_53bkc3ixl3xk-1{list-style-type:none}ul.lst-kix_53bkc3ixl3xk-0{list-style-type:none}.lst-kix_53bkc3ixl3xk-0>li:before{content:"\0025cf  "}.lst-kix_bfiv2d8w0wj0-0>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-0}.lst-kix_53bkc3ixl3xk-1>li:before{content:"\0025cb  "}.lst-kix_53bkc3ixl3xk-2>li:before{content:"\0025a0  "}.lst-kix_n3p4e22p9buz-0>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-0}.lst-kix_53bkc3ixl3xk-3>li:before{content:"\0025cf  "}.lst-kix_n3p4e22p9buz-8>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-8}ol.lst-kix_bfiv2d8w0wj0-7.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-7 0}ul.lst-kix_p7n6hu9fhznt-8{list-style-type:none}ul.lst-kix_p7n6hu9fhznt-7{list-style-type:none}ul.lst-kix_p7n6hu9fhznt-6{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-4.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-4 0}ul.lst-kix_p7n6hu9fhznt-5{list-style-type:none}ul.lst-kix_p7n6hu9fhznt-4{list-style-type:none}ul.lst-kix_p7n6hu9fhznt-3{list-style-type:none}ul.lst-kix_p7n6hu9fhznt-2{list-style-type:none}ul.lst-kix_p7n6hu9fhznt-1{list-style-type:none}.lst-kix_hljxosjr8wl4-6>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-6}ul.lst-kix_p7n6hu9fhznt-0{list-style-type:none}ol.lst-kix_hljxosjr8wl4-3.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-3 0}.lst-kix_n3p4e22p9buz-6>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-6,decimal) ". "}.lst-kix_n3p4e22p9buz-5>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-5,lower-roman) ". "}.lst-kix_n3p4e22p9buz-4>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-4,lower-latin) ". "}.lst-kix_n3p4e22p9buz-7>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-7,lower-latin) ". "}.lst-kix_n3p4e22p9buz-8>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-8,lower-roman) ". "}.lst-kix_n3p4e22p9buz-1>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-1}.lst-kix_hljxosjr8wl4-5>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-5}.lst-kix_n3p4e22p9buz-0>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-0,decimal) ". "}.lst-kix_bfiv2d8w0wj0-7>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-7}ol.lst-kix_bfiv2d8w0wj0-8.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-8 0}.lst-kix_n3p4e22p9buz-2>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-2,lower-roman) ". "}.lst-kix_n3p4e22p9buz-1>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-1,lower-latin) ". "}.lst-kix_n3p4e22p9buz-3>li:before{content:"" counter(lst-ctn-kix_n3p4e22p9buz-3,decimal) ". "}ol.lst-kix_n3p4e22p9buz-4.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-4 0}.lst-kix_ms732ch628h4-0>li:before{content:"\0025cf  "}.lst-kix_bfiv2d8w0wj0-0>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-0,decimal) ". "}.lst-kix_bfiv2d8w0wj0-1>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-1}.lst-kix_ms732ch628h4-2>li:before{content:"\0025a0  "}.lst-kix_bfiv2d8w0wj0-1>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-1,lower-latin) ". "}.lst-kix_bfiv2d8w0wj0-2>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-2,lower-roman) ". "}.lst-kix_ms732ch628h4-1>li:before{content:"\0025cb  "}.lst-kix_ms732ch628h4-5>li:before{content:"\0025a0  "}.lst-kix_bfiv2d8w0wj0-3>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-3,decimal) ". "}ol.lst-kix_bfiv2d8w0wj0-3.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-3 0}ol.lst-kix_hljxosjr8wl4-4.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-4 0}.lst-kix_ms732ch628h4-4>li:before{content:"\0025cb  "}.lst-kix_bfiv2d8w0wj0-4>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-4,lower-latin) ". "}.lst-kix_hljxosjr8wl4-2>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-2}.lst-kix_ms732ch628h4-3>li:before{content:"\0025cf  "}.lst-kix_bfiv2d8w0wj0-7>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-7,lower-latin) ". "}ul.lst-kix_b7gwzsoywil5-1{list-style-type:none}ul.lst-kix_b7gwzsoywil5-0{list-style-type:none}ol.lst-kix_n3p4e22p9buz-3.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-3 0}.lst-kix_bfiv2d8w0wj0-5>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-5,lower-roman) ". "}ul.lst-kix_b7gwzsoywil5-5{list-style-type:none}ul.lst-kix_b7gwzsoywil5-4{list-style-type:none}.lst-kix_bfiv2d8w0wj0-6>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-6,decimal) ". "}ul.lst-kix_b7gwzsoywil5-3{list-style-type:none}ul.lst-kix_b7gwzsoywil5-2{list-style-type:none}.lst-kix_ms732ch628h4-6>li:before{content:"\0025cf  "}ul.lst-kix_b7gwzsoywil5-8{list-style-type:none}ul.lst-kix_b7gwzsoywil5-7{list-style-type:none}ul.lst-kix_b7gwzsoywil5-6{list-style-type:none}.lst-kix_ms732ch628h4-8>li:before{content:"\0025a0  "}.lst-kix_n3p4e22p9buz-4>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-4}.lst-kix_n3p4e22p9buz-7>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-7}.lst-kix_bfiv2d8w0wj0-8>li:before{content:"" counter(lst-ctn-kix_bfiv2d8w0wj0-8,lower-roman) ". "}.lst-kix_ms732ch628h4-7>li:before{content:"\0025cb  "}.lst-kix_hljxosjr8wl4-3>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-3}ol.lst-kix_bfiv2d8w0wj0-6.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-6 0}.lst-kix_hljxosjr8wl4-8>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-8,lower-roman) ". "}ol.lst-kix_hljxosjr8wl4-8.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-8 0}.lst-kix_hljxosjr8wl4-7>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-7,lower-latin) ". "}.lst-kix_bfiv2d8w0wj0-5>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-5}.lst-kix_bfiv2d8w0wj0-4>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-4}.lst-kix_hljxosjr8wl4-4>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-4,lower-latin) ". "}.lst-kix_hljxosjr8wl4-5>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-5,lower-roman) ". "}.lst-kix_hljxosjr8wl4-2>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-2,lower-roman) ". "}.lst-kix_hljxosjr8wl4-6>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-6,decimal) ". "}.lst-kix_hljxosjr8wl4-4>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-4}.lst-kix_n3p4e22p9buz-5>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-5}ol.lst-kix_n3p4e22p9buz-7{list-style-type:none}.lst-kix_hljxosjr8wl4-3>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-3,decimal) ". "}ol.lst-kix_n3p4e22p9buz-8{list-style-type:none}ol.lst-kix_n3p4e22p9buz-5{list-style-type:none}ol.lst-kix_n3p4e22p9buz-6{list-style-type:none}ol.lst-kix_n3p4e22p9buz-5.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-5 0}.lst-kix_bfiv2d8w0wj0-3>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-3}.lst-kix_n3p4e22p9buz-6>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-6}.lst-kix_hljxosjr8wl4-0>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-0,decimal) ". "}.lst-kix_hljxosjr8wl4-1>li:before{content:"" counter(lst-ctn-kix_hljxosjr8wl4-1,lower-latin) ". "}ol.lst-kix_n3p4e22p9buz-2.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-2 0}.lst-kix_n3p4e22p9buz-3>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-3}ol.lst-kix_bfiv2d8w0wj0-1.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-1 0}ol.lst-kix_n3p4e22p9buz-8.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-8 0}ol.lst-kix_hljxosjr8wl4-5.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-5 0}ol.lst-kix_hljxosjr8wl4-2.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-2 0}.lst-kix_bfiv2d8w0wj0-6>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-6}ul.lst-kix_ms732ch628h4-4{list-style-type:none}ul.lst-kix_ms732ch628h4-5{list-style-type:none}ul.lst-kix_ms732ch628h4-2{list-style-type:none}ul.lst-kix_ms732ch628h4-3{list-style-type:none}.lst-kix_bfiv2d8w0wj0-2>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-2}ul.lst-kix_ms732ch628h4-0{list-style-type:none}ul.lst-kix_ms732ch628h4-1{list-style-type:none}.lst-kix_hljxosjr8wl4-0>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-0}ol.lst-kix_n3p4e22p9buz-1.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-1 0}ol.lst-kix_hljxosjr8wl4-2{list-style-type:none}ol.lst-kix_hljxosjr8wl4-3{list-style-type:none}ol.lst-kix_hljxosjr8wl4-4{list-style-type:none}.lst-kix_bfiv2d8w0wj0-8>li{counter-increment:lst-ctn-kix_bfiv2d8w0wj0-8}ol.lst-kix_hljxosjr8wl4-5{list-style-type:none}ol.lst-kix_hljxosjr8wl4-6{list-style-type:none}ul.lst-kix_ms732ch628h4-8{list-style-type:none}ol.lst-kix_hljxosjr8wl4-7{list-style-type:none}ol.lst-kix_hljxosjr8wl4-8{list-style-type:none}ul.lst-kix_ms732ch628h4-6{list-style-type:none}ul.lst-kix_ms732ch628h4-7{list-style-type:none}.lst-kix_n3p4e22p9buz-2>li{counter-increment:lst-ctn-kix_n3p4e22p9buz-2}.lst-kix_b7gwzsoywil5-6>li:before{content:"\0025cf  "}.lst-kix_b7gwzsoywil5-7>li:before{content:"\0025cb  "}.lst-kix_b7gwzsoywil5-8>li:before{content:"\0025a0  "}.lst-kix_b7gwzsoywil5-4>li:before{content:"\0025cb  "}.lst-kix_p7n6hu9fhznt-7>li:before{content:"\0025cb  "}.lst-kix_hljxosjr8wl4-1>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-1}.lst-kix_p7n6hu9fhznt-8>li:before{content:"\0025a0  "}ol.lst-kix_bfiv2d8w0wj0-0.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-0 0}.lst-kix_b7gwzsoywil5-5>li:before{content:"\0025a0  "}ol.lst-kix_hljxosjr8wl4-6.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-6 0}.lst-kix_p7n6hu9fhznt-2>li:before{content:"\0025a0  "}ol.lst-kix_n3p4e22p9buz-3{list-style-type:none}ol.lst-kix_bfiv2d8w0wj0-5.start{counter-reset:lst-ctn-kix_bfiv2d8w0wj0-5 0}ol.lst-kix_n3p4e22p9buz-4{list-style-type:none}.lst-kix_p7n6hu9fhznt-1>li:before{content:"\0025cb  "}.lst-kix_p7n6hu9fhznt-3>li:before{content:"\0025cf  "}ol.lst-kix_n3p4e22p9buz-1{list-style-type:none}ol.lst-kix_n3p4e22p9buz-2{list-style-type:none}.lst-kix_b7gwzsoywil5-0>li:before{content:"\0025cf  "}ol.lst-kix_n3p4e22p9buz-0{list-style-type:none}.lst-kix_p7n6hu9fhznt-6>li:before{content:"\0025cf  "}.lst-kix_hljxosjr8wl4-7>li{counter-increment:lst-ctn-kix_hljxosjr8wl4-7}.lst-kix_b7gwzsoywil5-2>li:before{content:"\0025a0  "}.lst-kix_b7gwzsoywil5-3>li:before{content:"\0025cf  "}.lst-kix_p7n6hu9fhznt-5>li:before{content:"\0025a0  "}ol.lst-kix_n3p4e22p9buz-7.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-7 0}.lst-kix_p7n6hu9fhznt-4>li:before{content:"\0025cb  "}.lst-kix_b7gwzsoywil5-1>li:before{content:"\0025cb  "}ol.lst-kix_hljxosjr8wl4-0.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-0 0}ol.lst-kix_hljxosjr8wl4-7.start{counter-reset:lst-ctn-kix_hljxosjr8wl4-7 0}ol.lst-kix_hljxosjr8wl4-0{list-style-type:none}ol.lst-kix_hljxosjr8wl4-1{list-style-type:none}.lst-kix_p7n6hu9fhznt-0>li:before{content:"\0025cf  "}ol.lst-kix_n3p4e22p9buz-0.start{counter-reset:lst-ctn-kix_n3p4e22p9buz-0 0}ol{margin:0;padding:0}table td,table th{padding:0}.c23{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:32.2pt;border-top-color:#000000;border-bottom-style:solid}.c22{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:399.8pt;border-top-color:#000000;border-bottom-style:solid}.c37{border-right-style:solid;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:147pt;border-top-color:#000000;border-bottom-style:solid}.c42{border-right-style:solid;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:72.8pt;border-top-color:#000000;border-bottom-style:solid}.c19{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Old Standard TT";font-style:normal}.c20{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Old Standard TT";font-style:normal}.c40{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:9pt;font-style:normal}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c36{border-spacing:0;border-collapse:collapse;margin-right:auto}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:right}.c31{margin-left:36pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c29{padding-top:0pt;padding-bottom:0pt;text-align:left}.c4{margin-left:72pt;orphans:2;widows:2}.c13{orphans:2;widows:2;height:11pt}.c39{padding-top:0pt;padding-bottom:0pt;text-align:center}.c3{margin-left:54pt;orphans:2;widows:2}.c32{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{margin-left:36pt;orphans:2;widows:2}.c0{font-size:10pt;font-family:"Consolas";color:#1fa15d}.c14{orphans:2;widows:2}.c35{width:33%;height:1px}.c43{font-size:14pt;color:#000000}.c9{color:inherit;text-decoration:inherit}.c16{color:#cc0000;text-decoration:line-through}.c34{padding:0;margin:0}.c18{height:0pt}.c8{font-family:"Consolas"}.c27{page-break-after:avoid}.c10{color:#1fa15d}.c28{line-height:1.0}.c26{text-indent:36pt}.c7{font-size:10pt}.c17{margin-left:108pt}.c33{margin-left:18pt}.c2{vertical-align:sub}.c25{height:11pt}.c15{text-decoration:underline}.c30{font-family:"Times New Roman"}.c21{font-weight:bold}.c38{margin-left:36pt}.c41{font-size:9pt}.c1{font-style:italic}.c44{text-indent:72pt}.c24{color:#1155cc}.c12{padding-left:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Old Standard TT";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Old Standard TT"}p{margin:0;color:#000000;font-size:11pt;font-family:"Old Standard TT"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Old Standard TT";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Old Standard TT";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Old Standard TT";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Old Standard TT";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Old Standard TT";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Old Standard TT";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c32"><div><p class="c13"><span></span></p></div><p class="c13"><span></span></p><a id="t.7d0eb08970c5c16f233b17020a274d1f30d6e795"></a><a id="t.0"></a><table class="c36"><tbody><tr class="c18"><td class="c42" colspan="1" rowspan="1"><p class="c39 c28"><span class="c19">Doc. no.</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c28 c29"><span class="c19">P0324R0</span></p></td></tr><tr class="c18"><td class="c42" colspan="1" rowspan="1"><p class="c39 c28"><span class="c19">Date</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c29 c28"><span class="c19">2016-05-04</span></p></td></tr><tr class="c18"><td class="c42" colspan="1" rowspan="1"><p class="c39 c28"><span class="c19">Reply-to</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c29 c28"><span class="c41">Zhihao Yuan </span><span class="c30 c41">&lt;</span><span class="c15 c41 c24"><a class="c9" href="mailto:zy@miator.net">zy@miator.net</a></span><span class="c30 c40">&gt;</span></p></td></tr><tr class="c18"><td class="c42" colspan="1" rowspan="1"><p class="c28 c39"><span class="c19">Audience</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c29 c28"><span class="c19">Evolution Working Group</span></p></td></tr></tbody></table><p class="c13"><span></span></p><p class="c14 c27 title" id="h.ukyv0ga9mlxk"><span>One Concept Definition Syntax</span></p><p class="c13"><span></span></p><p class="c14 c33"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.3cbt4smv1pgn">Summary</a></span></p><p class="c14 c33"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.esw7zog53zxq">Introduction</a></span></p><p class="c14 c33"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.lytpwgog8oo">Discussion</a></span></p><p class="c6"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.oor3pmnyh0w3">An issue or a non-issue?</a></span></p><p class="c6"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.8vznd7hd99h7">Overload or not?</a></span></p><p class="c6"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.fuus8dxocerh">A wording issue or a vocabulary issue?</a></span></p><p class="c14 c33"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.5lea52bym420">Approaches Considered</a></span></p><p class="c14 c33"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.k6cs350tmf">Acknowledgements</a></span></p><p class="c14 c33"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.8ylk2njaghk">References</a></span></p><p class="c14 c33"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.byhoo1nfuhi6">Appendix: Sample Wordings</a></span></p><p class="c6"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.zberycpykp21">Alternative I</a></span></p><p class="c3"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.d409nuanzzyd">14.5.8 &nbsp;Concepts</a></span></p><p class="c6"><span class="c15 c24"><a class="c9" href="p0324r0.html#h.w3sngykjb9k4">Alternative II</a></span></p><h2 class="c14 c27" id="h.3cbt4smv1pgn"><span>Summary</span></h2><p class="c6"><span>We propose to replace the function-style concept and the variable-style concept in the current Concepts TS[1] with one form,</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">template &lt;typename T, typename U&gt;</span></p><p class="c4"><span class="c8 c7">concept SwappableWith = Swappable&lt;T&gt; &amp;&amp; &hellip; ;</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c6"><span>without allowing the concepts to be overloaded.</span></p><h2 class="c14 c27" id="h.esw7zog53zxq"><span>Introduction</span></h2><p class="c6"><span>Concepts TS</span><span>&nbsp;specifies two forms of concept definitions:</span></p><p class="c13"><span></span></p><p class="c6"><span>Function concept:</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">template &lt;typename T&gt;</span></p><p class="c4"><span class="c8 c7">concept bool FC() {</span></p><p class="c4"><span class="c8 c7">&nbsp; &nbsp; return </span><span class="c7 c1">constraint-expression</span><span class="c8 c7">;</span></p><p class="c4"><span class="c8 c7">}</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c6"><span>Variable concept:</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">template &lt;typename T&gt;</span></p><p class="c4"><span class="c8 c7">concept bool VC = </span><span class="c7 c1">constraint-expression</span><span class="c8 c7">;</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c6"><span>To an end-user of the concepts, in some circumstances, these two forms unavoidably bring out different interfaces:</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">template &lt;typename T&gt;</span></p><p class="c4"><span class="c8 c7">&nbsp; &nbsp; requires FC&lt;T&gt;() &amp;&amp; VC&lt;T&gt;</span></p><p class="c4"><span class="c8 c7">void f();</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c6"><span>This mandates a strong coupling among libraries, users, and library specifications[13]:</span></p><p class="c13"><span></span></p><ul class="c34 lst-kix_53bkc3ixl3xk-0 start"><li class="c4 c12"><span>Users of a library that provides concept definitions must be aware of the form in which the concepts are defined in advance before using them (other than as a </span><span class="c1">constrained-type-specifier</span><span>).</span></li></ul><p class="c13"><span></span></p><ul class="c34 lst-kix_53bkc3ixl3xk-0"><li class="c4 c12"><span>Library specifications must dictate the form in which a concept definition is provided and implementers must adhere to the specified form.</span></li></ul><p class="c13"><span></span></p><ul class="c34 lst-kix_53bkc3ixl3xk-0"><li class="c4 c12"><span>Changing a concept definition from one form to the other breaks source compatibility. &nbsp;Overloading is not supported for variable concepts, so a desire to provide an overloaded concept definition might motivate such a change.</span></li></ul><p class="c13"><span></span></p><p class="c6"><span>Due to these usability and maintenance concerns, Ranges TS[2] switched to using only function concept. &nbsp;As the concerns become real, we look for a solution in this paper.</span></p><h2 class="c14 c27" id="h.lytpwgog8oo"><span>Discussion</span></h2><h3 class="c14 c27" id="h.oor3pmnyh0w3"><span class="c21">An issue or a non-issue?</span></h3><p class="c6"><span>One can argue that the problem we faced is a non-issue, since the same issue happens to, for example, data member v.s. member function. &nbsp;The users need to know in which form the accessor is defined in advance to use it, and we cannot &ldquo;upgrade&rdquo; a variable to a function without breaking source compatibility &ndash; a true story is that we cannot make </span><span class="c8 c7">std::pair</span><span>&nbsp;benefit from EBO since it requires the member functions </span><span class="c8 c7">first()</span><span>&nbsp;and </span><span class="c8 c7">second()</span><span>.</span></p><p class="c13"><span></span></p><p class="c6"><span>We can keep elaborating this argument. &nbsp;However, such an argument is based on the following premise: function and variable are the right abstractions to model a Concept. &nbsp;Let&rsquo;s recall the definition of Concepts in &ldquo;The Palo Alto&rdquo; report[3]:</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>Concepts are a kind of </span><span class="c1">type predicate</span><span>&nbsp;that determine whether their type (or non-type) arguments satisfy a set of requirements.</span></p><p class="c4 c25"><span></span></p><p class="c6"><span>A type predicate is a type function to return &ldquo;true&rdquo; or &ldquo;false&rdquo;, where the </span><span class="c1">type function</span><span>&nbsp;is defined as:</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>[&hellip;] a compile-time function where at least one argument or the result is a type.</span></p><p class="c4 c25"><span></span></p><p class="c6"><span>So a Concept is a type function. &nbsp;We compare the abstractions, namely function concept and variable concept, against this quiddity. &nbsp;Is a variable concept a type function? &nbsp;Yes, as it forms a mapping from types to </span><span class="c8 c7">true</span><span>&nbsp;or </span><span class="c8 c7">false</span><span>. &nbsp;But the word &ldquo;variable&rdquo; in its name is not contributing to the fact that it is a function under the definition of a type function. &nbsp;Similarly, in a function concept, the function arguments are not being used to fulfill the role of a type function. &nbsp;Thus, a function concept is a Concept not because it is a C</span><span class="c30">++</span><span>&nbsp;function, and a variable concept is a Concept while being a C</span><span class="c30">++</span><span>&nbsp;variable does not affect its essence of being a type function. &nbsp;Therefore, the notions of function concept and variable concept are unrelated to the quiddity of Concepts.</span></p><p class="c13 c38"><span></span></p><p class="c6"><span>But why this distinction exists? &nbsp;We look back into the history of writing type functions in C</span><span class="c30">++</span><span>. &nbsp;At the beginning, class templates are being used to represent type functions, where are called </span><span class="c1">type traits</span><span>. &nbsp;In C</span><span class="c30">++14</span><span>, alias templates are being used to simplify the transformation traits[4], and in the coming C</span><span class="c30">++17</span><span>, variable templates are being used to simplify the predicate traits[5]. &nbsp;That is to say, all kinds of C</span><span class="c30">++</span><span>&nbsp;templates &ndash; class templates, function templates, variable templates, and alias templates, may represent a type function. &nbsp;As a matter of fact, the author of the concepts-lite proposal experimented the idea to allow class templates and alias templates being used as Concepts[6], and chose function templates and variable templates mostly for technical reasons</span><sup><a href="p0324r0.html#ftnt1" id="ftnt_ref1">[1]</a></sup><span>.</span></p><p class="c13 c38"><span></span></p><p class="c6"><span>In other words, the notions of function concept and variable concept are acceptable representations rather than right abstractions.</span></p><p class="c13 c38"><span></span></p><p class="c6"><span>Keep refering to a concept by its representation rather than its meaning creates confusions, causes issues in practice, and does harm to the acceptance of the concept. &nbsp;We therefore propose to define Concepts using a dedicated form.</span></p><h3 class="c14 c27" id="h.8vznd7hd99h7"><span class="c21">Overload or not?</span></h3><p class="c6"><span>The current function-style concept can supersede the variable-style concept since only the former allows overloading the concept definitions, so it is a safe move for the existing libraries (Ranges TS and the text_view library[7], for instance) only use the function-style concepts. &nbsp;We like the basic syntax of the variable-style concept and considered adding overloading support to it, and it turns out that we </span><span>had</span><span>&nbsp;some misconceptions about this feature:</span></p><p class="c13"><span></span></p><ul class="c34 lst-kix_ms732ch628h4-0 start"><li class="c4 c12"><span>Overloading on the template parameter kinds (type, non-type, template) are ambiguous for the prototype parameter:</span></li></ul><p class="c14 c17"><span class="c8 c7"><br>template&lt;typename T&gt; concept bool C() { return true; }</span></p><p class="c14 c17"><span class="c8 c7">template&lt;int N&gt; concept bool C() { return true; }</span></p><p class="c14 c17"><span class="c8 c7">template&lt;C c&gt; void f(); &nbsp;</span><span class="c7 c1">// ill-formed</span></p><p class="c13 c17"><span class="c8 c7"></span></p><ul class="c34 lst-kix_ms732ch628h4-0"><li class="c4 c12"><span>Overloading on the kinds of types are not supported. &nbsp;Function parameter list is the only place to specify the candidate </span><span class="c1">type constructors</span><span>&nbsp;(</span><span class="c8 c7">T</span><span>&nbsp;&rarr; </span><span class="c8 c7">T*</span><span>, for instance), and requires passing function arguments, which are available to neither the function-style nor the variable-style concept.</span></li></ul><p class="c13"><span></span></p><ul class="c34 lst-kix_ms732ch628h4-0"><li class="c4 c12"><span>Overloading on the arity of a concept cause</span><span>s</span><span>&nbsp;confusions, since the Concepts TS supports partial application of a concept in</span><span>&nbsp;</span><span class="c1">constrained-type-specifier</span><span>&nbsp;at the same time</span><sup><a href="p0324r0.html#ftnt2" id="ftnt_ref2">[2]</a></sup><span>:</span></li></ul><p class="c4 c26 c25"><span class="c8 c7"></span></p><p class="c4 c26"><span class="c7 c1">// a type </span><span class="c8 c7">U</span><span class="c7 c1">&nbsp;such that</span><span class="c8 c7">&nbsp;EqualityComparable&lt;T, U&gt;</span></p><p class="c4 c26"><span class="c8 c7">template &lt;EqualityComparable&lt;T&gt; U&gt;</span></p><p class="c4 c25 c26"><span class="c8 c7"></span></p><p class="c4 c26"><span class="c7 c1">// a </span><span class="c8 c7">bool</span><span class="c7 c1">&nbsp;indicating whether </span><span class="c8 c7">T</span><span class="c7 c1">&nbsp;is equality comparable with itself</span></p><p class="c4 c26"><span class="c8 c7">template &lt;typename T&gt; requires EqualityComparable&lt;T&gt;</span></p><p class="c4 c26 c25"><span class="c8 c7"></span></p><p class="c13"><span></span></p><p class="c6"><span>For the last one, we suggest to rename the binary concepts </span><span class="c8 c7">EqualityComparable</span><span>&nbsp;to </span><span class="c8 c7">EqualityComparableWith</span><span>, and </span><span class="c8 c7">Swappable</span><span>&nbsp;to </span><span class="c8 c7">SwappableWith</span><span>&nbsp;in Ranges TS. &nbsp;This naming convention follows the new C</span><span class="c30">++17</span><span>&nbsp;traits </span><span class="c8 c7">is_swappable</span><span>&nbsp;and </span><span class="c8 c7">is_swappable_with</span><span>[8]. &nbsp;Similarly, overloading a function-style concept with a non-concept function or function template can use naming conventions to disambiguate, such as capitalizing the concept but not the others, or use different namespaces.</span></p><p class="c13"><span></span></p><p class="c6"><span>In summary, the only significant part of this feature is overloading on arities, which is not necessary, and sometimes beneficial if not being used. &nbsp;Therefore we propose not to make the concept definitions overloadable.</span></p><p class="c13"><span></span></p><p class="c6"><span>Notably, without overloadable concept definitions, the new section &ldquo;Resolution of qualified references to concepts&rdquo; (14.10.4 [temp.constr.resolve]) will be unnecessary, as we can fully rely on the existing name lookup rules.</span></p><h3 class="c14 c27" id="h.fuus8dxocerh"><span class="c21">A wording issue or a </span><span class="c21">vocabulary</span><span class="c21">&nbsp;issue?</span></h3><p class="c6"><span>Multiple parties raised this issue[9][10], and came up with the same design, but it is the first time we try to formalize such a design. &nbsp;The syntax of this design</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">template &lt;typename T&gt;</span></p><p class="c4"><span class="c8 c7">concept ConceptName = SomeConcept&lt;T&gt; &amp;&amp; expr;</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c6"><span>is suitable for defining concept as a new kind of entity rather than a variable template declared by a </span><span class="c8 c7">concept</span><span>&nbsp;keyword, and </span><span>we do hear people, including some implementers, expressed the desire to make concept a first-class entity in the language. &nbsp;Notably, while we keep talking about &ldquo;Concepts&rdquo;, the Concepts TS is not adding a section titled &ldquo;Concepts&rdquo; to the standard. &nbsp;We totally understand that the core semantics of this feature are template constraints as described in the section of the same name, but one can argue that it would be beneficial in terms of education and communication if we can refer to the standard for the vocabulary &ldquo;concept&rdquo;, without being warned that:</span></p><p class="c13"><span></span></p><ul class="c34 lst-kix_p7n6hu9fhznt-0 start"><li class="c4 c12"><span>It must have an equal-initializer.</span></li><li class="c4 c12"><span>A variable template of the same name may not be forward declared[11].</span></li><li class="c4 c12"><span>It cannot declare a partial specialization of a variable template[12].</span></li><li class="c4 c12"><span>It cannot be explicitly instantiated or explicitly or partially specialized</span><sup><a href="p0324r0.html#ftnt3" id="ftnt_ref3">[3]</a></sup><span>.</span></li><li class="c4 c12"><span>Unlike a &ldquo;regular&rdquo; variable template, its address cannot be taken</span><sup><a href="p0324r0.html#ftnt4" id="ftnt_ref4">[4]</a></sup><span>.</span></li></ul><p class="c13"><span></span></p><p class="c6"><span>This paper is not proposing a particular way to specify the concept definition in the TS. &nbsp;Instead, we present all the approaches that we have considered in the section below.</span></p><h2 class="c14 c27" id="h.5lea52bym420"><span>Approaches Considered</span></h2><ol class="c34 lst-kix_n3p4e22p9buz-0 start" start="1"><li class="c6 c12"><span class="c21">Keep </span><span class="c8 c7 c21">concept</span><span class="c21">&nbsp;as a </span><span class="c21 c1">decl-specifier</span><span class="c21">.</span></li></ol><p class="c13"><span></span></p><p class="c6"><span>So that we only need to drop the function-style concept. &nbsp;The problem is that, given the existing grammar, it is not possible to make the </span><span class="c1">type-specifier</span><span>&nbsp;</span><span class="c8 c7">bool</span><span>&nbsp;came after the </span><span class="c8 c7">concept</span><span>&nbsp;keyword optional or removed.</span></p><p class="c13"><span></span></p><ol class="c34 lst-kix_n3p4e22p9buz-0" start="2"><li class="c6 c12"><span class="c21">Make </span><span class="c8 c7 c21">concept</span><span class="c21">&nbsp;a </span><span class="c21 c1">simple-type-specifier</span><span class="c21">.</span></li></ol><p class="c6"><span><br>So that the </span><span class="c8 c7">bool</span><span>&nbsp;may be optional or removed. &nbsp;This approach meets our expected &ldquo;reasonable&rdquo; usage from an end-user&rsquo;s point of view with minimal changes to the existing TS. &nbsp;However, some of the users deem this approach &ldquo;an implementation technique put into the standard&rdquo;.</span></p><p class="c6"><span><br>The sample wording &ldquo;Alternative II&rdquo; </span><span>partially </span><span>illustrated this approach.</span></p><p class="c13"><span></span></p><ol class="c34 lst-kix_n3p4e22p9buz-0" start="3"><li class="c6 c12"><span class="c21">Define a new </span><span class="c21 c1">concept-definition</span><span class="c21">&nbsp;as an alternative for </span><span class="c21 c1">template-declaration</span><span class="c21">.</span></li></ol><p class="c13"><span></span></p><p class="c4"><span class="c1">template-declaration:</span></p><p class="c4"><span>&nbsp; &nbsp;</span><span class="c8 c7">template &lt;</span><span>&nbsp;</span><span class="c1">template-parameter-list</span><span>&nbsp;</span><span class="c8 c7">&gt;</span><span>&nbsp;</span><span class="c15 c1">requires-clause</span><span class="c2 c15 c1">opt</span><span>&nbsp;</span><span class="c1">declaration</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;</span><span class="c15 c1">concept-definition</span></p><p class="c4 c25"><span class="c1"></span></p><p class="c4"><span class="c1">concept-definition</span><span class="c1">:</span></p><p class="c4"><span>&nbsp; &nbsp;</span><span class="c8 c7">template &lt;</span><span>&nbsp;</span><span class="c1">template-parameter-list</span><span>&nbsp;</span><span class="c8 c7">&gt; concept</span><span>&nbsp;</span><span class="c1">concept-name</span><span>&nbsp;</span><span class="c8 c7">=</span><span>&nbsp;</span><span class="c1">constraint-expression</span><span>&nbsp;</span><span class="c8 c7">;</span></p><p class="c13"><span></span></p><p class="c6"><span>So that it is grammatically not possible to form a concept definition outside templates, and we can define c</span><span>oncepts </span><span>as separate entities. &nbsp;But many template mechanisms are defined in terms of the </span><span class="c1">declaration</span><span>&nbsp;sub-production, which requires extra efforts to make this approach work.</span></p><p class="c13"><span></span></p><ol class="c34 lst-kix_n3p4e22p9buz-0" start="4"><li class="c6 c12"><span class="c21">Define 3) in terms of an &ldquo;implicitly-defined variable template&rdquo;.</span></li></ol><p class="c13"><span></span></p><p class="c6"><span>By saying that a concept in the form of</span></p><p class="c13"><span></span></p><p class="c4"><span class="c8 c7">template &lt;</span><span>&nbsp;</span><span class="c1">template-parameter-list</span><span>&nbsp;</span><span class="c8 c7">&gt;</span></p><p class="c4"><span class="c8 c7">concept</span><span>&nbsp;</span><span class="c1">concept-name</span><span>&nbsp;</span><span class="c8 c7">=</span><span>&nbsp;</span><span class="c1">constraint-expression</span><span>&nbsp;</span><span class="c8 c7">;</span></p><p class="c13"><span></span></p><p class="c6"><span>implicitly defines a variable template in the form of</span></p><p class="c13"><span></span></p><p class="c4"><span class="c8 c7">template &lt;</span><span>&nbsp;</span><span class="c1">template-parameter-list</span><span>&nbsp;</span><span class="c8 c7">&gt;</span></p><p class="c4"><span class="c8 c7">constexpr bool</span><span>&nbsp;</span><span class="c1">concept-name</span><span>&nbsp;</span><span class="c8 c7">=</span><span>&nbsp;</span><span class="c1">constraint-expression</span><span>&nbsp;</span><span class="c8 c7">;</span></p><p class="c13"><span></span></p><p class="c6"><span>we can forward the rules for the concept definition such as linkage and name looku</span><span>p </span><span>to this variable template. &nbsp;But this still looks like &ldquo;an implementation technique in the standard&rdquo;, and since it is not a pure syntactic translation like the &ldquo;range-based </span><span class="c8 c7">for</span><span>&rdquo; case, the specification is not easy enough to understand as expected.</span></p><p class="c13"><span></span></p><p class="c6"><span>This approach has been obsoleted.</span></p><p class="c13"><span></span></p><ol class="c34 lst-kix_n3p4e22p9buz-0" start="5"><li class="c6 c12"><span class="c21">Define a new </span><span class="c21 c1">concept-declaration</span><span class="c21">&nbsp;which may only appear in a template.</span></li></ol><p class="c13"><span></span></p><p class="c4"><span class="c1">block-declaration:</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;&hellip;</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;alias-declaration</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;</span><span class="c15 c1">concept-declaration</span></p><p class="c4 c25"><span class="c1"></span></p><p class="c4"><span class="c1">concept-declaration:</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;</span><span class="c8 c7">concept</span><span class="c1">&nbsp;identifier </span><span class="c8 c7">=</span><span class="c1">&nbsp;constraint-expression </span><span class="c8 c7">;</span></p><p class="c13"><span></span></p><p class="c6"><span>The idea comes from alias templates, with a difference such that an </span><span class="c1">alias-declaration</span><span>&nbsp;outside a template is valid but a concept declaration outside a template has to be forbidden. &nbsp;Since the grammar of templates is untouched, the template mechanisms defined in terms of the </span><span class="c1">declaration</span><span>&nbsp;sub-production work out-of-box, and the kind-specific (function, class, alias, etc.) template mechanisms such as instantiations, explicit and partial specializations do not apply, which match perfectly with what we need for a concept definition.</span></p><p class="c13"><span></span></p><p class="c6"><span>The sample wording &ldquo;Alternative I&rdquo; illustrated this approach.</span></p><p class="c13"><span></span></p><ol class="c34 lst-kix_n3p4e22p9buz-0" start="6"><li class="c6 c12"><span class="c21">Open a new Clause, namely Concepts [concept].</span></li></ol><p class="c13"><span></span></p><p class="c6"><span>This is the ultimate thing we may be able to do in the standard, defining concept as a &ldquo;true&rdquo; first-class entity. &nbsp;The concept definition will be a new kind of declaration in [basic]; </span><span class="c1">concept-name</span><span>&nbsp;will be a new kind of name, so that the name lookup rules need to be </span><span>updated</span><span>; and linkage of a concept needs to be specified since concept is not template. &nbsp;This clause also needs to specify or repeat the necessary template-like mechanisms.</span></p><p class="c13"><span></span></p><p class="c6"><span>However, the most significant changes brought by the Concepts TS are in 14.10 [temp.constr], so a Concepts clause may not bring much new information, thus it may not worth that much significance in the standard document.</span></p><h2 class="c14 c27" id="h.k6cs350tmf"><span>Acknowledgements</span></h2><p class="c6"><span>Thanks to Richard Smith, Tom Honermann, and Andrew Sutton for joining the discussion to form this paper.</span></p><h2 class="c14 c27" id="h.8ylk2njaghk"><span>References</span></h2><a id="t.a0bcfae8744434011faa5c5ec6c07e9464aa32b5"></a><a id="t.1"></a><table class="c31"><tbody><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[1]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Andrew Sutton, Ed., N4553 </span><span class="c1">Working Draft, C</span><span class="c30 c1">++</span><span class="c1">&nbsp;extensions for Concepts</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4553.pdf&amp;sa=D&amp;ust=1462407616874000&amp;usg=AFQjCNFJU9_cqMZ5asZjrXaVrs3QZ4PuAw">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4553.pdf</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[2]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>E. Niebler and C. Carter, Eds., N4569 </span><span class="c1">Working Draft, C</span><span class="c30 c1">++</span><span class="c1">&nbsp;Extensions for Ranges</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4569.pdf&amp;sa=D&amp;ust=1462407616877000&amp;usg=AFQjCNEp6XzIa22QQr1hGH_ELJgiT4O5Ig">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4569.pdf</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[3]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>B. Stroustrup and A. Sutton, Eds., N3351 </span><span class="c1">A Concept Design for the STL</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf&amp;sa=D&amp;ust=1462407616879000&amp;usg=AFQjCNGUHlu503X5Jk7jlztEMKoi7DRM7g">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[4]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Walter E. Brown, N3655 </span><span class="c1">TransformationTraits Redux, v2</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf&amp;sa=D&amp;ust=1462407616882000&amp;usg=AFQjCNE3-N97GyewVNbYWeuoVwGxxrCQZw">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[5]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Stephan T. Lavavej, N3854 </span><span class="c1">Variable Templates For Type Traits</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3854.htm&amp;sa=D&amp;ust=1462407616885000&amp;usg=AFQjCNE9PFcxDbBFGzMdJOPvLuv0faOCtA">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3854.htm</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[6]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Andrew Sutton, In reply to </span><span class="c1">&quot;Why alias template can not be concept? &quot;</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=https://groups.google.com/a/isocpp.org/d/msg/concepts/fALMCb1uJrU/BbaM_EOUsbcJ&amp;sa=D&amp;ust=1462407616887000&amp;usg=AFQjCNGwB9zAmv-oxsLSkrc59_ze9Mvuig">https://groups.google.com/a/isocpp.org/d/msg/concepts/fALMCb1uJrU/BbaM_EOUsbcJ</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[7]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Tom Honermann, P0244R0 </span><span class="c1">Text_view: A C</span><span class="c1 c30">++</span><span class="c1">&nbsp;concepts and range based character encoding and code point enumeration library</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0244r0.html&amp;sa=D&amp;ust=1462407616890000&amp;usg=AFQjCNFpaSMqnDchDudeSuyBgsTKt_4CgA">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0244r0.html</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[8]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Daniel Kr&uuml;gler, P0185R1 </span><span class="c1">Adding [nothrow-]swappable traits, revision 3</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0185r1.html&amp;sa=D&amp;ust=1462407616893000&amp;usg=AFQjCNFr2KpL6fpE5skCbRV9z2d6J453SA">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0185r1.html</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[9]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Walter E. Brown, EWG 182 </span><span class="c1">N4434 Tweaks to Streamline Concepts Lite Syntax, other Concepts TS issues</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://cplusplus.github.io/EWG/ewg-active.html%23182&amp;sa=D&amp;ust=1462407616895000&amp;usg=AFQjCNGqMQdJ2sLH_TOJTgk0a0LiX7UX7w">http://cplusplus.github.io/EWG/ewg-active.html#182</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[10]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Walter E. Brown, N4434 </span><span class="c1">Tweaks to Streamline Concepts Lite Syntax</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4434.pdf&amp;sa=D&amp;ust=1462407616898000&amp;usg=AFQjCNHeIdcS8s7FXEAhyVLH4-vg1BNJ9A">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4434.pdf</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[11]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Hubert Tong, Concepts issue 16 </span><span class="c1">Concept and non-concept declarations of the same variable template</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://cplusplus.github.io/concepts-ts/ts-active.html%2316&amp;sa=D&amp;ust=1462407616900000&amp;usg=AFQjCNEhp043nTCesKLdrbLkXfuMf8mVCg">http://cplusplus.github.io/concepts-ts/ts-active.html#16</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[12]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Hubert Tong, Concepts issue 15 </span><span class="c1">Partial specialization of non-concept variable template as a concept definition</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://cplusplus.github.io/concepts-ts/ts-active.html%2315&amp;sa=D&amp;ust=1462407616903000&amp;usg=AFQjCNEzFZ4E0KZKEbS1SAp0t8sxfHnqcw">http://cplusplus.github.io/concepts-ts/ts-active.html#15</a></span></p></td></tr><tr class="c18"><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c20">[13]</span></p></td><td class="c22" colspan="1" rowspan="1"><p class="c11"><span>Tom Honermann, </span><span class="c1">Refining Concepts: The quiddity of concept definitions</span><span>. &nbsp;</span><span class="c15 c24"><a class="c9" href="https://www.google.com/url?q=http://honermann.net/blog/2016/03/24/refining-concepts-the-quiddity-of-concept-definitions/&amp;sa=D&amp;ust=1462407616906000&amp;usg=AFQjCNGyQ3GeTZmn6dl1L-4puv7hCLqmAw">http://honermann.net/blog/2016/03/24/refining-concepts-the-quiddity-of-concept-definitions/</a></span></p></td></tr></tbody></table><p class="c13"><span></span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span></span></p><h2 class="c14 c27" id="h.byhoo1nfuhi6"><span>Appendix: Sample Wordings</span></h2><p class="c6"><span>For editorial convenience, the sample wordings are not equal. &nbsp;Common instructions go into &ldquo;Alternative I&rdquo; and are not repeated in &ldquo;Alternative II&rdquo;. &nbsp;The author can create a wording based on either one.</span></p><h3 class="c14 c27" id="h.zberycpykp21"><span>Alternative I</span></h3><p class="c14"><span>Issues fixed: concepts-ts 6, 7, 8, 15, 16, 22, 29 (N4434 cleared).</span></p><p class="c14"><span>Issues closed: concepts-ts 19, 20, 25, 26, 27.</span></p><p class="c13"><span></span></p><p class="c14"><span>This wording is relative to N4553, Working Draft, C</span><span class="c30">++</span><span>&nbsp;extensions for Concepts.</span></p><p class="c13"><span></span></p><p class="c14"><span>Revert the following instruction applied to chapter 7.1 [dcl.spec]:</span></p><p class="c13"><span></span></p><p class="c14 c26"><span>Extend the </span><span class="c1">decl-specifier</span><span>&nbsp;production in paragraph 1 to include the </span><span class="c8 c7">concept</span><span>&nbsp;specifier.</span></p><p class="c13"><span></span></p><p class="c14"><span>Revert the new section 7.1.7 [dcl.spec.concept].</span></p><p class="c13"><span></span></p><p class="c14"><span>Add the following instruction:</span></p><p class="c13"><span></span></p><p class="c14 c26"><span>Extend the </span><span class="c1">block-declaration</span><span>&nbsp;production to include a </span><span class="c1">concept-declaration</span><span>:</span></p><p class="c13"><span></span></p><p class="c4"><span class="c1">block-declaration:</span></p><p class="c4"><span class="c1">&nbsp; simple-declaration</span></p><p class="c4"><span class="c1">&nbsp; asm-definition</span></p><p class="c4"><span class="c1">&nbsp; namespace-alias-definition</span></p><p class="c4"><span class="c1">&nbsp; using-declaration</span></p><p class="c4"><span class="c1">&nbsp; using-directive</span></p><p class="c4"><span class="c1">&nbsp; static_assert-declaration</span></p><p class="c4"><span class="c1">&nbsp; alias-declaration</span></p><p class="c4"><span class="c10 c1">&nbsp; concept-declaration</span></p><p class="c4"><span class="c1">&nbsp; opaque-enum-declaration</span></p><p class="c4 c25"><span class="c1"></span></p><p class="c4"><span class="c1">nodeclspec-function-declaration:</span></p><p class="c4"><span class="c1">&nbsp; attribute-specifier-seq</span><span class="c2 c1">opt</span><span class="c1">&nbsp;declarator </span><span class="c8 c7">;</span></p><p class="c4 c25"><span class="c1"></span></p><p class="c4"><span class="c1">alias-declaration:</span></p><p class="c4"><span class="c1">&nbsp; </span><span class="c8 c7 c1">using</span><span class="c1">&nbsp;identifier attribute-specifier-seq</span><span class="c1 c2">opt</span><span class="c1">&nbsp;</span><span class="c8 c7">=</span><span class="c1">&nbsp;type-id </span><span class="c8 c7">;</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c10 c1">concept-declaration:</span></p><p class="c4"><span class="c10 c1">&nbsp; </span><span class="c0">concept</span><span class="c10 c1">&nbsp;identifier </span><span class="c0">=</span><span class="c1 c10">&nbsp;constraint-expression </span><span class="c0">;</span></p><p class="c13"><span></span></p><p class="c14"><span>Modify the instruction applying to Clause 14 [temp] as follows:</span></p><p class="c13"><span></span></p><p class="c6"><span>Modify </span><span class="c16">the </span><span class="c16 c1">template-declaration</span><span class="c16">&nbsp;grammar in </span><span>paragraph 1 </span><span class="c10">as follows</span><span class="c16">&nbsp;to allow a template declaration introduced by a concept</span><span>.</span></p><p class="c13"><span></span></p><p class="c4"><span>A </span><span class="c1">template</span><span>&nbsp;defines a family of classes or functions</span><span class="c10">,</span><span class="c16">&nbsp;or</span><span>&nbsp;an alias for a family of types</span><span class="c10">, or a </span><span class="c10 c1">concept</span><span>.</span></p><p class="c13 c44"><span></span></p><p class="c4"><span class="c1">template-declaration:</span></p><p class="c4"><span>&nbsp; &nbsp;</span><span class="c8 c7">template &lt;</span><span>&nbsp;</span><span class="c1">template-parameter-list</span><span>&nbsp;</span><span class="c8 c7">&gt;</span><span>&nbsp;</span><span class="c15 c1">requires-clause</span><span class="c2 c15 c1">opt</span><span>&nbsp;</span><span class="c1">declaration</span></p><p class="c4"><span>&nbsp; &nbsp;</span><span class="c15 c1">template-introduction</span><span class="c15">&nbsp;</span><span class="c1 c15">declaration</span><span><br></span></p><p class="c4"><span class="c15 c1">requires-clause:</span></p><p class="c4"><span>&nbsp; &nbsp;</span><span class="c8 c7 c15">requires</span><span class="c15">&nbsp;</span><span class="c15 c1">constraint-expression</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>The declaration in a </span><span class="c1">template-declaration</span><span>&nbsp;shall</span></p><p class="c4"><span>&mdash; declare or define a function, a class, or a variable, or</span></p><p class="c4"><span>&mdash; define a member function, a member class, a member enumeration, or a static data member of a class template or of a class nested within a class template, or</span></p><p class="c4"><span>&mdash; define a member template of a class or class template, or</span></p><p class="c4"><span>&mdash; be an </span><span class="c1">alias-declaration</span><span class="c10">&nbsp;or a </span><span class="c10 c1">concept-declaration</span><span>.</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>A </span><span class="c1">template-declaration</span><span>&nbsp;is a declaration. &nbsp;A </span><span class="c1">template-declaration</span><span>&nbsp;is also a definition if its </span><span class="c1">declaration</span><span>&nbsp;</span><span class="c10">is a </span><span class="c10 c1">concept-declaration</span><span class="c10">, in which case the </span><span class="c10 c1">template-declaration</span><span class="c10">&nbsp;is referred to as </span><span class="c10 c1">concept definition</span><span class="c10">, or </span><span>defines a function, a class, a variable, or a static data member. &nbsp;A declaration introduced by a template declaration of a variable is a variable template. &nbsp;A variable template at class scope is a static data member template. &nbsp;[ </span><span class="c1">Example:</span><span>&nbsp;&hellip; </span><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c14"><span>New instructions:</span></p><p class="c13"><span></span></p><p class="c14 c26"><span>Add a new section 14.5.8 [temp.concept]:</span></p><h4 class="c4 c27" id="h.d409nuanzzyd"><span class="c21 c43">14.5.8 &nbsp;Concepts</span></h4><p class="c4"><span>A concept definition declares the </span><span class="c1">identifier</span><span>&nbsp;to be a </span><span class="c1">concept</span><span>. &nbsp;A concept defines a set of constraints (14.10). &nbsp;The name of the concept is a </span><span class="c1">template-name</span><span>.</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>A </span><span class="c1">concept-declaration</span><span>&nbsp;may appear only as the </span><span class="c1">declaration</span><span>&nbsp;of a </span><span class="c1">template-declaration</span><span>&nbsp;in namespace scope. &nbsp;[ </span><span class="c1">Example:</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c4"><span class="c8 c7">&nbsp; concept C1 = true; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// OK: declares a concept</span></p><p class="c4"><span class="c8 c7">&nbsp; concept C2 = true; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// error: not a concept definition</span></p><p class="c4"><span class="c8 c7">&nbsp; struct S {</span></p><p class="c4"><span class="c8 c7">&nbsp; &nbsp; template&lt;typename T&gt;</span></p><p class="c4"><span class="c7 c8">&nbsp; &nbsp; concept C = true; &nbsp; &nbsp; </span><span class="c7 c1">// error: concept declared in class scope</span></p><p class="c4"><span class="c8 c7">&nbsp; };</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>A concept definition shall not have associated constraints (14.10.2).</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>The </span><span class="c1">constraint-expression</span><span>&nbsp;(14.10.2) of a concept shall not include a reference to the concept being declared. &nbsp;[ </span><span class="c1">Example:</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c4"><span class="c8 c7">&nbsp; concept C = C&lt;T*&gt;; </span><span class="c7 c1">// error</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>The </span><span class="c1">constraint-expression</span><span>&nbsp;of a concept shall be a core constant expression of type </span><span class="c8 c7">bool</span><span>.</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>In a potentially-evaluated expression, when a </span><span class="c1">template-id</span><span>&nbsp;refers to a specialization of a concept, it is equivalent to </span><span>a</span><span>&nbsp;prvalue of the substituted </span><span class="c1">constraint-expression</span><span>&nbsp;of the concept. &nbsp;[ Note: The concept definitions cannot be instantiated, but may be normalized (14.10.2). &nbsp;&mdash;end note ]</span></p><p class="c4 c25"><span></span></p><p class="c4"><span>The first declared template parameter of a concept definition is its </span><span class="c1">prototype parameter</span><span>. &nbsp;A </span><span class="c1">variadic concept</span><span>&nbsp;is a concept whose prototype parameter is a template parameter pack.</span></p><p class="c4 c25"><span></span></p><p class="c14 c26"><span>Add a new paragraph at the end of section 14.5 [temp.decls]:</span></p><p class="c13 c26"><span></span></p><p class="c4"><span>Because an </span><span class="c1">alias-declaration</span><span>&nbsp;cannot declare a </span><span class="c1">template-id</span><span>, it is not possible to partially or explicitly specialize </span><span>an alias template.</span></p><p class="c4 c25"><span class="c10"></span></p><p class="c4"><span class="c10">It is also not possible to partially or explicitly specialize a concept as a </span><span class="c10 c1">concept-declaration</span><span class="c10">&nbsp;cannot declare a </span><span class="c10 c1">template-id</span><span class="c10">&nbsp;or a </span><span class="c10 c1">partial-concept-id</span><span class="c10">. &nbsp;[ Note: This prevents users from subverting the constraint system by providing a meaning for a concept that differs from its original definition. &nbsp;&mdash;end note ]</span></p><p class="c13"><span></span></p><p class="c14"><span>For the following instruction applying to chapter 14.1 [temp.param],</span></p><p class="c13"><span></span></p><p class="c6"><span>Insert the following paragraphs after paragraph 8. &nbsp;These paragraphs define the meaning of a constrained template parameter.</span></p><p class="c13"><span></span></p><p class="c14"><span>modify paragraph 9 as follows:</span></p><p class="c13"><span></span></p><p class="c4"><span>A </span><span class="c1">constrained-parameter</span><span>&nbsp;declares a template parameter whose kind (type, non-type, template) and type match that of the prototype parameter of the concept </span><span class="c10">referred to</span><span class="c16">&nbsp;designated</span><span>&nbsp;by the </span><span class="c1">qualified-concept-name</span><span>&nbsp;(7.1.6.4.2) in the </span><span class="c1">constrained-parameter</span><span>. &nbsp;</span><span class="c16">The designated concept is selected by the rules for concept resolution described in 14.10.4. &nbsp;</span><span>Let </span><span class="c8 c7">X</span><span>&nbsp;be the prototype parameter of the </span><span class="c16">designated </span><span>concept. &nbsp;The declared template parameter is determined by the kind of </span><span class="c8 c7">X</span><span>&nbsp;(type, non-type, template) and the optional ellipsis in the </span><span class="c1">constrained-parameter</span><span>&nbsp;as follows.</span></p><p class="c4"><span>&hellip;</span></p><p class="c13"><span></span></p><p class="c14"><span>modify the new bullets (10.3) and (10.4) as follows:</span></p><p class="c13"><span></span></p><p class="c4"><span>&mdash; </span><span class="c16">Then, f</span><span class="c10">F</span><span>orm an </span><span class="c1">expression</span><span>&nbsp;</span><span class="c8 c7">E</span><span>&nbsp;</span><span class="c16">as</span><span class="c16">&nbsp;</span><span class="c16">follows. If </span><span class="c16 c8 c7">C</span><span class="c16">&nbsp;is a variable concept (7.1.7), then </span><span class="c16 c8 c7">E</span><span class="c16">&nbsp;is </span><span class="c10">to be</span><span>&nbsp;the </span><span class="c1">id-expression</span><span>&nbsp;</span><span class="c8 c7">TT</span><span>. &nbsp;</span><span class="c16">Otherwise, </span><span class="c16 c8 c7">C</span><span class="c16">&nbsp;is a function concept and </span><span class="c16 c8 c7">E</span><span class="c16">&nbsp;is the function call </span><span class="c16 c8 c7">TT()</span><span class="c16">.</span></p><p class="c4"><span class="c16">&mdash; Finally, i</span><span class="c10">I</span><span>f </span><span class="c8 c7">P</span><span>&nbsp;declares a template parameter pack</span><span class="c16">&nbsp;and </span><span class="c16 c8 c7">C</span><span class="c16">&nbsp;is not a variadic concept</span><span>, </span><span class="c8 c7">E</span><span>&nbsp;is adjusted to be the </span><span class="c1">fold-expression</span><span>&nbsp;</span><span class="c8 c7">(E &amp;&amp; ...)</span><span>&nbsp;(5.1.3).</span></p><p class="c13"><span></span></p><p class="c14"><span>as well as the example:</span></p><p class="c13"><span></span></p><p class="c4"><span>[ </span><span class="c1">Example:</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;typename T&gt; concept bool C1 = true;</span></p><p class="c4"><span class="c16 c8 c7">&nbsp; template&lt;typename... Ts&gt; concept bool C2() { return true; }</span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;typename T, typename U&gt; concept bool C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">&nbsp;= true;</span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;C1 T&gt; struct s1; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// associates</span><span class="c8 c7">&nbsp;C1&lt;T&gt;</span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;C1... T&gt; struct s2; &nbsp; </span><span class="c1 c7">// associates</span><span class="c8 c7">&nbsp;(C1&lt;T&gt; &amp;&amp; ...)</span></p><p class="c4"><span class="c16 c8 c7">&nbsp; template&lt;C2... T&gt; struct s3; &nbsp; </span><span class="c16 c7 c1">// associates</span><span class="c16 c8 c7">&nbsp;C2&lt;T...&gt;()</span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">&lt;int&gt; T&gt; struct s</span><span class="c0">3</span><span class="c16 c8 c7">4</span><span class="c8 c7">; </span><span class="c7 c1">// associates</span><span class="c8 c7">&nbsp;C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">&lt;T, int&gt;</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c14"><span><br>In the instruction to add the chapter 14.2 [temp.intro], modify paragraph 2 as follows:</span></p><p class="c13"><span></span></p><p class="c4"><span class="c16">The concept designated by the </span><span class="c16 c1">qualified-concept-name</span><span class="c16">&nbsp;is selected by the concept resolution rules described in 14.10.4. &nbsp;</span><span>Let </span><span class="c8 c7">C</span><span>&nbsp;be the </span><span class="c16">designated </span><span>concept</span><span class="c10">&nbsp;referred to by the </span><span class="c10 c1">qualified-concept-name</span><span>. &nbsp;The template parameters declared by a </span><span class="c1">template-introduction</span><span>&nbsp;are derived from its </span><span class="c1">introduced-parameters</span><span>&nbsp;and the template parameter declarations of </span><span class="c8 c7">C</span><span class="c16">&nbsp;to which those </span><span class="c16 c1">introduced-parameters</span><span class="c16">&nbsp;are matched as wildcards according to the rules in 14.10.4</span><span>. &nbsp;For each </span><span class="c1">introduced-parameter</span><span>&nbsp;</span><span class="c8 c7">I</span><span>, declare a template parameter using the following rules:</span></p><p class="c4"><span>&hellip;</span></p><p class="c13"><span></span></p><p class="c14"><span>and modify the bullet (5.2) as follows:</span></p><p class="c13"><span></span></p><p class="c4"><span>&mdash; Then, form an </span><span>expression</span><span>&nbsp;</span><span class="c8 c7">E</span><span>&nbsp;</span><span class="c16">as follows. &nbsp;If </span><span class="c16 c8 c7">C</span><span class="c16">&nbsp;designates a variable concept (7.1.7), then </span><span class="c16 c8 c7">E</span><span class="c16">&nbsp;is </span><span class="c10">to be</span><span>&nbsp;the </span><span class="c1">id-expression</span><span>&nbsp;</span><span class="c8 c7">C&lt;A1, ..., AN&gt;</span><span>.</span><span class="c16">&nbsp; Otherwise, </span><span class="c16 c8 c7">C</span><span class="c16">&nbsp;designates a function concept and </span><span class="c16 c8 c7">E</span><span class="c16">&nbsp;is the function call </span><span class="c16 c8 c7">C&lt;A1, ..., AN&gt;()</span><span class="c16">.</span></p><p class="c13"><span></span></p><p class="c14"><span>as well as the example:</span></p><p class="c13"><span></span></p><p class="c4"><span>[ </span><span class="c1">Example:</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;typename T, typename U&gt; concept bool C1 = true;</span></p><p class="c4"><span class="c16 c8 c7">&nbsp; template&lt;typename T, typename U&gt; concept bool C2() { return true; }</span></p><p class="c4"><span class="c8 c7">&nbsp; template&lt;typename... Ts&gt; concept bool C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">&nbsp;= true;</span></p><p class="c4"><span class="c8 c7">&nbsp; C1{A, B} struct s1; &nbsp; &nbsp;</span><span class="c7 c1">// associates</span><span class="c8 c7">&nbsp;C1&lt;A, B&gt;</span></p><p class="c4"><span class="c16 c8 c7">&nbsp; C2{A, B} struct s2; &nbsp; &nbsp;</span><span class="c16 c7 c1">// associates</span><span class="c16 c8 c7">&nbsp;C2&lt;A, B&gt;()</span></p><p class="c4"><span class="c8 c7">&nbsp; C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">{...Ts} struct s</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">; &nbsp; </span><span class="c7 c1">// associates</span><span class="c8 c7">&nbsp;C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">&lt;Ts...&gt;</span></p><p class="c4"><span class="c8 c7">&nbsp; C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">{X, ...Y} struct s</span><span class="c0">3</span><span class="c16 c8 c7">4</span><span class="c8 c7">; </span><span class="c7 c1">// associates</span><span class="c8 c7">&nbsp;C</span><span class="c0">2</span><span class="c16 c8 c7">3</span><span class="c8 c7">&lt;X, Y...&gt;</span></p><p class="c4 c25"><span class="c8 c7"></span></p><p class="c4"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c14"><span>In the instruction to add the chapter 14.10 [temp.constr], in 14.10.2 [temp.constr.decl], modify the bullets (3.1) and (3.2) as follows:</span></p><p class="c13"><span></span></p><p class="c4"><span class="c16">&mdash; replace all function calls of the form </span><span class="c16 c8 c7">C&lt;A1, A2, ..., AN&gt;()</span><span class="c16">, where </span><span class="c16 c8 c7">C</span><span class="c16">&nbsp;refers to the function concept </span><span class="c16 c8 c7">D</span><span class="c16">&nbsp;(7.1.7) selected by the rules for concept resolution (14.10.4), with the result of substituting </span><span class="c16 c8 c7">A1, A2, ..., A</span><span class="c16 c1">N</span><span class="c16">&nbsp;into the expression returned by </span><span class="c16 c8 c7">D</span><span class="c16">, and</span></p><p class="c4"><span>&mdash; replace all </span><span class="c1">id-expressions</span><span>&nbsp;of the form </span><span class="c8 c7">C&lt;A1, A2, ..., AN&gt;</span><span>, where </span><span class="c8 c7">C</span><span>&nbsp;</span><span class="c10">refers to a</span><span class="c16">&nbsp;</span><span class="c16">is the variable</span><span>&nbsp;concept </span><span class="c8 c7">D</span><span>&nbsp;(</span><span class="c10">14.5.8</span><span class="c16">7.1.7</span><span>)</span><span class="c16">&nbsp;selected by the rules for concept resolution (14.10.4)</span><span>, with the result of substituting </span><span class="c8 c7">A1, A2, ..., A</span><span class="c1">N</span><span>&nbsp;into the</span><span>&nbsp;</span><span class="c10 c1">constraint-expression</span><span class="c16">&nbsp;initializer</span><span>&nbsp;of </span><span class="c8 c7">D</span><span>.</span></p><p class="c13"><span></span></p><p class="c14"><span>Revert the new section 14.10.4 [temp.constr.resolve].</span></p><p class="c13"><span></span></p><p class="c14"><span>In the instruction to add the section 7.1.6.4.2 [dcl.spec.auto.constr], modify paragraph 2 as follows:</span></p><p class="c13"><span></span></p><p class="c4"><span>An identifier is a </span><span class="c1">concept-name</span><span>&nbsp;if it refers to a </span><span class="c16">set of </span><span>concept </span><span class="c16">definitions </span><span>(</span><span class="c10">14.5.8</span><span class="c16">7.1.7</span><span>). &nbsp;</span><span class="c16">[ Note: &hellip; &mdash;end note ] [ Example: &hellip; &mdash;end example ]</span></p><p class="c13"><span></span></p><p class="c14"><span>and modify paragraph 4 as follows:</span></p><p class="c13"><span></span></p><p class="c4"><span class="c16">The concept designated by a </span><span class="c16 c1">constrained-type-specifier</span><span class="c16">&nbsp;is the one selected according to the rules for concept resolution in 14.10.4.</span></p><p class="c13"><span></span></p><p class="c14"><span>Apply the syntax changes to all the examples in the document. &nbsp;Sample edits:</span></p><p class="c13"><span></span></p><p class="c6"><span>&hellip; 5.1.4 paragraph 5&hellip; &nbsp;[ </span><span class="c1">Example:</span></p><p class="c13"><span class="c7"></span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp; concept </span><span class="c0">C1 =</span><span class="c16 c8 c7">bool C1() {</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; &nbsp;</span><span class="c8 c7">&nbsp;requires(T t, ...) { t; }; </span><span class="c7 c1">// error: terminates with an ellipsis</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; }</span></p><p class="c13"><span class="c8 c7"></span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp; concept </span><span class="c0">C2 =</span><span class="c16 c8 c7">bool C2() {</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp;</span><span class="c8 c7">&nbsp;requires(T t, void (*p)(T*, ...)) </span><span class="c7 c1">// OK: the parameter-declaration-clause of</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp; { p(t); }; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// the requires-expression does not terminate</span></p><p class="c6"><span class="c8 c7">&nbsp; </span><span class="c16 c8 c7">}</span><span class="c8 c7">&nbsp;</span><span class="c8 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">// with an ellipsis</span></p><p class="c13"><span class="c7"></span></p><p class="c6"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c6"><span>&hellip; 5.1.4 paragraph 7&hellip; &nbsp;[ </span><span class="c1">Example:</span></p><p class="c13"><span class="c8 c7"></span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt; concept </span><span class="c16 c8 c7">bool </span><span class="c8 c7">C =</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp; requires {</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp; new int[-(int)sizeof(T)]; </span><span class="c7 c1">// ill-formed, no diagnostic required</span></p><p class="c6"><span class="c8 c7">&nbsp; };</span></p><p class="c13"><span class="c8 c7"></span></p><p class="c6"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c14"><span>Update all the references to 7.1.7 to reference 14.5.8.</span></p><p class="c13"><span></span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span></span></p><h3 class="c14 c27" id="h.w3sngykjb9k4"><span>Alternative II</span></h3><p class="c14"><span>Issues fixed: concepts-ts 7, 8, 22.</span></p><p class="c14"><span>Issues closed: concepts-ts 19, 20, 25, 26, 27.</span></p><p class="c13"><span></span></p><p class="c14"><span>Revert the following instruction applied to chapter 7.1 [dcl.spec]:</span></p><p class="c13"><span></span></p><p class="c6"><span>Extend the </span><span class="c1">decl-specifier</span><span>&nbsp;production in paragraph 1 to include the </span><span class="c8 c7">concept</span><span>&nbsp;specifier.</span></p><p class="c13"><span></span></p><p class="c14"><span>Modify the instruction applying to section 7.1.6.2 [dcl.type.simple] as follows:</span></p><p class="c13"><span></span></p><p class="c6"><span>Add </span><span class="c1">constrained-type-specifier</span><span>&nbsp;</span><span class="c10">and the </span><span class="c0">concept</span><span class="c10">&nbsp;specifier </span><span>to the grammar for </span><span class="c1">simple-type-specifiers</span><span>.</span></p><p class="c13 c38"><span></span></p><p class="c14 c17"><span>&hellip;</span></p><p class="c14 c17"><span class="c8 c7">void</span></p><p class="c14 c17"><span class="c8 c7">auto</span></p><p class="c14 c17"><span class="c0">concept</span></p><p class="c14 c17"><span class="c1">decltype-specifier</span></p><p class="c14 c17"><span class="c15 c1">constrained-type-specifier</span></p><p class="c13"><span></span></p><p class="c14"><span>Modify the instruction adding a new section 7.1.7 [dcl.spec.concept] as follows:</span></p><p class="c13"><span></span></p><p class="c6"><span>The </span><span class="c8 c7">concept</span><span>&nbsp;</span><span class="c10 c1">type-specifier</span><span class="c16">&nbsp;specifier</span><span>&nbsp;shall be applied only to the definition of a </span><span class="c16">function template or </span><span>variable template, declared in namespace scope (3.3.6). &nbsp;</span><span class="c16">A function template definition having the </span><span class="c16 c8 c7">concept</span><span class="c16">&nbsp;specifier is called a </span><span class="c16 c1">function concept</span><span class="c16">. &nbsp;A function concept shall have no </span><span class="c16 c1">exception-specification</span><span class="c16">&nbsp;</span><span class="c16">and is treated as if it were specified with </span><span class="c16 c8 c7">noexcept(true)</span><span class="c16">&nbsp;(15.4). &nbsp;When a function is declared to be a concept, it shall be the only declaration of that function. &nbsp;</span><span>A variable template definition having the </span><span class="c8 c7">concept</span><span>&nbsp;</span><span class="c10 c1">type-specifier</span><span class="c16">&nbsp;specifier</span><span>&nbsp;is called a </span><span class="c16 c1">variable </span><span class="c1">concept</span><span>. &nbsp;A </span><span class="c1">concept definition</span><span>&nbsp;refers to </span><span class="c16">either a function concept and its definition or </span><span>a </span><span class="c16">variable </span><span>concept and its initializer. &nbsp;[ </span><span class="c1">Example:</span></p><p class="c13"><span></span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; concept bool F1() { return true; } </span><span class="c16 c7 c1">// OK: declares a function concept</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; concept bool F2(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c16 c7 c1">// error: function concept is not a definition</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; constexpr bool F3();</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; concept bool F3() { return true; } </span><span class="c16 c7 c1">// error: redeclaration of a function as a concept</span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; concept </span><span class="c0">C</span><span class="c16 c8 c7">bool V</span><span class="c8 c7">1 = true; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// OK: declares a </span><span class="c16 c7 c1">variable </span><span class="c7 c1">concept</span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; concept </span><span class="c0">C</span><span class="c16 c8 c7">bool V</span><span class="c8 c7">2; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">// error: </span><span class="c16 c7 c1">variable </span><span class="c7 c1">concept with no initializer</span></p><p class="c6"><span class="c8 c7">&nbsp; struct S {</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; &nbsp; static concept </span><span class="c16 c8 c7">bool </span><span class="c8 c7">C = true; &nbsp; &nbsp;</span><span class="c7 c1">// error: concept declared in class scope</span></p><p class="c6"><span class="c8 c7">&nbsp; };</span></p><p class="c13"><span></span></p><p class="c6"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c6"><span>Every concept definition is implicitly defined to be a </span><span class="c8 c7">constexpr</span><span>&nbsp;declaration (7.1.5)</span><span class="c10">&nbsp;of type </span><span class="c0">bool</span><span>. &nbsp;A concept definition shall not be declared with </span><span class="c10">any other</span><span class="c16">&nbsp;</span><span class="c16">the </span><span class="c16 c8 c7">thread_local</span><span class="c16">, </span><span class="c16 c8 c7">inline</span><span class="c16">, </span><span class="c16 c8 c7">friend</span><span class="c16">, or </span><span class="c16 c8 c7">constexpr</span><span>&nbsp;</span><span>specifiers, nor shall a concept definition have associated constraints (14.10.2).</span></p><p class="c13"><span></span></p><p class="c6"><span>The </span><span class="c16">definition of a function concept or the </span><span>initializer of a </span><span class="c16">variable </span><span>concept shall not include a reference to the concept being declared. &nbsp;[ </span><span class="c1">Example:</span></p><p class="c13"><span class="c8 c7"></span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; concept bool F() { return F&lt;typename T::type&gt;(); } </span><span class="c16 c7 c1">// error</span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; concept </span><span class="c0">C</span><span class="c16 c8 c7">bool V</span><span class="c8 c7">&nbsp;= </span><span class="c0">C</span><span class="c16 c8 c7">V</span><span class="c8 c7">&lt;T*&gt;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// error</span></p><p class="c13"><span class="c8 c7"></span></p><p class="c6"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c6"><span class="c16">The first declared template parameter of a concept definition is its </span><span class="c16 c1">prototype parameter</span><span class="c16">. &nbsp;A variadic concept is a concept whose prototype parameter is a template parameter pack.</span></p><p class="c13"><span class="c16"></span></p><p class="c6"><span class="c16">A function concept has the following restrictions:</span></p><p class="c6"><span class="c16">&mdash; No </span><span class="c16 c1">function-specifiers</span><span class="c16">&nbsp;shall appear in its declaration (7.1.2).</span></p><p class="c6"><span class="c16">&mdash; The declared return type shall have the type </span><span class="c16 c8 c7">bool</span><span class="c16">.</span></p><p class="c6"><span class="c16">&mdash; The declaration&rsquo;s parameter list shall be equivalent to an empty parameter list.</span></p><p class="c6"><span class="c16">&mdash; The declaration shall have a </span><span class="c16 c1">function-body</span><span class="c16">&nbsp;equivalent to </span><span class="c16 c8 c7">{ return E; }</span><span class="c16">&nbsp;where </span><span class="c16 c8 c7">E</span><span class="c16">&nbsp;is a </span><span class="c16 c1">constraint-expression</span><span class="c16">&nbsp;(14.10.1.3).</span></p><p class="c13"><span class="c16"></span></p><p class="c6"><span class="c16">[ </span><span class="c16 c1">Note:</span><span class="c16">&nbsp;Return type deduction requires the instantiation of the function definition, but concept definitions are not instantiated; they are normalized (14.10.2). &nbsp;</span><span class="c16 c1">&mdash;end note</span><span class="c16">&nbsp;] [ </span><span class="c16 c1">Example:</span></p><p class="c13"><span class="c16 c8 c7"></span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; concept int F1() { return 0; } &nbsp; &nbsp; &nbsp;</span><span class="c16 c7 c1">// error: return type is not bool</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; concept auto F2() { return true; } &nbsp;</span><span class="c16 c7 c1">// error: return type is deduced</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c16 c8 c7">&nbsp; concept bool F3(T) { return true; } </span><span class="c16 c7 c1">// error: not an empty parameter list</span></p><p class="c13"><span class="c16 c8 c7"></span></p><p class="c6"><span class="c16 c1">&mdash;end example</span><span class="c16">&nbsp;]</span></p><p class="c13"><span class="c16"></span></p><p class="c6"><span class="c16">A variable concept has the following restrictions:</span></p><p class="c6"><span class="c16">&mdash; The declared type shall have the type </span><span class="c16 c8 c7">bool</span><span class="c16">.</span></p><p class="c6"><span class="c16">&mdash; The declaration shall have an initializer.</span></p><p class="c6"><span class="c16">&mdash; </span><span>The initializer</span><span class="c10">&nbsp;of a concept</span><span>&nbsp;shall be a </span><span class="c1">constraint-expression</span><span class="c10">&nbsp;(14.10.2) followed by </span><span class="c0">=</span><span class="c10">&nbsp;(equal)</span><span>.</span></p><p class="c13"><span></span></p><p class="c6"><span>[ </span><span class="c1">Example:</span></p><p class="c13"><span class="c8 c7"></span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; concept </span><span class="c0">C</span><span class="c16 c8 c7">bool V</span><span class="c8 c7">1 = 3 + 4; </span><span class="c7 c1">// error: initializer is not a constraint-expression</span></p><p class="c6"><span class="c8 c7">&nbsp; concept </span><span class="c0">C</span><span class="c16 c8 c7">bool V</span><span class="c8 c7">2 = 0; &nbsp; &nbsp; </span><span class="c7 c1">// error: not a template</span></p><p class="c13 c38"><span class="c8 c7"></span></p><p class="c6"><span class="c8 c7">&nbsp; template&lt;typename T&gt; concept bool C = true;</span></p><p class="c6"><span class="c8 c7"><br></span><span class="c8 c7">&nbsp; template&lt;C T&gt;</span></p><p class="c6"><span class="c8 c7">&nbsp; concept </span><span class="c0">C</span><span class="c16 c8 c7">bool V</span><span class="c8 c7">3 = true; &nbsp;</span><span class="c7 c1">// error: constrained template declared as a concept</span></p><p class="c13"><span class="c8 c7"></span></p><p class="c6"><span class="c1">&mdash;end example</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c6"><span class="c10">The first declared template parameter of a concept definition is its </span><span class="c10 c1">prototype parameter</span><span class="c10">. &nbsp;A variadic concept is a concept whose prototype parameter is a template parameter pack.</span></p><p class="c13"><span></span></p><p class="c6"><span>A program shall not declare an explicit instantiation (14.8.2), an explicit specialization (14.8.3), or a partial specialization of a concept definition. &nbsp;[ </span><span class="c1">Note:</span><span>&nbsp;This prevents users from subverting the constraint system by providing a meaning for a concept that differs from its original definition. &nbsp;</span><span class="c1">&mdash;end note</span><span>&nbsp;]</span></p><p class="c13"><span></span></p><p class="c13"><span></span></p><p class="c13"><span></span></p><hr class="c35"><div><p class="c14 c28"><a href="p0324r0.html#ftnt_ref1" id="ftnt1">[1]</a><span class="c7">&nbsp;In addition to the cited material, I will add that, inline functions and variables with initializers are easier for normalization (into conjunctions and disjunctions).</span></p></div><div><p class="c14 c28"><a href="p0324r0.html#ftnt_ref2" id="ftnt2">[2]</a><span class="c7">&nbsp;Naturally curried languages exist, but I don&rsquo;t know of a precedence allowing overloading and currying to work together.</span></p></div><div><p class="c14 c28"><a href="p0324r0.html#ftnt_ref3" id="ftnt3">[3]</a><span class="c7">&nbsp;The sample wording &ldquo;Alternative I&rdquo; does emphasise these in a different place, but they are already grammatically not possible.</span></p></div><div><p class="c14 c28"><a href="p0324r0.html#ftnt_ref4" id="ftnt4">[4]</a><span class="c7">&nbsp;If an extension is applied to allow evaluating concepts in more contexts.</span></p></div></body></html>
