<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Allowing Anonymous Structs as Return Values</title>
<meta name="date" content="2016-02-05" />
<meta name="author" content="Matthew Woehlke (mwoehlke.floss&#64;gmail.com)" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="allowing-anonymous-structs-as-return-values">
<h1 class="title">Allowing Anonymous Structs as Return Values</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">Document:</th><td class="field-body">P0222R0</td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>2016-02-05</td></tr>
<tr class="field"><th class="docinfo-name">Project:</th><td class="field-body">ISO/IEC JTC1 SC22 WG21 Programming Language C++</td>
</tr>
<tr class="field"><th class="docinfo-name">Audience:</th><td class="field-body">Evolution Working Group</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Matthew Woehlke (<a class="reference external" href="mailto:mwoehlke.floss&#64;gmail.com">mwoehlke.floss&#64;gmail.com</a>)</td></tr>
</tbody>
</table>
<style>
  html { color: black; background: white; }
  table.docinfo { margin: 2em 0; }
  .literal-block { background: #eee; border: 1px solid #ddd; padding: 0.5em; }
  .addition { color: #2c2; text-decoration: underline; }
  .removal { color: #e22; text-decoration: line-through; }
  .literal-block .literal-block { background: none; border: none; }
  .block-addition { background: #cfc; text-decoration: underline; }
</style><div class="section" id="abstract">
<h1><a class="toc-backref" href="p0222r0.html#id1">Abstract</a></h1>
<p>This proposal recommends the relaxing of [dcl.fct]/11; specifically, the prohibition of defining (anonymous) types as return values. This proposal is considered contingent on <a class="reference external" href="http://wg21.link/p0224">P0224</a>, as obvious problems otherwise arise.</p>
<p>(Note: references made to the existing draft standard are made against <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">N4567</a>.)</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="p0222r0.html#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="p0222r0.html#rationale" id="id2">Rationale</a></li>
<li><a class="reference internal" href="p0222r0.html#proposal" id="id3">Proposal</a></li>
<li><a class="reference internal" href="p0222r0.html#proposed-wording" id="id4">Proposed Wording</a></li>
<li><a class="reference internal" href="p0222r0.html#interactions" id="id5">Interactions</a></li>
<li><a class="reference internal" href="p0222r0.html#implementation-and-existing-practice" id="id6">Implementation and Existing Practice</a></li>
<li><a class="reference internal" href="p0222r0.html#discussion" id="id7">Discussion</a><ul>
<li><a class="reference internal" href="p0222r0.html#what-about-defining-types-in-function-pointer-types" id="id8">What about defining types in function pointer types?</a></li>
<li><a class="reference internal" href="p0222r0.html#what-about-defining-types-in-parameter-types" id="id9">What about defining types in parameter types?</a></li>
<li><a class="reference internal" href="p0222r0.html#what-about-pass-through-of-return-values-having-equivalent-types" id="id10">What about &quot;pass-through&quot; of return values having equivalent types?</a></li>
<li><a class="reference internal" href="p0222r0.html#conflicts-with-future-true-multiple-return-values" id="id11">Conflicts with future &quot;true&quot; multiple return values?</a></li>
<li><a class="reference internal" href="p0222r0.html#what-about-deduced-return-types" id="id12">What about deduced return types?</a></li>
</ul>
</li>
<li><a class="reference internal" href="p0222r0.html#future-directions" id="id13">Future Directions</a></li>
<li><a class="reference internal" href="p0222r0.html#acknowledgments" id="id14">Acknowledgments</a></li>
<li><a class="reference internal" href="p0222r0.html#references" id="id15">References</a></li>
</ul>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="p0222r0.html#id2">Rationale</a></h1>
<p>The concept of multiple return values is well known. At present, however, C++ lacks a good mechanism for implementing the same. <tt class="docutils literal"><span class="pre">std::tuple</span></tt> is considered clunky by many and, critically, creates sub-optimal API by virtue of the returned values being unnamed, forcing developers to rely on supplemental documentation to explain their purpose. Aggregates represent an improvement, being self-documenting, but the need to provide external definitions of the same is awkward and, worse, pollutes their corresponding namespace with entities that may be single use. Proposals such as <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf">N4560</a> present a complicated mechanism for providing tagged (self-documenting) tuple-like types, which may be necessary in some cases, but still represent a non-trivial amount of complexity that ideally should not be required.</p>
<p>Proposals such as <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf">P0144</a> in particular represent a significant step toward support of multiple return values as first class citizens. This proposals, along with <a class="reference external" href="http://wg21.link/p0197">P0197</a> and other current directions show an encouraging movement away from the traditional <tt class="docutils literal"><span class="pre">std::pair</span></tt> and <tt class="docutils literal"><span class="pre">std::tuple</span></tt> towards comparable concepts without requiring the explicit types. (We expect, however, that the standard template library types will remain useful for algorithms where the identity of the elements is unimportant, while it <em>is</em> important to be able to name at least the outer, if not complete, type. In that respect, we hypothesize that we may in the future see the ability to construct a <tt class="docutils literal"><span class="pre">std::tuple</span></tt> from any tuple-like, as also suggested in <a class="reference external" href="http://wg21.link/p0197">P0197</a>.) On their own, however, these proposals risk exacerbating the problem that this proposal aims to address.</p>
<p>It has been suggested on multiple occasions that the optimal solution to the above issues is to return an anonymous <tt class="docutils literal">struct</tt>. This solves the problems of clutter and self-documentation, but runs afoul of a much worse issue; because the <tt class="docutils literal">struct</tt> is <em>anonymous</em>, it can be difficult to impossible to give its name a second time in order to separate the declaration and definition of the function that wishes to use it.</p>
<p>The discussion on this topic lead to an interesting question, which is addressed in <a class="reference external" href="http://wg21.link/p0224">P0224</a>: <strong>why is it necessary to repeat the return value at all?</strong> If <a class="reference external" href="http://wg21.link/p0224">P0224</a> is accepted, the problem of naming the return type is immediately eliminated, and along with it, a major reason why returning anonymous <tt class="docutils literal">struct</tt>s is not currently permitted.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="p0222r0.html#id3">Proposal</a></h1>
<p>The use of <tt class="docutils literal">auto</tt> to indicate an <em>inferred</em> return type (as proposed by <a class="reference external" href="http://wg21.link/p0224">P0224</a>) provides an optimal solution to the following problem:</p>
<pre class="code c++ literal-block">
<span class="comment single">// foo.h
</span><span class="keyword">struct</span> <span class="punctuation">{</span> <span class="keyword type">int</span> <span class="name">id</span><span class="punctuation">;</span> <span class="keyword type">double</span> <span class="name">value</span><span class="punctuation">;</span> <span class="punctuation">}</span> <span class="name">foo</span><span class="punctuation">();</span>
</pre>
<p>How does one now provide an external definition for <tt class="docutils literal">foo()</tt>? With <a class="reference external" href="http://wg21.link/p0224">P0224</a>, the solution is simple:</p>
<pre class="code c++ literal-block">
<span class="comment single">// foo.cpp
</span><span class="keyword">auto</span> <span class="name function">foo</span><span class="punctuation">()</span>
<span class="punctuation">{</span>
  <span class="punctuation">...</span>
  <span class="keyword">return</span> <span class="punctuation">{</span> <span class="name">id</span><span class="punctuation">,</span> <span class="name">value</span> <span class="punctuation">};</span>
<span class="punctuation">}</span>
</pre>
<p>Recent and proposed changes in C++ significantly mitigate the reasons to prohibit an anonymous struct defined as a return type. Constructing the return result is a non-issue, since the type name may now be elided, and the combination of <tt class="docutils literal">auto</tt> variable declarations, <tt class="docutils literal">decltype</tt>, and <a class="reference external" href="http://wg21.link/p0224">P0224</a>, permit implicit naming of the type where necessary. In short, the prohibition ([dcl.fct]/11) against defining types in return type specifications has become largely an artificial and arbitrary restriction which we propose to remove.</p>
<p>We additionally note that this prohibition is already not enforced by at least one major compiler (MSVC), and is enforced sporadically in others (see <a class="reference internal" href="p0222r0.html#what-about-defining-types-in-function-pointer-types">What about defining types in function pointer types?</a>).</p>
</div>
<div class="section" id="proposed-wording">
<h1><a class="toc-backref" href="p0222r0.html#id4">Proposed Wording</a></h1>
<p>(Proposed changes are specified relative <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">N4567</a>.)</p>
<p>Change [dcl.fct]/11 (8.3.5.11) as follows:</p>
<div class="literal-block compound">
<p>Types shall not be defined in <span class="removal">return or</span> parameter types.</p>
</div>
</div>
<div class="section" id="interactions">
<h1><a class="toc-backref" href="p0222r0.html#id5">Interactions</a></h1>
<p>Definition of an anonymous class-type as a return value type is currently ill-formed (although not universally enforced by existing major compilers). Accordingly, this change will not affect existing and conforming code, and may cause existing but non-conforming code to become conforming. This proposal does not make any changes to other existing language or library features; while conceivable that some library methods might benefit from the feature, such changes are potentially breaking, and no such changes are proposed at this time.</p>
</div>
<div class="section" id="implementation-and-existing-practice">
<h1><a class="toc-backref" href="p0222r0.html#id6">Implementation and Existing Practice</a></h1>
<p>The proposed feature is at least already partly implemented by MSVC and (to a lesser extend) GCC and ICC. The curious, partial support in GCC and ICC (see <a class="reference internal" href="p0222r0.html#what-about-defining-types-in-function-pointer-types">What about defining types in function pointer types?</a>) suggests that the existing prohibition may already be largely artificial, and that removing it would accordingly be a simple matter.</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="p0222r0.html#id7">Discussion</a></h1>
<div class="section" id="what-about-defining-types-in-function-pointer-types">
<h2><a class="toc-backref" href="p0222r0.html#id8">What about defining types in function pointer types?</a></h2>
<p>An obvious consequence of relaxing [dcl.fct]/11 is the desire to permit function pointers which return an anonymous struct. For example:</p>
<pre class="code c++ literal-block">
<span class="comment single">// Declare a function pointer type which returns an anonymous struct
</span><span class="keyword">using</span> <span class="name">ReturnsAnonymousStruct</span> <span class="operator">=</span> <span class="keyword">struct</span> <span class="punctuation">{</span> <span class="keyword type">int</span> <span class="name">result</span><span class="punctuation">;</span> <span class="punctuation">}</span> <span class="punctuation">(</span><span class="operator">*</span><span class="punctuation">)();</span>

<span class="comment single">// Define a function using the same
</span><span class="keyword type">int</span> <span class="name function">bar</span><span class="punctuation">(</span><span class="name">ReturnsAnonymousStruct</span> <span class="name">f</span><span class="punctuation">)</span> <span class="punctuation">{</span> <span class="keyword">return</span> <span class="punctuation">((</span><span class="operator">*</span><span class="name">f</span><span class="punctuation">)()).</span><span class="name">result</span><span class="punctuation">;</span> <span class="punctuation">}</span>

<span class="comment single">// Provide a mechanism to obtain the return type of a function
</span><span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="keyword">struct</span> <span class="name">ReturnType</span><span class="punctuation">;</span>

<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="punctuation">,</span> <span class="keyword">typename</span><span class="punctuation">...</span> <span class="name">Args</span><span class="operator">&gt;</span>
<span class="keyword">struct</span> <span class="name">ReturnType</span><span class="operator">&lt;</span><span class="name">T</span> <span class="punctuation">(</span><span class="operator">*</span><span class="punctuation">)(</span><span class="name">Args</span><span class="punctuation">...)</span><span class="operator">&gt;</span>
<span class="punctuation">{</span>
    <span class="keyword">using</span> <span class="keyword type">result_t</span> <span class="operator">=</span> <span class="name">T</span><span class="punctuation">;</span>
<span class="punctuation">};</span>

<span class="comment single">// Declare a function that is a ReturnsAnonymousStruct
</span><span class="name">ReturnType</span><span class="operator">&lt;</span><span class="name">ReturnsAnonymousStruct</span><span class="operator">&gt;::</span><span class="keyword type">result_t</span> <span class="name">foo</span><span class="punctuation">()</span> <span class="punctuation">{</span> <span class="keyword">return</span> <span class="punctuation">{</span><span class="literal number integer">0</span><span class="punctuation">};</span> <span class="punctuation">}</span>

<span class="comment single">// Use the function
</span><span class="keyword type">int</span> <span class="name">main</span><span class="punctuation">()</span>
<span class="punctuation">{</span>
    <span class="keyword">return</span> <span class="name">bar</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">foo</span><span class="punctuation">);</span>
<span class="punctuation">}</span>
</pre>
<p>It is our opinion that the proposed changes are sufficient to allow the above. (In fact, this example is already accepted by both GCC and ICC, although it is rejected by clang per [dcl.fct]/11.) Accordingly, we feel that this proposal should be understood as intending to allow the above example and that additional wording changes to specify this behavior are not required at this time.</p>
</div>
<div class="section" id="what-about-defining-types-in-parameter-types">
<h2><a class="toc-backref" href="p0222r0.html#id9">What about defining types in parameter types?</a></h2>
<p>An obvious follow-on question is, should we also lift the prohibition against types defined in parameter specifications? There have been suggestions floated to implement the much requested named parameters in something like this manner. However, there are significant (in our opinion) reasons to not address this, at least initially. First, it is widely contested that this is not an optimal solution to the problem (named parameters) in the first place. Second, it depends on named initializers, which is an area of ongoing work. Third, this proposal works largely because C++ forbids overloading on return type, which may be leveraged to eliminate any ambiguity as to the deduction of the actual type of <tt class="docutils literal">auto</tt>; this is not the case for parameters, and so permitting <tt class="docutils literal">auto</tt> as a parameter type specifier would quickly run into issues that can be avoided for the return type case.</p>
<p>While we do not wish to categorically rule out future changes in this direction, we feel that it is not appropriate for this proposal to attempt to address these issues.</p>
</div>
<div class="section" id="what-about-pass-through-of-return-values-having-equivalent-types">
<h2><a class="toc-backref" href="p0222r0.html#id10">What about &quot;pass-through&quot; of return values having equivalent types?</a></h2>
<p>Another question that has come up is if something like this should be allowed:</p>
<pre class="code c++ literal-block">
<span class="keyword">struct</span> <span class="punctuation">{</span> <span class="keyword type">int</span> <span class="name">result</span><span class="punctuation">;</span> <span class="punctuation">}</span> <span class="name">foo</span><span class="punctuation">()</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
<span class="keyword">struct</span> <span class="punctuation">{</span> <span class="keyword type">int</span> <span class="name">result</span><span class="punctuation">;</span> <span class="punctuation">}</span> <span class="name">bar</span><span class="punctuation">()</span>
<span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="name">foo</span><span class="punctuation">();</span>
<span class="punctuation">}</span>
</pre>
<p>Specifically, others have expressed an interest in treating layout-compatible types as equivalent (or at least, implicitly convertible), particularly in the context of return values as in the above example.</p>
<p>Under the current rules (plus relaxed [dcl.fct]/11), these two definitions have different return types which are not convertible. It is our opinion that the rules making these types different are in fact correct and desirable, and this proposal specifically does <em>not</em> include any changes which would make the types compatible. We would, however, encourage a future (orthogonal) proposal which would allow something like this:</p>
<pre class="code c++ literal-block">
<span class="keyword">struct</span> <span class="punctuation">{</span> <span class="keyword type">int</span> <span class="name">result</span><span class="punctuation">;</span> <span class="punctuation">}</span> <span class="name">bar</span><span class="punctuation">()</span>
<span class="punctuation">{</span>
  <span class="comment single">// The use of '...' here implies that the compiler stores the result of
</span>  <span class="comment single">// 'foo()' in a temporary, which is unpacked into a parameter pack and then
</span>  <span class="comment single">// expanded into an expression list which is used to form an initializer
</span>  <span class="comment single">// list which in turn forms the return value of 'bar'. This syntax should
</span>  <span class="comment single">// be taken as illustrative only; we do not anticipate that this would be
</span>  <span class="comment single">// the exact syntax used should such a feature be added.
</span>  <span class="keyword">return</span> <span class="punctuation">{</span> <span class="name">foo</span><span class="punctuation">()...</span> <span class="punctuation">};</span>
<span class="punctuation">}</span>
</pre>
</div>
<div class="section" id="conflicts-with-future-true-multiple-return-values">
<h2><a class="toc-backref" href="p0222r0.html#id11">Conflicts with future &quot;true&quot; multiple return values?</a></h2>
<p>There has been some discussion of &quot;true&quot; multiple return values, in particular with respect to RVO and similar issues. No doubt unpacking, if accepted, will play a part. A point that bears consideration is if moving down the path of using anonymous (or not) structs for multiple return values will &quot;paint us into a corner&quot; where future optimization potential is prematurely eliminated.</p>
<p>It is our hope that these issues can be addressed with existing compound types (which will have further reaching benefit), and that it is accordingly not necessary to hold back the features here proposed in the hope of something better coming along. As is often said, perfect is the enemy of good.</p>
</div>
<div class="section" id="what-about-deduced-return-types">
<h2><a class="toc-backref" href="p0222r0.html#id12">What about deduced return types?</a></h2>
<p>This feature is not compatible with deduced return types at this time. If designated initializers are ever accepted, it might be possible to lift this restriction:</p>
<pre class="code c++ literal-block">
<span class="keyword">auto</span> <span class="name function">foo</span><span class="punctuation">()</span>
<span class="punctuation">{</span>
  <span class="keyword">return</span> <span class="punctuation">{</span> <span class="punctuation">.</span><span class="name">x</span> <span class="operator">=</span> <span class="literal number integer">3</span><span class="punctuation">,</span> <span class="punctuation">.</span><span class="name">y</span> <span class="operator">=</span> <span class="literal number integer">2</span> <span class="punctuation">};</span> <span class="comment single">// deduce: struct { int x, y; }
</span><span class="punctuation">}</span>
</pre>
<p>However, we have reservations about allowing this, and do not at this time propose that this example would be well-formed.</p>
</div>
</div>
<div class="section" id="future-directions">
<h1><a class="toc-backref" href="p0222r0.html#id13">Future Directions</a></h1>
<p>In the <a class="reference internal" href="p0222r0.html#discussion">Discussion</a> section above, we presented a utility for extracting the return type from a function pointer type. The facility as presented has significant limitations; namely, it does not work on member functions and the several variations (e.g. CV-qualification) which apply to the same. We do not here propose a standard library implementation of this facility, which presumably would cover these cases, however there is room to imagine that such a facility could be useful, especially if the proposals we present here are adopted. (David Krauss points out that <tt class="docutils literal"><span class="pre">std::reference_wrapper</span></tt> can be used to similar effect... on <em>some</em> compilers. However, imperfect portability and the disparity between intended function and use for this result suggest that this is not the optimal facility for the problem.)</p>
<p>Another consideration that seems likely to come up is if we should further simplify the syntax for returning multiple values (conceivably, this could apply to both anonymous structs and to <tt class="docutils literal"><span class="pre">std::pair</span></tt> / <tt class="docutils literal"><span class="pre">std::tuple</span></tt>). Some have suggested allowing that the <tt class="docutils literal">struct</tt> keyword may be omitted. In light of <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0151r0.pdf">P0151</a>, we can conceive that allowing the syntax <tt class="docutils literal">&lt;int x, double y&gt; foo()</tt> might be interesting. At this time, we prefer to focus on the feature here presented rather than risk overextending the reach of this proposal. However, if this proposal is accepted, it represents an obvious first step to considering such features in the future.</p>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="p0222r0.html#id14">Acknowledgments</a></h1>
<p>We wish to thank everyone on the <tt class="docutils literal"><span class="pre">std-proposals</span></tt> forum, especially Bengt Gustafsson and Tim Song, for their valuable feedback and insights.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="p0222r0.html#id15">References</a></h1>
<ul>
<li><p class="first"><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">N4567</a> Working Draft, Standard for Programming Language C++</p>
<p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf</a></p>
</li>
</ul>
<ul>
<li><p class="first"><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf">N4560</a> Extensions for Ranges</p>
<p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf</a></p>
</li>
</ul>
<ul>
<li><p class="first"><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf">P0144</a> Structured Bindings</p>
<p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf</a></p>
</li>
</ul>
<ul>
<li><p class="first"><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0151r0.pdf">P0151</a> Proposal of Multi-Declarators (aka Structured Bindings)</p>
<p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0151r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0151r0.pdf</a></p>
</li>
</ul>
<!-- not published as of writing; here's hoping the wg21.link link will work -->
<ul>
<li><p class="first"><a class="reference external" href="http://wg21.link/p0197">P0197</a> Default Tuple-like Access</p>
<p><a class="reference external" href="http://wg21.link/p0197">http://wg21.link/p0197</a></p>
</li>
</ul>
<ul>
<li><p class="first"><a class="reference external" href="http://wg21.link/p0224">P0224</a> Implicit Return Type</p>
<p><a class="reference external" href="http://wg21.link/p0224">http://wg21.link/p0224</a></p>
</li>
</ul>
<!-- .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. -->
<!-- kate: hl reStructuredText -->
</div>
</div>
</body>
</html>
