<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="Microsoft FrontPage 5.0" />
  <title>C++17 Filesystem - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <link href="data:text/css;charset=utf-8,body%0A%7B%0Afont%2Dfamily%3A%20arial%2C%20sans%2Dserif%3B%0Amax%2Dwidth%3A%206%2E75in%3B%0Amargin%3A%200px%20auto%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ains%20%7Bbackground%2Dcolor%3A%20%23CCFFCC%3B%20text%2Ddecoration%3A%20none%3B%7D%0Adel%20%7Bbackground%2Dcolor%3A%20%23FFCACA%3B%20text%2Ddecoration%3A%20none%3B%7D%0Apre%20%7Bbackground%2Dcolor%3A%20%23D7EEFF%3B%20font%2Dsize%3A%2095%25%3B%20font%2Dfamily%3A%20%22courier%20new%22%2C%20courier%2C%20serif%3B%7D%0Acode%20%7Bfont%2Dsize%3A%20110%25%3B%20font%2Dfamily%3A%20%22courier%20new%22%2C%20courier%2C%20serif%3B%7D%0Atable%20%7Bfont%2Dsize%3A%2090%25%3B%7D%0A%0A" rel="stylesheet" type="text/css" />
</head>
<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left">P0218R0</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2016-02-11</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library, Filesystem</td>
</tr>
</table>
<h1 id="adopt-the-file-system-ts-for-c17">Adopt the File System TS for C++17</h1>
<h2 id="introduction">Introduction</h2>
<p>Technical work on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf">N4100, <em>File System Technical Specification</em></a>, ISO/IEC TS 18822:2015, was completed in July 2014, and published by ISO in July 2015. There are three shipping implementations and one soon-to-ship implementation. Two of the shipping implementations have been have been in use for several years.</p>
<p>This document proposes adopting the File System Technical Specification, with corrections, for C++17.</p>
<p>The alternative to this proposal is to start work on version two of the File System TS. Doing nothing is not an alternative.</p>
<h3 id="isoiec-abstract-for-the-technical-specification">ISO/IEC Abstract for the Technical Specification</h3>
<blockquote>
<p>ISO/IEC TS 18822:2015 specifies requirements for implementations of an interface that computer programs written in the C++ programming language may use to perform operations on file systems and their components, such as paths, regular files, and directories. This Technical Specification is applicable to information technology systems that can access hierarchical file systems, such as those with operating systems that conform to the POSIX (3) interface. This Technical Specification is applicable only to vendors who wish to provide the interface it describes.</p>
</blockquote>
<h2 id="implementation-and-use-experience">Implementation and Use Experience</h2>
<ul>
<li><strong>Boost</strong> Has been shipping versions of the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm">Boost Filesystem Library</a> since 2003.</li>
<li><strong>Microsoft/Dinkumware</strong> Began shipping the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/msdn.microsoft.com/en-us/library/hh874694.aspx">TS version with Visual C++ 2015</a>. Previously shipped a version based on the TR1 proposal with VC++ 2012 and VC++ 2013.</li>
<li><strong>libstdc++</strong> Began shipping with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/gcc.gnu.org/gcc-5/">gcc-5.3</a> in 2015.</li>
<li><strong>libc++</strong> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/github.com/efcs/filesystem-standalone">Implemented</a>, but not yet shipping.</li>
</ul>
<h2 id="pending-issues-and-proposals">Pending Issues and Proposals</h2>
<p>The pending issues and proposals described below should be resolved by LWG in the next meeting or two, and do not block adopting the Filesystem TS for C++17.</p>
<h3 id="pending-issues">Pending issues</h3>
<p>There are twelve open Filesystem issues in the LWG Active Issues list. Ten have proposed resolution text. Most of the issues involve standardese corrections or clarifications and require no change to implementations or user code.</p>
<h3 id="pending-proposals">Pending proposals</h3>
<p>LWG issue 2611 (aka SG3 issue 11), <em>Lack of relative() operation function</em>, is a <em>NAD Future</em> issue raised by UK PDTS comment GB-1. Two solutions have been proposed â€” <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0011r0.html">P0011R0, <em>Additions to Filesystem supporting Relative Paths</em></a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r0.html">P0218R0, <em>Relative Paths for Filesystem</em></a>. The authors are working together to finalize a single proposal for the Jacksonville meeting.</p>
<h2 id="hosted-implementations-only">Hosted implementations only</h2>
<p>No change is proposed for the C++ working paper's table of &quot;C++ headers for freestanding implementations&quot; in 17.6.2.2 Headers [using.headers]. This means that header filesystem is only required for hosted implementations. See C++ 1.4 Implementation compliance [intro.compliance].</p>
<h2 id="proposed-c17-wording">Proposed C++17 Wording</h2>
<p>The proposed wording below is unchanged from the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf">File System TS wording</a>, except for section renumbering and changes shown with <del>delete</del> and <ins>insert</ins> tags. A table of contents is provided for convenience, but is not part of the proposed wording.</p>
<p><span style="background-color:lightgrey"><em>Editorial comments are shown in italics with a light gray background.</em></span></p>
<h3 id="wording-table-of-contents">Wording table of contents</h3>
<!-- include "wp.html" snippet=wpwordingTOC --><p>
<a href="p0218r0.html#File-systems">27.10  <ins>File systems&nbsp; </ins></a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#<del>Scope</del> <ins>General</ins>">27.10.1  <del>Scope</del> <ins>General</ins>&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Conformance">27.10.2  Conformance </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.conform.9945">27.10.2.1  POSIX conformance </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.conform.os">27.10.2.2  Operating system dependent behavior conformance </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.race.behavior">27.10.2.3  File system race behavior </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Normative-references">27.10.3  Normative references&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Definitions">27.10.4  Terms and definitions </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Absolute-path">27.10.4.1  absolute path </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#canonical-path">27.10.4.2  canonical path </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#directory">27.10.4.3  directory </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#file">27.10.4.4  file </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#file-system">27.10.4.5  file system </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#file-system-race">27.10.4.6  file system race </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#filename">27.10.4.7  filename </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#hard-link">27.10.4.8  hard link </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#link">27.10.4.9  link </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.def.native.encode">27.10.4.10  native encoding </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.def.native">27.10.4.11  native pathname format </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#NTCTS">27.10.4.12  NTCTS </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#operating system dependent">27.10.4.13  operating system dependent behavior 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.def.parent">27.10.4.14  parent directory </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path">27.10.4.15  path </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.def.pathname">27.10.4.16  pathname </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.def.pathres">27.10.4.17  pathname resolution </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Relative-path">27.10.4.18  relative path </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#symbolic-link">27.10.4.19  symbolic link </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.req">27.10.5  Requirements </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Namespaces-and-headers"><del>27.10.5.1  Namespaces and headers</del></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.req.macros"><del>27.10.5.2  Feature test macros</del></a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Header-filesystem-synopsis">27.10.6  Header <code>&lt;filesystem&gt;</code> synopsis 
</a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Error-reporting">27.10.7  Error reporting </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#class-path">27.10.8  Class <code>path</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path.generic">27.10.8.1  <code>path</code> generic pathname format grammar </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-Conversions">27.10.8.2  <code>path</code> conversions </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-Conversions-to-native-format">27.10.8.2.1  <code>path</code> argument format 
conversions </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path.arg.convert">27.10.8.2.2  <code>path</code> type and encoding conversions </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-Requirements">27.10.8.3  <code>path</code> requirements </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path.member">27.10.8.4  <code>path</code> members&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-constructors">27.10.8.4.1   <code>path</code> constructors </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-assignments">27.10.8.4.2  <code>path</code> assignments </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-appends">27.10.8.4.3  <code>path</code> appends 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-concatenation">27.10.8.4.4  <code>path</code> concatenation </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-modifiers">27.10.8.4.5   <code>path</code> modifiers </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-native-format-observers">27.10.8.4.6  <code>path</code> native format observers 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-generic-format-observers">27.10.8.4.7  <code>path</code> generic format observers 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-compare">27.10.8.4.8  <code>path</code> compare </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-decomposition">27.10.8.4.9   <code>path</code> decomposition 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-query">27.10.8.4.10   <code>path</code> query </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-iterators">27.10.8.5   <code>path</code> iterators </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-non-member-functions">27.10.8.6   <code>path</code> non-member functions 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path-inserter-extractor">27.10.8.6.1  <code>path</code> inserter and extractor </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#path.factory">27.10.8.6.2  <code>path</code> factory functions </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Class-filesystem_error">27.10.9  Class <code>filesystem_error</code> 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#filesystem_error-members">27.10.9.1   <code>filesystem_error</code> members 
</a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.enum">27.10.10  Enumerations&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Enum-file_type">27.10.10.1  Enum class <code>file_type</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#enum.copy_options">27.10.10.2  Enum class <code>copy_options</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#enum.perms">27.10.10.3  Enum class <code>perms</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#enum.directory_options">27.10.10.4  Enum class <code>directory_options</code> 
  </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#file_status">27.10.11  Class <code>file_status</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#file_status-constructors">27.10.11.1  <code>file_status</code> constructors 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#file_status-observers">27.10.11.2  <code>file_status</code> observers </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#file_status-modifiers">27.10.11.3  <code>file_status</code> modifiers </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Class-directory_entry">27.10.12  Class <code>directory_entry</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#directory_entry-constructors">27.10.12.1  <code>directory_entry</code> 
constructors  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#directory_entry-modifiers">27.10.12.2  <code>directory_entry</code> 
modifiers  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#directory_entry-observers">27.10.12.3  <code>directory_entry</code> 
observers  </a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Class-directory_iterator">27.10.13  Class <code>directory_iterator</code> 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#directory_iterator-members">27.10.13.1  <code>directory_iterator</code> members 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#directory_iterator-non-member-functions">27.10.13.2  <code>directory_iterator</code> non-member functions 
</a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#class.rec.dir.itr">27.10.14  Class <code>recursive_directory_iterator</code> 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#recursive_directory_iterator-members">27.10.14.1  <code>recursive_directory_iterator</code> members 
</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#rec.dir.itr.nonmembers">27.10.14.2  <code>recursive_directory_iterator</code> non-member functions 
</a><br>
&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#Operational-functions">27.10.15  Operational functions </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.absolute">27.10.15.1  Absolute&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.canonical">27.10.15.2  Canonical&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.copy">27.10.15.3  Copy&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.copy_file">27.10.15.4  Copy file&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.copy_symlink">27.10.15.5  Copy symlink&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.create_directories">27.10.15.6  Create directories&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.create_directory">27.10.15.7  Create directory&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.create_dir_symlk">27.10.15.8  Create directory symlink&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.create_hard_lk">27.10.15.9  Create hard link&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.create_symlink">27.10.15.10  Create symlink&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.current_path">27.10.15.11  Current path&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.exists">27.10.15.12  Exists&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.equivalent">27.10.15.13  Equivalent&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.file_size">27.10.15.14  File size&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.hard_lk_ct">27.10.15.15  Hard link count&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_block_file">27.10.15.16  Is block file&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_char_file">27.10.15.17  Is character file&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_directory">27.10.15.18  Is directory&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_empty">27.10.15.19  Is empty&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_fifo">27.10.15.20  Is fifo&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_other">27.10.15.21  Is other&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_regular_file">27.10.15.22  Is regular file&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_socket">27.10.15.23  Is socket&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.is_symlink">27.10.15.24  Is symlink&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.last_write_time">27.10.15.25  Last write time&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.permissions">27.10.15.26  Permissions&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.read_symlink">27.10.15.27  Read symlink&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.remove">27.10.15.28  Remove&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.remove_all">27.10.15.29  Remove all&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.rename">27.10.15.30  Rename&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.resize_file">27.10.15.31  Resize file&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.space">27.10.15.32  Space&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.status">27.10.15.33  Status&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.status_known">27.10.15.34  Status known&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.symlink_status">27.10.15.35  Symlink status&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.system_complete">27.10.15.36  System complete&nbsp; </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="p0218r0.html#fs.op.temp_dir_path">27.10.15.37  Temporary directory path&nbsp; </a><br>
</p><!-- end include --></p>
<h3 id="proposed-wording">Proposed Wording</h3>
<p><span style="background-color:lightgrey"><em>Add the following as a new sub-clause at the end of clause 27, Input/output library:</em></span></p>
<!-- include "wp.html" snippet=wpwording -->
<h2 class="page_number_reset">27.10  <ins><a name="File-systems">File systems</a>&nbsp; [<a name="filesystems">filesystems</a>]</ins></h2>


<h3 class="page_number_reset">27.10.1  <a name="Scope"><del>Scope</del> <ins>General</ins></a>&nbsp; [<a name="fs.general">fs.general</a>]</h2>

<p para_num="1">This <del>Technical Specification specifies requirements for implementations of an 
interface that computer programs written in the C++ programming language may use 
to perform</del> <ins>sub-clause describes</ins> operations on file systems and their components, such as paths, 
regular files, and directories.  <del>ThisTechnical Specification is applicable to 
information technology systems that can access hierarchical file systems, such 
as those with operating systems that conform to the POSIX (<a href="p0218r0.html#fs.norm.ref">27.10.2.1</a>) 
interface. This Technical Specification is applicable only to vendors who wish 
to provide the interface it describes.</del></p>

<h3>27.10.2  <a name="Conformance">Conformance</a> [<a name="fs.conformance">fs.conformance</a>]</h2>

<p para_num="1">Conformance is specified in terms of behavior. Ideal behavior is not always 
implementable, so the conformance sub-clauses take that into account.</p>

<h4>27.10.2.1  POSIX conformance [<a name="fs.conform.9945">fs.conform.9945</a>]</h3>
<p para_num="1">Some behavior is specified by reference to POSIX (<a href="p0218r0.html#fs.norm.ref">27.10.2.1</a>). How such behavior is actually implemented is unspecified.</p>
<blockquote>
<p para_num="2">[<i>Note:</i> This constitutes an &quot;as if&quot; rule allowing implementations 
to call native 
operating system or other API's. <i>&mdash;end note</i>]</p>
</blockquote>
<p para_num="3">Implementations are encouraged to provide such behavior as it is defined by 
POSIX. Implementations shall document any behavior that differs from the 
behavior defined by POSIX. Implementations that do not support exact POSIX 
behavior are encouraged to provide behavior as close to POSIX behavior as is reasonable given the 
limitations of actual operating systems and file systems. If an implementation cannot provide any 
reasonable behavior, the implementation shall report an error as specified in Â§ 
<a href="p0218r0.html#fs.norm.ref">27.10.7</a>.
</p>
<blockquote>
<p para_num="4">[<i>Note:</i> This allows users to rely on an exception being thrown or 
an error code being set when an implementation cannot provide any reasonable 
behavior. â€” <i>end note</i>]</p>
</blockquote>
<p para_num="5">Implementations are not required to provide behavior that is not supported by 
a particular file system.</p>
<blockquote>
<p para_num="6">[<i>Example:</i> The <a href="http://en.wikipedia.org/wiki/FAT_filesystem">
FAT file system</a> used by some memory cards, camera memory, and floppy discs 
does not support hard links, symlinks, and many other features of more capable 
file systems, so implementations are not required to support those features 
on the FAT file system. <i>&mdash;end example</i>]</p>
</blockquote>

<h4>27.10.2.2  Operating system dependent behavior conformance [<a name="fs.conform.os">fs.conform.os</a>]</h3>
<p para_num="1">Some behavior is specified as being 
operating system dependent (<a href="p0218r0.html#fs.def.osdep">27.10.4.13</a>). The operating system an 
implementation is dependent upon is implementation defined.</p>
<p para_num="2">It is permissible for an implementation to be dependent upon an operating 
system emulator rather than the actual underlying operating system.</p>

<h4>27.10.2.3  File system race behavior [<a name="fs.race.behavior">fs.race.behavior</a>]</h3>

<p para_num="1">Behavior is undefined if calls to functions provided by this <del>Technical Specification</del> <ins>sub-clause</ins> introduce a file system race (<a href="p0218r0.html#fs.def.race">27.10.4.6</a>).</p>

<p para_num="2">If the possibility of a file system race would make it unreliable for a 
program to test for a precondition before calling a function described herein, <i>
Requires</i> is not specified for the function.</p>
<blockquote>
<p para_num="3">[<i>Note:</i> As a design practice, preconditions are not specified when it 
is unreasonable for a program to detect them prior to calling the function. <i>
â€”end note</i>]</p>
</blockquote>

<h3>27.10.3  <a name="Normative-references">Normative references</a>&nbsp; [<a name="fs.norm.ref">fs.norm.ref</a>]</h2>

<p para_num="1"><del>The following referenced documents are indispensable for the application of 
this document. For dated references, only the edition cited applies. For undated 
references, the latest edition of the referenced document (including any 
amendments) applies.</del></p>

<ul>
  <li para_num="2"><del>ISO/IEC 14882, <i>Programming Language C++<br>
&nbsp;</i></del></li>
  <li para_num="3"><del>ISO/IEC 9945, <i>Information Technology â€” Portable Operating System 
  Interface (POSIX)</i></del></li>
</ul>

<p para_num="4"><del>[<i>Note:</i> The programming language and library described in ISO/IEC 14882 
is herein called <i>the C++ Standard</i>. References to clauses within the C++ 
Standard are written as &quot;Â§3.2&quot;. Section references are relative 
to <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3936.pdf">
N3936</del></a>.

<p para_num="5"><del>The operating system interface 
described in ISO/IEC 9945 is herein called <i>POSIX</i>. <i>&mdash;end note</i>]</del></p>

<p para_num="6">This 
<del>Technical Specification</del> <ins>sub-clause</ins>  mentions commercially 
available operating systems for purposes of exposition.<sup> <a href="p0218r0.html#footnote">
[footnote]</a></sup>

<p para_num="7"><del>Unless otherwise specified, the whole of the C++ 
Standard&#39;s Library introduction (Â§17) is included into this Technical 
Specification by reference.</del></p>

<blockquote>
  <p para_num="8"><sup>[<a name="footnote">footnote</a>]</sup> POSIXÂ® is 
a registered trademark of The IEEE. MAC OSÂ® is a registered trademark of Apple 
Inc. WindowsÂ® is a registered trademark of Microsoft Corporation. This information is given for the convenience of 
users of this document and does not constitute an endorsement by ISO or IEC of 
these products.</blockquote>

<h3>27.10.4  <a name="Definitions">Terms and definitions</a> [<a name="fs.definitions">fs.definitions</a>]</h2>
<p para_num="1"><del>For the purposes of this document, the terms and definitions given in the C++ 
Standard and the following apply.</del></p>

<h4>27.10.4.1  <a name="Absolute-path">absolute path</a> [<a name="fs.def.absolute-path">fs.def.absolute-path</a>]</h3>
<p para_num="1">A path that 
unambiguously 
identifies the location of a file without reference to an additional starting 
location. The elements of a path that determine if it is absolute are 
operating system dependent.</p>

<h4>27.10.4.2  <a name="canonical-path">canonical path</a> [<a name="fs.def.canonical-path">fs.def.canonical-path</a>]</h3>
<p para_num="1">An absolute path that has no elements that are symbolic links, and no dot or 
dot-dot elements (<a href="p0218r0.html#path.generic">28.10.8.1</a>).</p>
<h4>27.10.4.3  <a name="directory">directory</a> [<a name="fs.def.directory">fs.def.directory</a>]</h3>
<p para_num="1">A file within a file system that acts as a container of directory entries 
that contain information about 
other files, possibly including other directory files.</p>
<h4>27.10.4.4  <a name="file">file</a> [<a name="fs.def.file">fs.def.file</a>]</h3>
<p para_num="1">An object within a file system that holds user or system data. Files can be written to, or read from, or both. A file 
has certain attributes, including type. File types include regular files 
and directories. Other types of files, such as symbolic links, may be supported by the 
implementation.</p>
<h4>27.10.4.5  <a name="file-system">file system</a> [<a name="fs.def.filesystem">fs.def.filesystem</a>]</h3>
<p para_num="1">A collection of files and certain of their attributes.</p>
<h4>27.10.4.6  <a name="file-system-race">file system race</a> [<a name="fs.def.race">fs.def.race</a>]</h3>
<p para_num="1">The condition that occurs 
when multiple threads, processes, or computers interleave access and 
modification of 
the same object within a file system.</p>

<h4>27.10.4.7  <a name="filename">filename</a> [<a name="fs.def.filename">fs.def.filename</a>]</h3>
  <p para_num="1">The name of a file. Filenames dot&nbsp; 
and dot-dot&nbsp; have special meaning. The following characteristics of 
  filenames are operating system dependent:</p>
<ul>
  <li para_num="2">The permitted characters. [<i>Example</i>: Some operating systems prohibit the ASCII control characters (0x00-0x1F) 
    in filenames. <i>&mdash;end example</i>].
  </li>
  <li para_num="3">The maximum permitted length.</li>
  <li para_num="4">Filenames that are not permitted.</li>
  <li para_num="5">Filenames that have special meaning.</li>
  <li para_num="6">Case awareness and sensitivity during path resolution.</li>
  <li para_num="7">Special rules that may apply to file types other than regular 
  files, such as directories.</li>
</ul>
<h4>27.10.4.8  <a name="hard-link">hard link</a> [<a name="fs.def.hardlink">fs.def.hardlink</a>]</h3>
<p para_num="1">A link (<a href="p0218r0.html#fs.def.link">27.10.4.9</a>) to an existing file. Some 
file systems support multiple hard links to a file. If the last hard link to a 
file is removed, the file itself is removed.</p>
<blockquote>
<p para_num="2">[<i>Note:</i> A hard link can be thought of as a shared-ownership smart 
pointer to a file.<i> &mdash;end note</i>]<i> </i></p>
</blockquote>
<h4>27.10.4.9  <a name="link">link</a> [<a name="fs.def.link">fs.def.link</a>]</h3>
<p para_num="1">A directory entry  that associates a 
filename with a file. A link is either a hard link (<a href="p0218r0.html#fs.def.hardlink">27.10.4.8</a>) or a 
symbolic link (<a href="p0218r0.html#fs.def.symlink">27.10.4.19</a>).</p>

<h4>27.10.4.10  native encoding [<a name="fs.def.native.encode">fs.def.native.encode</a>]</h3>
<p para_num="1">For narrow character strings, the operating system dependent current encoding 
for path names. For wide character strings, the implementation defined execution 
wide-character set encoding (Â§2.3).</p>

<h4>27.10.4.11  native pathname format [<a name="fs.def.native">fs.def.native</a>]</h3>
<p para_num="1">The operating system dependent pathname format accepted by the host operating system.</p>
<h4>27.10.4.12  <a name="NTCTS">NTCTS</a> [<a name="fs.def.ntcts">fs.def.ntcts</a>]</h3>
<p para_num="1">Acronym for &quot;null-terminated character-type sequence&quot;. Describes a sequence 
of values of a given encoded character type terminated by that type's null character. If 
the encoded character type is <code>EcharT</code>, the null character can be constructed 
by <code>EcharT()</code>. </p>
<h4>27.10.4.13  <a name="operating system dependent">operating system dependent</a> behavior 
[<a name="fs.def.osdep">fs.def.osdep</a>]</h3>
<p para_num="1">Behavior  that is dependent upon the behavior 
and characteristics of an operating system. See [fs.conform.os].</p>
<h4>27.10.4.14  parent directory [<a name="fs.def.parent">fs.def.parent</a>]</h3>
<p para_num="1">When discussing a given directory, the directory that both contains a 
directory entry for the given directory and is represented by the filename 
dot-dot in the given directory.</p>
<p para_num="2">When discussing other types of files, a directory containing a directory 
entry for the file under discussion.</p>
<p para_num="3">This concept does not apply to dot and dot-dot.</p>
<h4>27.10.4.15  <a name="path">path</a> [<a name="fs.def.path">fs.def.path</a>]</h3>
<p para_num="1">A sequence of elements that identify 
the location of a file within a filesystem. The elements are the <i>root-name<sub>opt</sub></i>, <i>
root-directory<sub>opt</sub></i>, and an optional sequence of filenames. 
The maximum number of elements in the sequence is operating system dependent.
</p>

<h4>27.10.4.16  pathname [<a name="fs.def.pathname">fs.def.pathname</a>]</h3>
<p para_num="1">A character string that represents the name of a path. Pathnames are 
formatted according to the generic pathname format grammar (<a href="p0218r0.html#path.generic">27.10.8.1</a>) or an 
operating system dependent 
native pathname format.</p>

<h4>27.10.4.17  pathname resolution [<a name="fs.def.pathres">fs.def.pathres</a>]</h3>

<p para_num="1">Pathname resolution is the operating system dependent mechanism for resolving 
a pathname to a particular file in a file hierarchy. There may be multiple 
pathnames that resolve to the same file.&nbsp; [<i>Example:</i> POSIX specifies the mechanism in section 4.11, Pathname resolution. <i>
&mdash;end example]</i></p>

<h4>27.10.4.18  <a name="Relative-path">relative path</a> [<a name="fs.def.relative-path">fs.def.relative-path</a>]</h3>
<p para_num="1">A path that 
is not absolute, and so only 
unambiguously 
identifies the location of a file when resolved relative to 
an implied starting location. The elements of a path that determine if it is 
relative are operating system dependent.&nbsp; [<i>Note:</i> 
 Pathnames <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> are relative paths. <i>&mdash;end note</i>]</p>
<h4>27.10.4.19  <a name="symbolic-link">symbolic link</a> [<a name="fs.def.symlink">fs.def.symlink</a>]</h3>
<p para_num="1">A  type of file with the 
property that when the file is encountered during pathname resolution, a string 
stored by the file is used to modify the pathname resolution. </p>
<blockquote>
<p para_num="2">[<i>Note:</i> Symbolic links are often called symlinks. A symbolic link can be thought of as a raw pointer to a file. 
If the file pointed to does not exist, the symbolic link is said to be a 
&quot;dangling&quot; symbolic link.<i> &mdash;end note</i>]<i> </i></p>
</blockquote>

<h3>27.10.5  Requirements [<a name="fs.req">fs.req</a>]</h2>
<p para_num="1">Throughout this <del>Technical Specification</del> <ins>sub-clause</ins>, <code>char</code>, <code>wchar_t</code>,
<code>char16_t</code>, and <code>char32_t</code> are collectively called <i>
encoded character types</i>.</p>

<p para_num="2">Template parameters named <code>EcharT</code> shall be one of the 
encoded character types.</p>

<p para_num="3">Template parameters named <code>InputIterator</code> shall meet the 
C++ Standard&#39;s library input iterator requirements (Â§24.2.3) and shall 
have a value type that is one of the encoded character types.</p>

<blockquote>
<p para_num="4">[<i>Note:</i> Use of an encoded character type implies an associated 
encoding. Since <code>signed char</code> and <code>unsigned char</code> have no 
implied encoding, they are not included as permitted types. <i>&mdash;end note</i>]</p>

</blockquote>
<p para_num="5">Template parameters named <code>Allocator</code> shall meet the C++ 
Standard&#39;s library Allocator requirements (Â§17.6.3.5).</p>

<h4>2<del>7.10.5.1  <a name="Namespaces-and-headers">Namespaces and headers</a> [<a name="fs.req.namespace">fs.req.namespace</a>]></del></h3>


<p para_num="1"><del>The components described in this Technical Specification are experimental and 
not part of the C++ standard library. All components described in this technical 
specification are declared in namespace <code>std::filesystem::v1</code> 
or a sub-namespace thereof unless otherwise specified. The header described in 
this shall import the contents of <code>
std::filesystem::v1</code> into <code>std::filesystem</code> as 
if by</del></p>
<blockquote>
<pre para_num="2"><del>namespace std {
  namespace experimental {
    namespace filesystem {
     }
    }
  }
}</del></pre>
</blockquote>
<p para_num="3"><del>Unless otherwise specified, references to other entities described in this 
Technical Specification are assumed to be qualified with <code>std::filesystem::v1::</code>, 
and references to entities described in the C++ standard are assumed to be qualified 
with <code>std::</code>.</del></p>

<h4><del>27.10.5.2  Feature test macros [<a name="fs.req.macros">fs.req.macros</a>]</del></h3>
<p para_num="1"><del>This macro allows users to determine which version of this 
Technical Specification is supported by header <code>&lt;experimental/filesystem&gt;</code>.</del></p>
<p para_num="2"><del>Header <code>&lt;experimental/filesystem&gt;</code> shall supply 
the following macro definition:</del></p>
<blockquote>
  <div>
    <pre para_num="3"><del>#define __cpp_lib_experimental_filesystem     201406</del></pre>
  </div>
</blockquote>
<p para_num="4"><del>[<i>Note:</i> The value of macro <code>__cpp_lib_experimental_filesystem</code> 
is <i>yyyymm</i> where <i>yyyy</i> is the year and <i>mm</i> the month when the 
version of the Technical Specification was completed. <i>â€” end note</i>]</del></p>

<h3>27.10.6  <a name="Header-filesystem-synopsis">Header <code>&lt;filesystem&gt;</code> synopsis</a> 
[<a name="fs.filesystem.synopsis">fs.filesystem.synopsis</a>]</h2>
<pre para_num="1">namespace std { <del>namespace experimental {</del> namespace filesystem { <del>inline namespace v1 {</del>

  class <a href="p0218r0.html#class-path">path</a>;
  
  void swap(path&amp; lhs, path&amp; rhs) noexcept;
  size_t <a href="p0218r0.html#hash_value">hash_value</a>(const path&amp; p) noexcept;

  bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;

  path operator/ (const path&amp; lhs, const path&amp; rhs);

  template &lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);

  template &lt;class charT, class traits&gt;
  basic_istream&lt;charT, traits&gt;&amp;
  operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);

  template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;  
    path u8path(const Source&amp; source);
  template &lt;class InputIterator&gt;
    path u8path(InputIterator first, InputIterator last);

  class <a href="p0218r0.html#Class-filesystem_error">filesystem_error</a>;      
  class <a href="p0218r0.html#Class-directory_entry">directory_entry</a>;

  class <a href="p0218r0.html#Class-directory_iterator">directory_iterator</a>;

  // enable directory_iterator range-based for statements
  directory_iterator <a href="p0218r0.html#directory_iterator-non-member-functions">begin</a>(directory_iterator iter) noexcept;
  directory_iterator <a href="p0218r0.html#directory_iterator-non-member-functions">end</a>(const directory_iterator&amp;) noexcept;

  class <a href="p0218r0.html#class.rec.dir.itr">recursive_directory_iterator</a>;

  // enable recursive_directory_iterator range-based for statements
  recursive_directory_iterator <a href="p0218r0.html#rec.dir.itr.nonmembers">begin</a>(recursive_directory_iterator iter) noexcept;
  recursive_directory_iterator <a href="p0218r0.html#rec.dir.itr.nonmembers">end</a>(const recursive_directory_iterator&amp;) noexcept;

  class <a href="p0218r0.html#file_status">file_status</a>;

  struct <a name="space_info">space_info</a>
  {
    uintmax_t capacity;
    uintmax_t free; 
    uintmax_t available;
  };

  enum class <a href="p0218r0.html#enum.file_type">file_type</a>;
  enum class <a href="p0218r0.html#enum.perms">perms</a>;
  enum class <a name="copy_option" href="p0218r0.html#enum.copy_options">copy_options</a>;
  enum class <a name="symlink_option" href="p0218r0.html#enum.directory_options">directory_options</a>;

  typedef chrono::time_point&lt;<b><i>trivial-clock</i></b>&gt;  file_time_type;

  // <a href="p0218r0.html#Operational-functions">operational functions</a>

  path <a href="p0218r0.html#absolute">absolute</a>(const path&amp; p, const path&amp; base=current_path());

  path <a href="p0218r0.html#canonical">canonical</a>(const path&amp; p, const path&amp; base = current_path());
  path <a href="p0218r0.html#canonical">canonical</a>(const path&amp; p, error_code&amp; ec);
  path <a href="p0218r0.html#canonical">canonical</a>(const path&amp; p, const path&amp; base, error_code&amp; ec);

  void <a href="p0218r0.html#copy">copy</a>(const path&amp; from, const path&amp; to);
  void <a href="p0218r0.html#copy">copy</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;
  void <a href="p0218r0.html#copy">copy</a>(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> options);
  void <a href="p0218r0.html#copy">copy</a>(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> options,  
         error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#copy_file">copy_file</a>(const path&amp; from, const path&amp; to);
  bool <a href="p0218r0.html#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;
  bool <a href="p0218r0.html#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> option);
  bool <a href="p0218r0.html#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> option,
                 error_code&amp; ec) noexcept;

  void <a href="p0218r0.html#copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink);
  void <a href="p0218r0.html#copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink,
                    error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#create_directories">create_directories</a>(const path&amp; p);
  bool <a href="p0218r0.html#create_directories">create_directories</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#create_directory">create_directory</a>(const path&amp; p);
  bool <a href="p0218r0.html#create_directory">create_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#create_directory2">create_directory</a>(const path&amp; p, const path&amp; attributes);
  bool <a href="p0218r0.html#create_directory2">create_directory</a>(const path&amp; p, const path&amp; attributes,
                        error_code&amp; ec) noexcept;

  void <a href="p0218r0.html#create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink);
  void <a href="p0218r0.html#create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                                error_code&amp; ec) noexcept;

  void <a href="p0218r0.html#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link);
  void <a href="p0218r0.html#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link,
                        error_code&amp; ec) noexcept;

  void <a href="p0218r0.html#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink);
  void <a href="p0218r0.html#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                      error_code&amp; ec) noexcept;

  path <a href="p0218r0.html#current_path">current_path</a>();
  path <a href="p0218r0.html#current_path">current_path</a>(error_code&amp; ec);
  void <a href="p0218r0.html#current_path">current_path</a>(const path&amp; p);
  void <a href="p0218r0.html#current_path">current_path</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#exists">exists</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#exists">exists</a>(const path&amp; p);
  bool <a href="p0218r0.html#exists">exists</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
  bool <a href="p0218r0.html#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;

  uintmax_t <a href="p0218r0.html#file_size">file_size</a>(const path&amp; p);
  uintmax_t <a href="p0218r0.html#file_size">file_size</a>(const path&amp; p, error_code&amp; ec) noexcept;

  uintmax_t <a href="p0218r0.html#hard_link_count">hard_link_count</a>(const path&amp; p);
  uintmax_t <a href="p0218r0.html#hard_link_count">hard_link_count</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_block_file">is_block_file</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#is_block_file">is_block_file</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_block_file">is_block_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_character_file">is_character_file</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#is_character_file">is_character_file</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_character_file">is_character_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_directory">is_directory</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#is_directory">is_directory</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_directory">is_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_empty">is_empty</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_empty">is_empty</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_fifo">is_fifo</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#is_fifo">is_fifo</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_fifo">is_fifo</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_other">is_other</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#is_other2">is_other</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_other2">is_other</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_regular_file">is_regular_file</a>(file_status s) noexcept; 
  bool i<a href="p0218r0.html#is_regular_file2">s_regular_file</a>(const path&amp; p);
  bool i<a href="p0218r0.html#is_regular_file2">s_regular_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_socket">is_socket</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#is_socket">is_socket</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_socket">is_socket</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#is_symlink">is_symlink</a>(file_status s) noexcept;
  bool <a href="p0218r0.html#is_symlink2">is_symlink</a>(const path&amp; p);
  bool <a href="p0218r0.html#is_symlink2">is_symlink</a>(const path&amp; p, error_code&amp; ec) noexcept;

  file_time_type  <a href="p0218r0.html#last_write_time">last_write_time</a>(const path&amp; p);
  file_time_type  <a href="p0218r0.html#last_write_time">last_write_time</a>(const path&amp; p, error_code&amp; ec) noexcept;
  void <a href="p0218r0.html#last_write_time2">last_write_time</a>(const path&amp; p, file_time_type new_time);
  void <a href="p0218r0.html#last_write_time2">last_write_time</a>(const path&amp; p, file_time_type new_time,
                       error_code&amp; ec) noexcept;
                       
  void <a href="p0218r0.html#fs.op.permissions">permissions</a>(const path&amp; p, perms prms);
  void <a href="p0218r0.html#fs.op.permissions">permissions</a>(const path&amp; p, perms prms, error_code&amp; ec) noexcept;

  path <a href="p0218r0.html#read_symlink">read_symlink</a>(const path&amp; p);
  path <a href="p0218r0.html#read_symlink">read_symlink</a>(const path&amp; p, error_code&amp; ec);

  bool <a href="p0218r0.html#remove">remove</a>(const path&amp; p);
  bool <a href="p0218r0.html#remove">remove</a>(const path&amp; p, error_code&amp; ec) noexcept;

  uintmax_t <a href="p0218r0.html#remove_all">remove_all</a>(const path&amp; p);
  uintmax_t <a href="p0218r0.html#remove_all">remove_all</a>(const path&amp; p, error_code&amp; ec) noexcept;

  void <a href="p0218r0.html#rename">rename</a>(const path&amp; from, const path&amp; to);
  void <a href="p0218r0.html#rename">rename</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;

  void <a href="p0218r0.html#resize_file">resize_file</a>(const path&amp; p, uintmax_t size);
  void <a href="p0218r0.html#resize_file2">resize_file</a>(const path&amp; p, uintmax_t size, error_code&amp; ec) noexcept;

  <a href="p0218r0.html#space_info">space_info</a> <a href="p0218r0.html#space">space</a>(const path&amp; p);
  <a href="p0218r0.html#space_info">space_info</a> <a href="p0218r0.html#space">space</a>(const path&amp; p, error_code&amp; ec) noexcept;

  <a href="p0218r0.html#file_status">file_status</a> <a href="p0218r0.html#status">status</a>(const path&amp; p);
  <a href="p0218r0.html#file_status">file_status</a> <a href="p0218r0.html#status">status</a>(const path&amp; p, error_code&amp; ec) noexcept;

  bool <a href="p0218r0.html#status_known">status_known</a>(file_status s) noexcept;

  <a href="p0218r0.html#file_status">file_status</a> <a href="p0218r0.html#symlink_status">symlink_status</a>(const path&amp; p);
  <a href="p0218r0.html#file_status">file_status</a> <a href="p0218r0.html#symlink_status">symlink_status</a>(const path&amp; p, error_code&amp; ec) noexcept;

  path <a href="p0218r0.html#system_complete">system_complete</a>(const path&amp; p);
  path <a href="p0218r0.html#system_complete">system_complete</a>(const path&amp; p, error_code&amp; ec);

  path <a href="p0218r0.html#temp_directory_path">temp_directory_path</a>();
  path <a href="p0218r0.html#temp_directory_path">temp_directory_path</a>(error_code&amp; ec);

} }<del> } }</del></pre>

 <p para_num="2"><b><i><code>trivial-clock</code></i></b> is an implementation-defined type that satisfies the
<code>TrivialClock</code> requirements (Â§20.12.3) 
 and that is capable of representing and measuring file time values. 
 Implementations should ensure that the resolution and range of <tt>
 file_time_type</tt> reflect the operating system dependent resolution and range 
 of file time values.</p>
<h3>27.10.7  <a name="Error-reporting">Error reporting</a> [<a name="fs.err.report">fs.err.report</a>]</h2>
<p para_num="1">Filesystem library functions often provide two overloads, one that 
throws an exception to report file system errors, and another that sets an <code>error_code</code>.</p>
<blockquote>
<p para_num="2">[<i>Note:</i> This supports two common use cases:</p>
<ul>
  <li para_num="3">Uses where file system 
errors are truly exceptional and indicate a serious failure. Throwing an 
  exception is the most appropriate response. This is the preferred default for 
  most everyday programming.<br>
&nbsp;</li>
  <li para_num="4">Uses where file system  errors are routine and do not necessarily represent 
  failure. Returning an error code is the most appropriate response. This allows 
  application specific error handling, including simply ignoring the error.</li>
</ul>
  <p para_num="5"><i>&mdash;end note</i>]</p>
</blockquote>
<p para_num="6">Functions <b>not</b> having an argument of type <code>error_code&amp;</code> report errors as follows, unless otherwise specified:</p>
  <ul>
  <li para_num="7">When a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, an exception 
  of type
<code>filesystem_error</code> shall be thrown. For functions with a single path 
  argument, that argument shall be passed to the
<code>filesystem_error</code> constructor with a single path argument.&nbsp; For 
  functions with two path arguments, the first of these arguments shall be 
  passed to the
<code>filesystem_error</code> constructor as the <code>path1</code> argument, 
  and the second shall be passed as the <code>path2</code> argument. The
  <code>filesystem_error</code> constructor&#39;s <code>error_code</code> argument 
  is set as appropriate for the specific operating system dependent error. <br>
&nbsp;</li>
  <li para_num="8">Failure to allocate storage is reported by throwing an exception as described in 
  Â§17.6.5.12.<br>
&nbsp;</li>
  <li para_num="9">Destructors throw nothing.</li>
  </ul>
  <p para_num="10">Functions having an argument of type <code>error_code&amp;</code> report errors as follows, unless otherwise 
  specified:</p>
<ul>
  <li para_num="11">If a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, the
<code>error_code&amp;</code> argument is set as 
  appropriate for the specific operating system dependent error. Otherwise, <code>clear()</code> 
  is called on the
<code>error_code&amp;</code> argument.</li>
</ul>
<h3>27.10.8  <a name="class-path">Class <code>path</code> [class.path]</a></h2>
<p para_num="1">An object of class <code>path</code> represents a path (<a href="p0218r0.html#fs.def.path">27.10.4.15</a>) 
and contains a pathname (<a href="p0218r0.html#fs.def.pathname">27.10.4.16</a>). Such an object is concerned only with the lexical and syntactic aspects 
of a path. The path does not necessarily exist in external storage, and the 
pathname is not necessarily valid for the current operating 
system or for a particular file system.</p>
<pre para_num="2">namespace std { <del>namespace experimental {</del> namespace filesystem { <del>inline namespace v1 {</del>

  class path
  {
  public:
    typedef <b><i><a href="p0218r0.html#value_type">see below</a></i></b>                      value_type;
    typedef basic_string&lt;value_type&gt;       string_type;
    static constexpr value_type            preferred_separator = <b><i><a href="p0218r0.html#value_type">see below</a></i></b>;

    // <a href="p0218r0.html#path-constructors">constructors</a> and destructor
    path() noexcept;
    path(const path& p);
    path(path&amp;&amp; p) noexcept;
    template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
      path(const Source&amp; source);
    template &lt;class InputIterator&gt;
      path(InputIterator first, InputIterator last);
    template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;  
      path(const Source&amp; source, const locale&amp; loc);
    template &lt;class InputIterator&gt;
      path(InputIterator first, InputIterator last, const locale&amp; loc);
   ~path();

    // <a href="p0218r0.html#path-assignments">assignments</a>
    path&amp; operator=(const path&amp; p);
    path&amp; operator=(path&amp;&amp; p) noexcept;
    template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
      path&amp; operator=(const Source&amp; source);
    template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
      path&amp; assign(const Source&amp; source)
    template &lt;class InputIterator&gt;
      path&amp; assign(InputIterator first, InputIterator last);

    // <a href="p0218r0.html#path-appends">appends</a>
    path&amp; operator/=(const path&amp; p);
    template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
      path&amp; operator/=(const Source&amp; source);
    template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
      path&amp; append(const Source&amp; source);
    template &lt;class InputIterator&gt;
      path&amp; append(InputIterator first, InputIterator last);

    // <a href="p0218r0.html#path-concatenation">concatenation</a>
    path&amp; operator+=(const path&amp; x);
    path&amp; operator+=(const string_type&amp; x);
    path&amp; operator+=(const value_type* x);
    path&amp; operator+=(value_type x);
    template &lt;class Source&gt;
      path&amp; operator+=(const Source&amp; x);
    template &lt;class EcharT&gt;
      path&amp; operator+=(EcharT x);
    template &lt;class Source&gt;
      path&amp; concat(const Source&amp; x);
    template &lt;class InputIterator&gt;
      path&amp; concat(InputIterator first, InputIterator last);
    
    // <a href="p0218r0.html#path-modifiers">modifiers</a>
    void  <a href="p0218r0.html#path-clear">clear</a>() noexcept;
    path&amp; <a href="p0218r0.html#path-make_preferred">make_preferred</a>();
    path&amp; <a href="p0218r0.html#path-remove_filename">remove_filename</a>();
    path&amp; <a href="p0218r0.html#replace_filename">replace_filename</a>(const path&amp; replacement);
    path&amp; <a href="p0218r0.html#path-replace_extension">replace_extension</a>(const path&amp; replacement = path());
    void  <a href="p0218r0.html#path-swap">swap</a>(path&amp; rhs) noexcept;

    // <a href="p0218r0.html#path-native-format-observers">native format observers</a>
    const string_type&amp;  <a href="p0218r0.html#native">native</a>() const noexcept;
    const value_type*   <a href="p0218r0.html#c_str">c_str</a>() const noexcept;
    <a href="p0218r0.html#operator-string_type">operator string_type</a>() const;

    template &lt;class EcharT, class traits = char_traits&lt;EcharT&gt;,
              class Allocator = allocator&lt;EcharT&gt; &gt;
    basic_string&lt;EcharT, traits, Allocator&gt;
      <a href="p0218r0.html#string-template">string</a>(const Allocator&amp; a = Allocator()) const;
    std::string    <a href="p0218r0.html#string">string</a>() const;
    std::wstring   <a href="p0218r0.html#wstring">wstring</a>() const;
    std::string    <a href="p0218r0.html#u8string">u8string</a>() const;
    std::u16string <a href="p0218r0.html#u16string">u16string</a>() const;
    std::u32string <a href="p0218r0.html#u32string">u32string</a>() const;

    // <a href="p0218r0.html#path-generic-format-observers">generic format observers</a>
    template &lt;class EcharT, class traits = char_traits&lt;EcharT&gt;,
              class Allocator = allocator&lt;EcharT&gt; &gt;
    basic_string&lt;EcharT, traits, Allocator&gt;
      <a href="p0218r0.html#generic_string-template">generic_string</a>(const Allocator&amp; a = Allocator()) const;
    std::string    <a href="p0218r0.html#generic_string">generic_string</a>() const;
    std::wstring   <a href="p0218r0.html#generic_wstring">generic_wstring</a>() const;
    std::string    <a href="p0218r0.html#generic_u8string">generic_u8string</a>() const;
    std::u16string <a href="p0218r0.html#generic_u16string">generic_u16string</a>() const;
    std::u32string <a href="p0218r0.html#generic_u32string">generic_u32string</a>() const;

    // <a href="p0218r0.html#path-compare">compare</a>
    int  <a href="p0218r0.html#path-compare">compare</a>(const path&amp; p) const noexcept;
    int  <a href="p0218r0.html#path-compare">compare</a>(const string_type&amp; s) const;
    int  <a href="p0218r0.html#path-compare">compare</a>(const value_type* s) const;

    // <a href="p0218r0.html#path-decomposition">decomposition</a>
    path <a href="p0218r0.html#path-root_name">root_name</a>() const;
    path <a href="p0218r0.html#path-root_directory">root_directory</a>() const;
    path <a href="p0218r0.html#path-root_path">root_path</a>() const;
    path <a href="p0218r0.html#path-relative_path">relative_path</a>() const;
    path <a href="p0218r0.html#path-parent_path">parent_path</a>() const;
    path <a href="p0218r0.html#path-filename">filename</a>() const;
    path <a href="p0218r0.html#path-stem">stem</a>() const;
    path <a href="p0218r0.html#path-extension">extension</a>() const;

    // <a href="p0218r0.html#path-query">query</a>
    bool <a href="p0218r0.html#path-query">empty</a>() const noexcept;
    bool <a href="p0218r0.html#path-has_root_name">has_root_name</a>() const;
    bool <a href="p0218r0.html#path-has_root_directory">has_root_directory</a>() const;
    bool <a href="p0218r0.html#path-has_root_path">has_root_path</a>() const;
    bool <a href="p0218r0.html#path-has_relative_path">has_relative_path</a>() const;
    bool <a href="p0218r0.html#path-has_parent_path">has_parent_path</a>() const;
    bool <a href="p0218r0.html#path-has_filename">has_filename</a>() const;
    bool <a href="p0218r0.html#path-has_stem">has_stem</a>() const;
    bool <a href="p0218r0.html#path-has_extension">has_extension</a>() const;
    bool <a href="p0218r0.html#path-is_absolute">is_absolute</a>() const;
    bool <a href="p0218r0.html#path-is_relative">is_relative</a>() const;

    // <a href="p0218r0.html#path-iterators">iterators</a>
    class iterator;
    typedef iterator const_iterator;

    iterator begin() const;
    iterator end() const;

  private:
    string_type pathname;  // <b><i>exposition only</i></b>
  };

} }<del> } }</del></pre>

<p para_num="3"><code><a name="value_type">value_type</a></code> is a <code>typedef</code> for the 
operating system dependent encoded character type used  to represent pathnames.</p>
<p para_num="4">The value of <a name="preferred_separator"><code>preferred_separator</code></a> 
is the operating system dependent <i>preferred-separator</i> character (<a href="p0218r0.html#path.generic">27.10.8.1</a>).</p>
<blockquote>
 <p para_num="5">[<i>Example:</i> For  POSIX based operating 
      systems, <code>value_type</code> is <code>char</code> and <code>
      preferred_separator</code> is the slash character (/).&nbsp; For Windows based 
operating systems, <code>value_type</code> is <code>wchar_t</code> and <code>
      preferred_separator</code> is the backslash character (\).&nbsp; <i>&mdash;end example</i>]</p>
</blockquote>
<h4>27.10.8.1  <code>path</code> generic pathname format grammar [<a name="path.generic">path.generic</a>]</h3>
<p para_num="1"><i>pathname:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-name 
root-directory<sub>opt</sub> relative-path<sub>opt<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>root-directory relative-path<sub>opt<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>relative-path</i></p>
<p para_num="2"><i>root-name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>An 
operating system dependent name that identifies the starting location for 
absolute paths. </p>
<blockquote>
  <blockquote>
<p para_num="3">[<i>Note:</i> Many operating systems define a name 
beginning with two <i>directory-separator</i> characters as a <i>root-name</i> 
that identifies network or other resource locations. Some operating systems define a single letter followed by a colon as a drive 
specifier - a <i>root-name</i> identifying a specific device such as a disc drive. <i>&mdash;end note</i>]</p>
  </blockquote>
</blockquote>
<p para_num="4"><i>root-directory:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
directory-separator</i></p>
<p para_num="5"><i>relative-path:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
filename<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator filename</i></p>
<p para_num="6"><i>filename:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot-dot</i></p>
<p para_num="7"><i>name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>A 
sequence of characters other than <i>directory-separator</i> characters.</p>
<blockquote>
<blockquote>
<p para_num="8">[<i>Note:</i> Operating systems often place restrictions 
      on the characters that may be used in a <i>filename</i>. For wide 
      portability, users may wish to limit <i>filename</i> characters to the  POSIX Portable Filename Character Set:
      <p para_num="9">
      <tt>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>
      a b c d e f g h i j k l m n o p q r s t u v w x y z<br>
      0 1 2 3 4 5 6 7 8 9 . _ -</tt> <i><br>
      <br>
      &mdash;end note</i>]</p>
</blockquote>
</blockquote>
<p para_num="10"><i>dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The 
filename consisting solely of a single period character (.).</p>
<p para_num="11">
<i>dot-dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The 
filename consisting solely of two period characters (..).</p>
<p para_num="12">
<i>directory-separator:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slash<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slash directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preferred-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preferred-separator directory-separator</i></p>
<p para_num="13">
<i>preferred-separator:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>An 
operating system dependent directory separator character. May be a synonym for
<i>slash</i>.</p>
<p para_num="14">
<i>slash:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The slash 
character (/). </p>
<p para_num="15">Multiple successive <i>directory-separator</i> characters are considered to 
be the same as one <i>directory-separator</i> character.</p>
<p para_num="16">The filename <i>dot</i> is treated as a reference to the current directory. The filename <i>
dot-dot</i> is treated as a reference to the 
parent 
directory. What the filename <i>dot-dot</i> refers to relative to <i>
root-directory</i> is implementation-defined. Specific filenames may have special meanings for a particular 
operating system.</p>
<h4>27.10.8.2  <a name="path-Conversions"><code>path</code> conversions</a> [<a name="path.cvt">path.cvt</a>]</h3>
<h5>27.10.8.2.1  <a name="path-Conversions-to-native-format"><code>path</code> argument format 
conversions</a> [<a name="path.fmt.cvt">path.fmt.cvt</a>]</h4>

<blockquote>
<p para_num="1">[<i>Note:</i> The format conversions described in this 
      section are not applied on POSIX or Windows based operating systems 
      because on these systems:<ul>
        <li para_num="2">The generic format is acceptable as a native path.</li>
        <li para_num="3">There is no need to distinguish between native format and generic 
        format arguments.</li>
        <li para_num="4">Paths for regular files and paths for directories share the same 
        syntax.</li>
      </ul>
      <p para_num="5">&nbsp;<i>&mdash;end note</i>]
</blockquote>

<p para_num="6">Functions arguments that take character sequences representing 
paths may use the generic pathname format grammar (<a href="p0218r0.html#path.generic">27.10.8.1</a>) or 
the native pathname format (<a href="p0218r0.html#fs.def.native">4.11</a>). If and only if such 
arguments are in the generic format and the generic format is not acceptable to 
the operating system as a native path, conversion to native format shall be 
performed during the processing of the argument. </p>
<blockquote>
<p para_num="7">[<i>Note:</i> Some operating systems may have no unambiguous way to distinguish between native format and generic format arguments. 
This is by design as it simplifies use for operating systems that do not require 
disambiguation. An implementation for an operating system where disambiguation 
is required is permitted 
as an extension to distinguish between the formats. <i>
&mdash;end note</i>]</p>
</blockquote>

<p para_num="8">If the native format requires paths for regular files to be formatted 
differently from paths for directories, the path shall be treated as a directory 
path if last element is <i>directory-separator</i>, 
otherwise it shall be treated as a regular file path.</p>

<h5>27.10.8.2.2  <code>path</code> type and encoding conversions [<a name="path.arg.convert">path.type.cvt</a>]</h4>
<p para_num="1">For member function arguments that take character sequences representing 
paths and for member functions returning strings, value type and encoding 
conversion is performed if the value type of the argument or return differs from <code>
path::value_type</code>. Encoding 
and method of conversion for the argument or return value
to be converted to is determined 
by its value type:</p>
<blockquote>
  <ul>
    <li para_num="2"><code>char</code>: Encoding is the native narrow encoding (<a href="p0218r0.html#fs.def.native.encode">27.10.4.10</a>). Conversion, if any, is operating system dependent.<p para_num="3">[<i>Note:</i> 
For POSIX based operating systems <code>path::value_type</code> is <code>char</code> 
so no conversion from <code>char</code> value type arguments or to <code>char</code> 
value type returns is performed.

<p para_num="4">For Windows based operating systems, the 
native narrow encoding is determined by calling a Windows API function. <i>&mdash;end note</i>]

<p para_num="5">[<i>Note:</i> 
This results in behavior identical to other C and C++ 
standard library functions that perform file operations using narrow character 
strings to identify paths. Changing this  behavior would be surprising and error 
prone. <i>&mdash;end note</i>]</li>
    <li para_num="6"><code>wchar_t</code>: Encoding is the native wide encoding (<a href="p0218r0.html#fs.def.native.encode">27.10.4.10</a>). Conversion method is unspecified.
    <p para_num="7">[<i>Note:</i> 
For Windows based operating systems <code>path::value_type</code> is <code>wchar_t</code> 
so no conversion from <code>wchar_t</code> value type arguments or to <code>wchar_t</code> 
    value type returns is performed. <i>&mdash;end note</i>]</li>
    <li para_num="8"><code>char16_t</code>: Encoding is UTF-16. Conversion method 
is unspecified.</li><br>
    <li para_num="9"><code>char32_t</code>: Encoding is UTF-32. Conversion method 
is unspecified.
    </li>
  </ul>
</blockquote>
<p para_num="10">If the encoding being converted to has no representation for source 
characters, the resulting converted characters, if any, are unspecified.</p>

<h4>27.10.8.3  <a name="path-Requirements"><code>path</code> requirements</a> [<a name="path.req">path.req</a>]</h3>
<p para_num="1">In addition to the requirements (<a href="p0218r0.html#fs.req">5</a>), function template parameters named <code><a name="Source">Source</a></code> 
shall be one of:</p>
<ul>
  <li para_num="2"><code>basic_string&lt;EcharT, traits, Allocator&gt;</code>. A function 
  argument <code>const Source&amp;</code> <code>source</code> shall have an 
  effective range [<code>source.begin()</code>, <code>source.end()</code>).</li>
  <li para_num="3">A type meeting the input iterator requirements that iterates over a NTCTS. 
  The value type shall be an encoded character type. A function argument <code>
  const Source&amp;</code> <code>source</code> shall have an effective range&nbsp; 
  [<code>source</code>, <code>end</code>) where <code>end</code> is the first 
  iterator value with an element value equal to <code>iterator_traits&lt;Source&gt;::<wbr />value_type()</code>.</li>
  <li para_num="4">A character array that after array-to-pointer decay results in a 
  pointer to the start of a NTCTS. The value type shall be an encoded character type. A 
  function argument <code>const Source&amp;</code> <code>source</code> shall 
  have an effective range [<code>source</code>, <code>end</code>) where <code>
  end</code> is the first iterator value with an element value equal to <code>iterator_traits&lt;decay&lt;Source&gt;:<wbr />:type&gt;::value_type()</code>.</li>
</ul>

<blockquote>
  <p para_num="5">[<i>Note:</i> See path conversions (<a href="p0218r0.html#path.cvt">27.10.8.2</a>) 
  for how these value types and their encodings convert to <code>
  path::value_type</code> and its encoding. <i>&mdash;end note</i>]</p>
</blockquote>

  <p para_num="6">Arguments of type <code>Source</code> 
  shall not be null pointers.</p>

  <h4>27.10.8.4  <code>path</code> members&nbsp; [<a name="path.member">path.member</a>]</h3>

<h5>27.10.8.4.1  <a name="path-constructors"> <code>path</code> constructors</a> [<a name="path.construct">path.construct</a>]</h4>
<pre para_num="1">path() noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Constructs an object of class <code>path</code>.</p>
  <p para_num="3"><i>Postconditions:</i> <code>empty()</code>.</p>
</blockquote>
<pre para_num="4">path(const path&amp; p);
path(path&amp;&amp; p) noexcept;</pre>
<blockquote>
  <p para_num="5"><i>Effects:</i> Constructs an object of class <code>path</code> with <code>
  pathname</code> having the original value of <code>p.pathname</code>. In the 
  second form, <code>p</code> is left in a valid but unspecified state.</p>
</blockquote>
<pre para_num="6">template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
  path(const Source&amp; source);
template &lt;class InputIterator&gt;
  path(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p para_num="7"><i>Effects:</i> Constructs an object of class <code>path</code>, storing the effective range of <code>source</code> 
  (<a href="p0218r0.html#path.req">27.10.8.3</a>) 
  or the range [<code>first</code>,<code>last</code>) in <code>pathname</code>, 
  converting format and encoding if required (<a href="p0218r0.html#path.fmt.cvt">27.10.8.2.1</a>).</p>
</blockquote>
<pre para_num="8">template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
  path(const Source&amp; source, const locale&amp; loc);
template &lt;class InputIterator&gt;
  path(InputIterator first, InputIterator last, const locale&amp; loc);</pre>
  <blockquote>
  <p para_num="9"><i>Requires:</i> The value type of <code>Source</code> and <code>InputIterator</code> is <code>
  char</code>.</p>
  <p para_num="10"><i>Effects:</i> Constructs an object of class <code>path</code>, storing the effective range of <code>
  source</code> 
  or the range [<code>first</code>,<code>last</code>) in <code>pathname</code>, 
  after converting format if required and after converting the encoding as 
  follows:</p>
  <blockquote>
  <p para_num="11">If <code>value_type</code> is <code>wchar_t</code>, converts to the native 
  wide encoding (<a href="p0218r0.html#fs.def.native.encode">27.10.4.10</a>) using the <code>codecvt&lt;wchar_t, char, mbstate_t&gt;</code> 
  facet of <code>loc</code>. Otherwise a conversion is performed using the <code>
  codecvt&lt;wchar_t, char, mbstate_t&gt;</code> facet of <code>loc</code>, and then a second 
  conversion to the current narrow encoding. </p>
  </blockquote>
  <p para_num="12">[<i>Example</i>:</p>
    <blockquote>
  <p para_num="13">A string is to be read from a database 
  that is encoded in ISO/IEC 8859-1, and used to create a directory:</p>
      <pre para_num="14">namespace fs = std::filesystem;
std::string latin1_string = read_latin1_data();
codecvt_8859_1&lt;wchar_t&gt; latin1_facet;
std::locale latin1_locale(std::locale(), latin1_facet);
fs::create_directory(fs::path(latin1_string, latin1_locale));</pre>
    <p para_num="15">For POSIX based operating systems the path is constructed by first using <code>
    latin1_facet</code> to convert ISO/IEC 8859-1 encoded
    <code>latin1_string</code> to a wide character string in the native wide 
    encoding (<a href="p0218r0.html#fs.def.native.encode">27.10.4.10</a>). The resulting wide string is then 
    converted to a narrow character
    <code>pathname</code> string in the current native narrow encoding. If the 
    native wide encoding is UTF-16 or UTF-32, and the current native narrow 
    encoding is UTF-8, all of the characters in the ISO/IEC 8859-1 character set 
    will be converted to their Unicode representation, but for other native 
    narrow encodings some characters may have no representation. </p>                                                   
    <p para_num="16">For Windows based operating systems the path is constructed by 
    using <code>latin1_facet</code> to convert ISO/IEC 8859-1 encoded <code>
    latin1_string</code> to a UTF-16 encoded wide character <code>pathname</code> 
    string. All of the characters in the ISO/IEC 8859-1 character set will be 
    converted to their Unicode representation.</p>                                                   
    </blockquote>
<p para_num="17"> <i>&mdash;end example]</i> </p>
</blockquote>
<h5>27.10.8.4.2  <a name="path-assignments"><code>path</code> assignments</a> [<a name="path.assign">path.assign</a>]</h4>
<pre para_num="1">path&amp; operator=(const path&amp; p);</pre>
<blockquote>
  <p para_num="2"><i>Effects: </i>If <code>*this</code> and <code>p</code> are the same 
  object, has no effect. Otherwise, modifies <code>pathname</code> to have the 
  original value of <code>p.pathname</code>.</p>
  <p para_num="3">
  <i>Returns: </i><code>*this</code></p>
</blockquote>
<pre para_num="4">path&amp; operator=(path&amp;&amp; p) noexcept;</pre>
<blockquote>
  <p para_num="5"><i>Effects: </i>If <code>*this</code> and <code>p</code> are the same 
  object, has no effect. Otherwise, modifies <code>pathname</code> to have the 
  original value of <code>p.pathname</code>.&nbsp; <code>p</code> is left in a 
  valid but unspecified state. [<i>Note:</i> A valid implementation is <code>
  swap(p)</code>. <i>â€”end note</i>]</p>
  <p para_num="6">
  <i>Returns: </i><code>*this</code></p>
</blockquote>
<pre para_num="7">template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
  path&amp; operator=(const Source&amp; source);
template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
  path&amp; assign(const Source&amp; source);
template &lt;class InputIterator&gt;
  path&amp; assign(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p para_num="8"><i>Effects:</i> Stores the effective range of <code>source</code> (<a href="p0218r0.html#path.req">27.10.8.3</a>) 
  or the range [<code>first</code>,<code>last</code>) in <code>pathname</code>, 
  converting format and encoding if required (<a href="p0218r0.html#path.arg.convert">27.10.8.2.1</a>). </p>
  <p para_num="9">
  <i>Returns: </i><code>*this</code></p>
  </blockquote>
<h5>27.10.8.4.3  <a name="path-appends"><code>path</code> appends</a> 
[path.append]</h4>
  <p para_num="1">The append operations use <code>
  operator/=</code> to denote their semantic effect of appending <i>
  preferred-separator</i> when needed. </p>
<pre para_num="2">path&amp; <a name="operator-slash-eq">operator/=</a>(const path&amp; p);</pre>
<blockquote>
  <p para_num="3"><i>Effects:</i></p>
  <blockquote>
    Appends <code>path::preferred_separator</code> to <code>pathname</code> unless:<ul>
    <li para_num="4">an added separator 
    would be redundant, or</li>
    <li para_num="5">would change a relative path to an absolute path
    [<i>Note</i>: An empty path is relative. â€” <i>end note</i>], or</li>
    <li para_num="6"><code>p.empty()</code>, or</li>
    <li para_num="7"><code>*p.native().cbegin()</code> is a directory separator.</li>
  </ul>
    <p para_num="8">Then appends <code>p.native()</code> to <code>pathname</code>.</p>
  </blockquote>
  <p para_num="9"><i>Returns: </i><code>*this</code></p>
</blockquote>
<pre para_num="10"><a name="append-source">template</a> &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
  path&amp; operator/=(const Source&amp; source);
template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;
  path&amp; append(const Source&amp; source);
template &lt;class InputIterator&gt;
  path&amp; append(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p para_num="11"><i>Effects:</i></p>
  <blockquote>
    <p para_num="12">Appends <code>path::preferred_separator</code> to <code>pathname</code>, 
    converting format and encoding if required (<a href="p0218r0.html#path.arg.convert">27.10.8.2.1</a>), unless:</p>
    <ul>
    <li para_num="13">an added separator 
    would be redundant, or</li>
    <li para_num="14">would change an relative path to an absolute path, or</li>
    <li para_num="15"><code>source.empty()</code>, or</li>
    <li para_num="16"><code>*source.native().cbegin()</code> is a separator.</li>
  </ul>
    <p para_num="17">Appends the effective range of <code>source</code> (<a href="p0218r0.html#path.req">27.10.8.3</a>) 
    or the range [<code>first</code>,<code>last</code>) to <code>pathname</code>, 
    converting format and encoding if required (<a href="p0218r0.html#path.arg.convert">27.10.8.2.1</a>).</p>
  </blockquote>
  <p para_num="18"><i>Returns: </i><code>*this</code></p>
  </blockquote>
  
<h5>27.10.8.4.4  <a name="path-concatenation"><code>path</code> concatenation</a> [<a name="path.concat">path.concat</a>]</h4>
<pre para_num="1">path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(const value_type* x);
path&amp; operator+=(value_type x);
template &lt;class Source&gt;
  path&amp; operator+=(const Source&amp; x);
template &lt;class EcharT&gt;
  path&amp; operator+=(EcharT x);
template &lt;class Source&gt;
  path&amp; concat(const Source&amp; x);
template &lt;class InputIterator&gt;
  path&amp; concat(InputIterator first, InputIterator last);</pre>
<blockquote><p para_num="2"><i>Postcondition:</i> <code>native() == prior_native + <i>effective-argument</i></code>,
 where <code>prior_native</code> is <code>native()</code> prior to the call to <code>operator+=</code>,
 and <code><i>effective-argument</i></code> is:</p>
 <ul><li para_num="3"><code>x.native()</code> if <code>x</code> is present and is <code>const path&amp;</code>, otherwise</li>
 <li para_num="4">the effective range <code>source</code> (<a href="p0218r0.html#path.req">27.10.8.3</a>), 
 if <code>source</code> is present, otherwise,</li>
 <li para_num="5">the range [<code>first</code>,<code>last</code>),
 if <code>first</code> and
 <code>last</code> are present, otherwise,</li>
 <li para_num="6"><code>x</code>.</li></ul><p para_num="7">If the value type of <code><i>effective-argument</i></code> would not be <code>path::value_type</code>, 
  the actual argument or argument range is first converted (<a href="p0218r0.html#path.arg.convert">27.10.8.2.1</a>) so that <code><i>effective-argument</i></code> has value type <code>path::value_type</code>.</li> </p>
 <p para_num="8"><i>Returns: </i><code>*this</code></p>
 </blockquote>
<h5>27.10.8.4.5  <a name="path-modifiers"> <code>path</code> modifiers</a> [path.modifiers]</h4><pre>void <a name="path-clear">clear</a>() noexcept;</pre>
<blockquote>
<p para_num="1"><i>Postcondition:</i> <code>empty()</code></p>
</blockquote>
<pre para_num="2">path&amp; <a name="path-make_preferred">make_preferred</a>();</pre>
<blockquote>
  <p para_num="3"><i>Effects: </i>Each <i>directory-separator</i> 
  is converted to <i>preferred-separator</i>.</p>
  <p para_num="4"><i>Returns:</i> <code>*this</code></p>
<p para_num="5">[<i>Example:</i></p>
  <blockquote>
    <pre para_num="6">path p(&quot;foo/bar&quot;);
std::cout &lt;&lt; p &lt;&lt; '\n';
p.make_preferred();
std::cout &lt;&lt; p &lt;&lt; '\n';</pre>
  </blockquote>
  <p para_num="7">On an operating system where <i>preferred-separator</i> is the same as <i>
  directory-separator</i>, the output is:</p>
  <blockquote>
    <pre para_num="8">&quot;foo/bar&quot;
&quot;foo/bar&quot;</pre>
  </blockquote>
  <p para_num="9">On an operating system where <i>preferred-separator</i> is a backslash, the 
  output is:</p>
  <blockquote>
    <pre para_num="10">&quot;foo/bar&quot;
&quot;foo\bar&quot;</pre>
  </blockquote>
  <p para_num="11"> <i>&mdash;end example</i>]</p>
</blockquote>

<pre para_num="12">path&amp; <a name="path-remove_filename">remove_filename</a>();</pre>
<blockquote>
  <p para_num="13"><i>Postcondition:</i> <code>!has_filename()</code>.</p>
  <p para_num="14"><i>Returns: </i> <code>*this</code>.</p>
  <p para_num="15">[<i>Example:</i></p>
  <blockquote>
    <pre para_num="16">std::cout &lt;&lt; path(&quot;/foo&quot;).remove_filename();  // outputs &quot;/&quot;
std::cout &lt;&lt; path(&quot;/&quot;).remove_filename();     // outputs &quot;&quot;</pre>
  </blockquote>
  <p para_num="17"> <i>&mdash;end example</i>]</p>
</blockquote>

<pre para_num="18">path&amp; <a name="replace_filename">replace_filename</a>(const path&amp; replacement);</pre>
<blockquote>
  <p para_num="19"><i>Effects:</i></p>
  <blockquote>
    <p para_num="20"><code>remove_filename();<br>
    operator/=(replacement);</code></p>
  </blockquote>
  <p para_num="21"><i>Returns: </i> <code>*this</code>.</p>
  <p para_num="22">[<i>Example:</i></p>
  <blockquote>
    <pre para_num="23">std::cout &lt;&lt; path(&quot;/foo&quot;).replace_filename(&quot;bar&quot;);  // outputs &quot;/bar&quot;
std::cout &lt;&lt; path(&quot;/&quot;).replace_filename(&quot;bar&quot;);     // outputs &quot;bar&quot;</pre>
  </blockquote>
  <p para_num="24"> <i>&mdash;end example</i>]</p>
</blockquote>
<pre para_num="25">path&amp; <a name="path-replace_extension">replace_extension</a>(const path&amp; replacement = path());</pre>
<blockquote>
  <p para_num="26"><i>Effects:</i></p>
  <ul>
    <li para_num="27">Any existing <code><a href="p0218r0.html#path-extension">extension()</a>(</code><a href="p0218r0.html#path.decompose">27.10.8.4.9</a><code>)</code> is removed from the stored path, 
    then</li>
    <li para_num="28">If <code>replacement</code> is not empty and does not begin with a dot 
    character, a dot character is appended to the stored path, then</li>
    <li para_num="29">
  <code>replacement</code> is concatenated to the stored path.</li>
  </ul>
  <p para_num="30"><i>Returns:</i> <code>*this</code></p>
</blockquote>
<pre para_num="31">void <a name="path-swap">swap</a>(path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="32"><i>Effects:</i> Swaps the contents of the two paths.</p>
  <p para_num="33"><i>Complexity: </i>constant time.</p>
</blockquote>

<h5>27.10.8.4.6  <a name="path-native-format-observers"><code>path</code> native format observers</a> 
[path.native.obs]</h4>
<p para_num="1">The string returned by all native format observers is in the <a href="p0218r0.html#fs.def.native">native pathname format</a>.</p>
<pre para_num="2">const string_type&amp;  <a name="native">native</a>() const noexcept;</pre>
<blockquote>
<p para_num="3"><i>Returns:</i> <code>pathname</code>.</p>
</blockquote>
<pre para_num="4">const value_type* <a name="c_str">c_str</a>() const noexcept;</pre>
<blockquote>
<p para_num="5"><i>Returns:</i> <code>pathname.c_str()</code>.</p>
</blockquote>
<pre para_num="6"><a name="operator-string_type">operator</a> string_type() const;</pre>
<blockquote>
  <p para_num="7"><i>Returns: </i><code>pathname</code>.</p>
  <p para_num="8">[<i>Note:</i> Conversion to <code>string_type</code> is provided so that an 
  object of class <code>path</code> can be given as an argument to existing 
  standard library file stream constructors and open functions. This provides 
  basic interoperability without the need to modify existing standard library 
  classes or headers. <i>&mdash;end note</i>]</p>
</blockquote>
<pre para_num="9">template &lt;class EcharT, class traits = char_traits&lt;EcharT&gt;,
          class Allocator = allocator&lt;EcharT&gt; &gt;
basic_string&lt;EcharT, traits, Allocator&gt;
  <a name="string-template">string</a>(const Allocator& a = Allocator()) const;</pre>


<blockquote>
  <p para_num="10"><i>Returns:</i> <code>pathname</code>.</p>
<p para_num="11"><i>Remarks:</i> All memory allocation, including for the return value, shall 
be performed by <code>a</code>. Conversion, if any, is specified by
<a href="p0218r0.html#path.cvt">27.10.8.2</a>.</p>
</blockquote>
<pre para_num="12">std::string <a name="string">string</a>() const;
std::wstring <a name="wstring">wstring</a>() const;
std::string <a name="u8string">u8string</a>() const;
std::u16string <a name="u16string">u16string</a>() const;
std::u32string <a name="u32string">u32string</a>() const; </pre>
<blockquote>
<p para_num="13"><i>Returns:</i> <code>pathname</code>.</p>
<p para_num="14"><i>Remarks:</i> Conversion, if any, is performed as specified 
by <a href="p0218r0.html#path.cvt">27.10.8.2</a>. 
The encoding of the string returned by <code>u8string()</code> is always UTF-8.</p>
</blockquote>

<h5>27.10.8.4.7  <a name="path-generic-format-observers"><code>path</code> generic format observers</a> 
[path.generic.obs]</h4>
<p para_num="1">Generic format observer functions return strings formatted according to the 
generic pathname format (<a href="p0218r0.html#path.generic">27.10.8.1</a>). 
The forward slash (<code>'/'</code>) character is used as the <i>
directory-separator</i> character.</p>
<blockquote>
<p para_num="2">[<i>Example:</i> On an operating system that uses backslash as 
its preferred-separator,&nbsp; <code>path(&quot;foo\\bar&quot;).generic_string()</code> 
returns <code>&quot;foo/bar&quot;</code>. <i>&mdash;end example</i>]</p>
</blockquote>

<pre para_num="3">template &lt;class EcharT, class traits = char_traits&lt;EcharT&gt;,
          class Allocator = allocator&lt;EcharT&gt; &gt;
basic_string&lt;EcharT, traits, Allocator&gt;
  <a name="generic_string-template">generic_string</a>(const Allocator& a = Allocator()) const;</pre>

<blockquote>
  <p para_num="4"><i>Returns:</i> <code>pathname</code>, reformatted according to the generic 
  pathname format (<a href="p0218r0.html#path.generic">27.10.8.1</a>). </p>
<p para_num="5"><i>Remarks:</i> All memory allocation, including for the return value, shall 
be performed by <code>a</code>. Conversion, if any, is specified by
<a href="p0218r0.html#path.cvt">27.10.8.2</a>.</p>
</blockquote>
<pre para_num="6">std::string <a name="generic_string">generic_string</a>() const;
std::wstring <a name="generic_wstring">generic_wstring</a>() const;
std::string <a name="generic_u8string">generic_u8string</a>() const;
std::u16string <a name="generic_u16string">generic_u16string</a>() const;
std::u32string <a name="generic_u32string">generic_u32string</a>() const; </pre>
<blockquote>
<p para_num="7"><i>Returns:</i> <code>pathname</code>, reformatted according to the generic 
pathname format (<a href="p0218r0.html#path.generic">27.10.8.1</a>).</p>
<p para_num="8"><i>Remarks:</i>&nbsp; Conversion, if any, is specified by
<a href="p0218r0.html#path.cvt">27.10.8.2</a>. 
The encoding of the string returned by <code>generic_u8string()</code> is always 
UTF-8.</p>
</blockquote>

<h5>27.10.8.4.8  <a name="path-compare"><code>path</code> compare</a> [path.compare]</h4>
<pre para_num="1">int compare(const path&amp; p) const noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> A value less than 0 if <code>native()</code> for the elements of <code>*this</code> are lexicographically less than
  <code>native()</code> for the elements of <code>p</code>, otherwise a 
  value greater than 0 if <code>native()</code> for the elements of <code>*this</code> are 
  lexicographically greater than <code>native()</code> for the elements of <code>p</code>, otherwise 0.</p>
  <p para_num="3">Remark: The elements are determined as if by iteration over the half-open 
  range [<code>begin()</code>, <code>end()</code>) for <code>*this</code> and&nbsp; <code>p</code>.</p>
</blockquote>
<pre para_num="4">int compare(const string_type&amp; s) const</pre>
<blockquote>
  <p para_num="5"><i>Returns:</i> <code>compare(path(s))</code>.</p>
</blockquote>
<pre para_num="6">int compare(const value_type* s) const</pre>
<blockquote>
  <p para_num="7"><i>Returns:</i> <code>compare(path(s))</code>.</p>
</blockquote>
<h5>27.10.8.4.9  <a name="path-decomposition"> <code>path</code> decomposition</a> 
[<a name="path.decompose">path.decompose</a>]</h4>
<pre para_num="1">path <a name="path-root_name">root_name</a>() const;</pre>
<blockquote>
<p para_num="2"><i>Returns:</i> <i>root-name,</i> if <code>pathname</code> includes <i>root-name</i>, otherwise <code>path()</code>. </p>
</blockquote>
<pre para_num="3">path <a name="path-root_directory">root_directory</a>() const;</pre>
<blockquote>
<p para_num="4"><i>Returns:</i> <i>root-directory</i>, if <code>pathname</code> includes <i>root-directory</i>, otherwise <code>path()</code>.</p>
<p para_num="5">If <i>root-directory</i> is composed of <i>slash name</i>, <i>slash</i> is 
excluded from the returned string.</p>
</blockquote>
<pre para_num="6">path <a name="path-root_path">root_path</a>() const;</pre>
<blockquote>
  <p para_num="7"><i>Returns:</i> <code>root_name() / root_directory()</code></p>
</blockquote>
<pre para_num="8">path <a name="path-relative_path">relative_path</a>() const;</pre>
<blockquote>
<p para_num="9"><i>Returns:</i> A <code>path</code> composed from <code>pathname</code>, if <code>!empty()</code>, beginning 
with the first <i>filename</i> after <i>root-path</i>. Otherwise, <code>path()</code>.</p>
</blockquote>
<pre para_num="10">path <a name="path-parent_path">parent_path</a>() const;</pre>
<blockquote>
  <p para_num="11"><i>Returns:</i> <code>(empty() || begin() == --end()) ? path() : <i>pp</i></code>, where <code><i>pp</i></code> is constructed as if by 
  starting with an empty <code>path</code> and successively applying <code>operator/=</code> for each element in the range 
  [<code>begin()</code>, <code>--end()</code>).</p>
</blockquote>
<pre para_num="12">path <a name="path-filename">filename</a>() const;</pre>
<blockquote>
  <p para_num="13"><i>Returns:</i> <code>empty() ? path() : *--end()</code></p>
  <p para_num="14">[<i>Example:</i></p>
  <blockquote>
    <pre para_num="15">std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).filename(); // outputs &quot;bar.txt&quot;
std::cout &lt;&lt; path(&quot;/&quot;).filename();            // outputs &quot;/&quot;
std::cout &lt;&lt; path(&quot;.&quot;).filename();            // outputs &quot;.&quot;
std::cout &lt;&lt; path(&quot;..&quot;).filename();           // outputs &quot;..&quot;</pre>
  </blockquote>
  <p para_num="16"> <i>&mdash;end example</i>]</p>
</blockquote>
<pre para_num="17">path <a name="path-stem">stem</a>() const;</pre>
<blockquote>
  <p para_num="18"><i>Returns:</i> if <code>filename()</code> contains a period but does not 
  consist solely of one or two periods, returns 
  the substring of <code>filename()</code> starting at its beginning and 
  ending with the character before the last period. Otherwise, 
  returns <code>filename()</code>.</p>
  <p para_num="19">[<i>Example:</i></p>
  <blockquote>
    <pre para_num="20">std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).stem(); // outputs &quot;bar&quot;
path p = &quot;foo.bar.baz.tar&quot;;
for (; !p.extension().empty(); p = p.stem())
  std::cout &lt;&lt; p.extension() &lt;&lt; '\n';
  // outputs: .tar
  //          .baz
  //          .bar</pre>
  </blockquote>
  <p para_num="21"> <i>&mdash;end example</i>]</p>
</blockquote>
<pre para_num="22">path <a name="path-extension">extension</a>() const;</pre>
<blockquote>
  <p para_num="23"><i>Returns:</i> if <code>filename()</code> contains a period but does not 
  consist solely of one or two periods, returns 
  the substring of <code>filename()</code> starting at the rightmost period 
  and for the remainder of the path. Otherwise, returns an empty <code>path</code> object. </p>
  <p para_num="24"><i>Remarks:</i> Implementations are permitted to define additional 
  behavior for file systems which append additional elements to extensions, such 
  as alternate data streams or partitioned dataset names.</p>
  <p para_num="25">[<i>Example:</i></p>
  <blockquote>
    <pre para_num="26"><code>std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).extension(); //</code> outputs &quot;<code>.txt</code>&quot;</pre>
  </blockquote>
  <p para_num="27"> <i>&mdash;end example</i>]</p>
  <p para_num="28">[<i>Note:<b> </b></i>The period is included in the return value so that it is 
  possible to distinguish between no extension and an empty extension. Also note 
  that for a path <code>p</code>, <code>p.stem()+p.extension() == p.filename()</code>. <i>
  &mdash;end note</i>]</p>
</blockquote>
<h5>27.10.8.4.10  <a name="path-query"> <code>path</code> query</a> [path.query]</h4>
<pre para_num="1">bool <a name="path-empty">empty</a>() const noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>pathname.empty()</code>.</p>
</blockquote>
<pre para_num="3">bool <a name="path-has_root_path">has_root_path</a>() const;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>!<a href="p0218r0.html#path-root_path">root_path</a>().empty()</code></p>
</blockquote>
<pre para_num="5">bool <a name="path-has_root_name">has_root_name</a>() const;</pre>
<blockquote>
  <p para_num="6"><i>Returns:</i> <code>!<a href="p0218r0.html#path-root_name">root_name</a>().empty()</code></p>
</blockquote>
<pre para_num="7">bool <a name="path-has_root_directory">has_root_directory</a>() const;</pre>
<blockquote>
  <p para_num="8"><i>Returns:</i> <code>!<a href="p0218r0.html#path-root_directory">root_directory</a>().empty()</code></p>
</blockquote>
<pre para_num="9">bool <a name="path-has_relative_path">has_relative_path</a>() const;</pre>
<blockquote>
  <p para_num="10"><i>Returns:</i> <code>!<a href="p0218r0.html#path-relative_path">relative_path</a>().empty()</code></p>
</blockquote>
<pre para_num="11">bool <a name="path-has_parent_path">has_parent_path</a>() const;</pre>
<blockquote>
  <p para_num="12"><i>Returns:</i> <code>!<a href="p0218r0.html#path-parent_path">parent_path</a>().empty()</code></p>
</blockquote>
<pre para_num="13">bool <a name="path-has_filename">has_filename</a>() const;</pre>
<blockquote>
  <p para_num="14"><i>Returns:</i> <code>!<a href="p0218r0.html#path-filename">filename</a>().empty()</code></p>
</blockquote>
<pre para_num="15">bool <a name="path-has_stem">has_stem</a>() const;</pre>
<blockquote>
  <p para_num="16"><i>Returns:</i> <code>!<a href="p0218r0.html#path-stem">stem</a>().empty()</code></p>
</blockquote>
<pre para_num="17">bool <a name="path-has_extension">has_extension</a>() const;</pre>
<blockquote>
  <p para_num="18"><i>Returns:</i> <code>!<a href="p0218r0.html#path-extension">extension</a>().empty()</code></p>
</blockquote>
<pre para_num="19">bool <a name="path-is_absolute">is_absolute</a>() const;</pre>
<blockquote>
  <p para_num="20"><i>Returns:</i> <code>true</code> if <code>pathname</code> 
  contains an absolute path (<a href="p0218r0.html#fs.def.absolute-path">27.10.4.1</a>), else <code>false</code>.</p>
<p para_num="21">[<i>Example:</i> <code>path(&quot;/&quot;).is_absolute()</code> is
      <code>true</code> for  POSIX based operating systems, and <code>false</code> for Windows based 
operating systems.&nbsp; <i>&mdash;end example</i>]</p>
</blockquote>
<pre para_num="22">bool <a name="path-is_relative">is_relative</a>() const;</pre>
<blockquote>
  <p para_num="23"><i>Returns:</i> <code>!is_absolute()</code>.</p>
</blockquote>
<h4>27.10.8.5  <a name="path-iterators"> <code>path</code> iterators</a> [path.itr]</h3>
<p para_num="1"> Path iterators iterate over the elements of the stored pathname.</p>
<p para_num="2"> A <code>path::iterator</code> is a constant iterator satisfying all the 
requirements of a bidirectional iterator (Â§24.1.4 Bidirectional 
iterators). Its <code>value_type</code> is <code>path</code>.</p>
  <p para_num="3">Calling any non-const member function of a <code>path</code> object 
  invalidates all iterators referring to elements of that object.</p>
<p para_num="4"> The forward traversal order is as follows:</p>
<ul>
  <li para_num="5">The <i>root-name</i> element, if present.</li>
  <li para_num="6">The <i>root-directory</i> element, if present, in the generic format. <i>
  [note:</i> the generic format is required to ensure lexicographical 
  comparison works correctly. <i>&mdash;end note</i>]</li>
  <li para_num="7">Each successive <i>filename</i> element, if present.</li>
  <li para_num="8"><i>Dot</i>, if one or more trailing non-root <i>slash</i> 
  characters are present.</li>
</ul>
  <p para_num="9">The backward traversal order is the reverse of forward traversal.</p>
  <pre para_num="10">iterator begin() const;</pre>
<blockquote>
  <p para_num="11"><i>Returns:</i> An iterator for the first present element in the traversal 
  list above. If no elements are present, the end iterator.</p>
</blockquote>
<pre para_num="12">iterator end() const;</pre>
<blockquote>
  <p para_num="13"><i>Returns:</i> The end iterator.</p>
</blockquote>
 <p><h4>27.10.8.6  <a name="path-non-member-functions"> <code>path</code> non-member functions</a> 
[path.non-member]</h3>
<pre para_num="1">void swap(path&amp; lhs, path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects: </i><code>lhs.swap(rhs)</code>.</p>
</blockquote>
<pre para_num="3">size_t <a name="hash_value">hash_value</a> (const path&amp; p) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> A hash value for the path <code>p</code>. If
  for two paths, <code>p1 == p2</code> then <code>hash_value(p1) == hash_value(p2)</code>.</p>
</blockquote>
<pre para_num="5">bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="6"><i>Returns:</i> <code>return lhs.compare(rhs) &lt; 0</code>.</p>
</blockquote>
<pre para_num="7">bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="8"><i>Returns:</i> <code>!(rhs &lt; lhs)</code>.</p>
</blockquote>
<pre para_num="9">bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="10"><i>Returns:</i> <code>rhs &lt; lhs</code>.</p>
</blockquote>
<pre para_num="11">bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="12"><i>Returns:</i> <code>!(lhs &lt; rhs)</code>.</p>
</blockquote>
<pre para_num="13">bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="14"><i>Returns:</i> <code>!(lhs &lt; rhs) &amp;&amp; !(rhs &lt; lhs)</code>.</p>
  <p para_num="15">[<i>Note:</i> <a name="Path-equality">Path equality</a> and path 
  equivalence have different semantics.</p>
  <p para_num="16">Equality is determined by the <code>path</code> non-member <code>operator==</code>, which considers the two path's lexical 
  representations only. Thus <code>path(&quot;foo&quot;) == &quot;bar&quot;</code> is never <code>true</code>.</p>
  <p para_num="17">Equivalence is determined by the <a href="p0218r0.html#equivalent"><code>equivalent()</code></a> non-member function, which determines if two paths <a href="p0218r0.html#class-path">resolve</a> to the same file system entity. 
  Thus <code>equivalent(&quot;foo&quot;, &quot;bar&quot;)</code> will be <code>true</code> when both paths resolve to the same file.</p>
  <p para_num="18">Programmers wishing to determine if two paths are &quot;the same&quot; must decide if 
  &quot;the same&quot; means &quot;the same representation&quot; or &quot;resolve to the same actual 
  file&quot;, and choose the appropriate function accordingly. <i>&mdash;end note</i>]</p>
</blockquote>
<pre para_num="19">bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="20"><i>Returns:</i> <code>!(lhs == rhs)</code>.</p>
</blockquote>
<pre para_num="21">path operator/ (const path&amp; lhs, const path&amp; rhs);</pre>
<blockquote>
  <p para_num="22"><i>Returns:</i> <code>path(lhs) /= rhs</code>.</p>
</blockquote>
<h5>27.10.8.6.1  <a name="path-inserter-extractor"><code>path</code> inserter and extractor</a> [path.io]</h4>
<pre para_num="1">template &lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> <code>os </code>
  <tt>&lt;&lt; quoted(p.string&lt;charT, traits&gt;())</tt>. </p>
  <p para_num="3">[<i>Note</i>: The <code>quoted</code> function is described in 
   Â§27.7.6. &mdash; <i>end note</i>] </p>
  <p para_num="4"><i>Returns:</i> <code>os</code></p>
  </blockquote>
<pre para_num="5">template &lt;class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);</pre>
<blockquote>
  <p para_num="6"><i>Effects:&nbsp; </i></p>
  <blockquote>
    <pre para_num="7">basic_string&lt;charT, traits&gt; tmp;
is &gt;&gt; quoted(tmp);
p = tmp;</pre>
  </blockquote>
  <p para_num="8"><i>Returns:</i> <code>is</code></p>
  </blockquote>
<h5>27.10.8.6.2  <a name="path.factory"><code>path</code> factory functions [path.factory]</a></h4>
<pre para_num="1">template &lt;class <a href="p0218r0.html#Source">Source</a>&gt;  
  path u8path(const Source&amp; source);
template &lt;class InputIterator&gt;
  path u8path(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p para_num="2"><i>Requires:</i> The <code>source</code> and [<code>first</code>,<code>last</code>) 
  sequences are UTF-8 encoded. The value type of <code>
  Source</code> and <code>
  InputIterator</code> is <code>char</code>. </p>
  <p para_num="3"><i>Returns:</i></p>
  <blockquote>
    <ul>
      <li para_num="4">If <code>value_type</code> is <code>char</code> and the current native 
      narrow encoding (<a href="p0218r0.html#fs.def.native.encode">27.10.4.11</a>) is UTF-8, <code>path(source)</code> or <code>path(first, last)</code>, 
      else</li>
      <li para_num="5">if <code>value_type</code> is <code>wchar_t </code>and the 
      native wide encoding is UTF-16, or if <code>value_type</code> is <code>char16_t</code> 
      or <code>char32_t</code>,&nbsp; convert <code>source</code> or [<code>first</code>,<code>last</code>) 
      to a temporary, <code>tmp</code>, of type <code>string_type</code> and 
      return <code>path(tmp)</code>, 
      else</li>
      <li para_num="6">convert <code>source</code> or [<code>first</code>,<code>last</code>) 
      to a temporary, <code>tmp</code>, of type <code>u32string</code> and 
      return <code>path(tmp)</code>.</li>
    </ul>
  </blockquote>
  <p para_num="7"><i>Remarks: </i>Argument format conversion (<a href="p0218r0.html#path.fmt.cvt">27.10.8.2.1</a>) applies to the 
  arguments for these functions. How Unicode encoding conversions are performed is 
  unspecified. </p>
  <p para_num="8">[<i>Example</i>:</p>
  <blockquote>
    <p para_num="9">A string is to be read from a database that is encoded in UTF-8, and used 
    to create a directory using the native encoding for filenames:</p>
    <pre para_num="10">namespace fs = std::filesystem;
std::string utf8_string = read_utf8_data();
fs::create_directory(fs::u8path(utf8_string));</pre>
    <p para_num="11">For POSIX based operating systems with the native narrow encoding set 
    to UTF-8, no encoding or type conversion occurs.</p>
    <p para_num="12">For POSIX based operating systems with the native narrow encoding not 
    set to UTF-8, a conversion to UTF-32 occurs, followed by a conversion to the 
    current native narrow encoding. Some Unicode characters may have no native character 
    set representation.</p>
    <p para_num="13">For Windows based operating systems a conversion from UTF-8 to 
    UTF-16 occurs.</p>
  </blockquote>
  <p para_num="14"><i>&mdash;end example]</i></p>
</blockquote>
<h3>27.10.9  <a name="Class-filesystem_error">Class <code>filesystem_error</code> 
[class.filesystem_error]</a></h2>
<pre para_num="1">namespace std { <del>namespace experimental {</del> namespace filesystem { <del>inline namespace v1 {</del>

      class filesystem_error : public system_error
      {
      public:
        <a href="p0218r0.html#filesystem_error-2-arg">filesystem_error</a>(const string&amp; what_arg, error_code ec);
        <a href="p0218r0.html#filesystem_error-3-arg">filesystem_error</a>(const string&amp; what_arg,
          const path&amp; p1, error_code ec);
        <a href="p0218r0.html#filesystem_error-4-arg">filesystem_error</a>(const string&amp; what_arg,
          const path&amp; p1, const path&amp; p2, error_code ec);

        const path&amp; <a href="p0218r0.html#filesystem_error-path1">path1</a>() const noexcept;
        const path&amp; <a href="p0218r0.html#filesystem_error-path2">path2</a>() const noexcept;
        const char* <a href="p0218r0.html#filesystem_error-what">what</a>() const noexcept;
      };
} }<del> } }</del></pre>
<p para_num="2">The class <code>filesystem_error</code> defines the type of 
objects thrown as exceptions to report file system errors from functions described in this 
<del>Technical Specification</del> <ins>sub-clause</ins>.</p>
<h4>27.10.9.1  <a name="filesystem_error-members"> <code>filesystem_error</code> members</a> 
[filesystem_error.members]</h3>
<p para_num="1"> Constructors are provided that store zero, one, or two paths associated with 
an error.</p>
<pre para_num="2"><a name="filesystem_error-2-arg">filesystem_error</a>(const string&amp; what_arg, error_code ec);</pre>
<blockquote>
  <p para_num="3"><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" bgcolor="#FFFFFF"><code>
      runtime_error::what()</code></td>
      <td width="82%" bgcolor="#FFFFFF">
      <code>what_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre para_num="4"><a name="filesystem_error-3-arg">filesystem_error</a>(const string&amp; what_arg, const path&amp; p1, error_code ec);</pre>
<blockquote>
  <p para_num="5"><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>
      runtime_error::what()</code></td>
      <td width="82%">
      <code>what_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path1()</code></td>
      <td width="82%">Reference to stored copy of <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre para_num="6"><a name="filesystem_error-4-arg">filesystem_error</a>(const string&amp; what_arg, const path&amp; p1, const path&amp; p2, error_code ec);</pre>
<blockquote>
  <p para_num="7"><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>
      runtime_error::what()</code></td>
      <td width="82%">
      <u>
      <code>w</code></u><code>hat_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1()</code></td>
      <td width="82%">Reference to stored copy of <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2()</code></td>
      <td width="82%">Reference to stored copy of <code>p2</code></td>
    </tr>
  </table>
</blockquote>
<pre para_num="8">const path&amp; <a name="filesystem_error-path1">path1</a>() const noexcept;</pre>
<blockquote>
  <p para_num="9"><i>Returns:</i> Reference to copy of <code>p1</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre para_num="10">const path&amp; <a name="filesystem_error-path2">path2</a>() const noexcept;</pre>
<blockquote>
  <p para_num="11"><i>Returns:</i> Reference to copy of <code>p2</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre para_num="12">const char* <a name="filesystem_error-what">what</a>() const noexcept;</pre>
<blockquote>
  <p para_num="13"><i>Returns: </i>A string containing <code>runtime_error::what()</code>. The exact format is unspecified. 
  Implementations are encouraged but not required to include <code>path1.native_string()</code>if not empty, <code>path2.native_string()</code>if 
  not empty, and <code>system_error::what()</code> strings in the returned 
  string.</p>
</blockquote>
<h3>27.10.10  Enumerations&nbsp; [<a name="fs.enum">fs.enum</a>]</h2>
<h4>27.10.10.1  <a name="Enum-file_type">Enum class <code>file_type</code></a> [<a name="enum.file_type">enum.file_type</a>]</h3>
<p para_num="1">This enum class specifies constants used to identify file types.</p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td><b>Constant Name</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>The type of the file has not been determined or an error occurred while 
    trying to determine the type. </td>
  </tr>
  <tr>
    <td><code>not_found</code></td>
    <td align="center"><code>-1</code></td>
    <td>Pseudo-type indicating the file was not found. [<i>Note:</i> The file 
    not being found is not considered an error while determining the 
    type of a file. <i>&mdash;end note</i>]</td>
  </tr>
  <tr>
    <td><code>regular</code></td>
    <td align="center"><code>1</code></td>
    <td>Regular file</td>
  </tr>
  <tr>
    <td><code>directory</code></td>
    <td align="center"><code>2</code></td>
    <td>Directory file</td>
  </tr>
  <tr>
    <td><code>symlink</code></td>
    <td align="center"><code>3</code></td>
    <td>Symbolic link file</td>
  </tr>
  <tr>
    <td><code>block</code></td>
    <td align="center"><code>4</code></td>
    <td>Block special file</td>
  </tr>
  <tr>
    <td><code>character</code></td>
    <td align="center"><code>5</code></td>
    <td>Character special file</td>
  </tr>
  <tr>
    <td><code>fifo</code></td>
    <td align="center"><code>6</code></td>
    <td>FIFO or pipe file</td>
  </tr>
  <tr>
    <td><code>socket</code></td>
    <td align="center"><code>7</code></td>
    <td>Socket file</td>
  </tr>
  <tr>
    <td><code>unknown</code></td>
    <td align="center"><code>8</code></td>
    <td>The file does exist, but is of an operating system dependent type not 
    covered by any of the other cases or the process does not have permission to 
    query the file type</td>
  </tr>
</table>
<h4>27.10.10.2  Enum class <code>copy_options</code> [<a name="enum.copy_options">enum.copy_options</a>]</h3>
<p para_num="1">The <tt>enum class</tt> type <tt>copy_options</tt> 
is a bitmask type (Â§17.5.2.1.3) that specifies bitmask constants used to control the semantics of 
copy operations.&nbsp; The constants are specified in option groups. Constant
<code>none</code> is shown in each option group for purposes of exposition; 
implementations shall provide only a single definition.&nbsp; Calling a 
Filesystem library function with more than a single constant for an option 
group results in undefined behavior.</p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td colspan="3"align="center"><b>Option group controlling <code>copy_file</code> 
    function effects for existing target files</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Error; file already exists.</td>
  </tr>
  <tr>
    <td><code>skip_existing</code></td>
    <td align="center"><code>1</code></td>
    <td>Do not overwrite existing file, do not report an error.</td>
  </tr>
  <tr>
    <td><code>overwrite_existing</code></td>
    <td align="center"><code>2</code></td>
    <td>Overwrite the existing file.</td>
  </tr>
  <tr>
    <td><code>update_existing</code></td>
    <td align="center"><code>4</code></td>
    <td>Overwrite the existing file if it is older than the replacement file.</td>
  </tr>
  <tr>
    <td colspan="3" align="center"><b>Option group controlling <code>copy</code> function effects for 
    sub-directories</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Do not copy sub-directories.</td>
  </tr>
  <tr>
    <td><code>recursive</code></td>
    <td align="center"><code>8</code></td>
    <td>Recursively copy sub-directories and their contents.</td>
  </tr>
  <tr>
    <td colspan="3" align="center"><b>Option group controlling <code>copy</code> function effects for 
    symbolic links</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Follow symbolic links.</td>
  </tr>
  <tr>
    <td><code>copy_symlinks</code></td>
    <td align="center"><code>16</code></td>
    <td>Copy symbolic links as symbolic links rather than copying the files that 
    they point to.</td>
  </tr>
  <tr>
    <td><code>skip_symlinks</code></td>
    <td align="center"><code>32</code></td>
    <td>Ignore symbolic links.</td>
  </tr>
  <tr>
    <td colspan="3" align="center"><b>Option group controlling <code>copy</code> function effects for
    choosing the form of copying</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Copy content.</td>
  </tr>
  <tr>
    <td><code>directories_only</code></td>
    <td align="center"><code>64</code></td>
    <td>Copy directory structure only, do not copy non-directory files.</td>
  </tr>
  <tr>
    <td><code>create_symlinks</code></td>
    <td align="center"><code>128</code></td>
    <td>Make symbolic links instead of copies of files. The source path shall be 
    an absolute path unless the destination path is in the current directory.</td>
  </tr>
  <tr>
    <td><code>create_hard_links</code></td>
    <td align="center"><code>256</code></td>
    <td>Make hard links instead of copies of files.</td>
  </tr>
</table>
<h4>27.10.10.3  Enum class <code>perms</code> [<a name="enum.perms">enum.perms</a>]</h3>
<p para_num="1">The <tt>enum class</tt> type <tt>perms</tt> 
is a bitmask type (Â§17.5.2.1.3) that specifies bitmask constants used to identify file 
permissions. </p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td><b>Name</b></td>
    <td align="center"><b>Value<br>
    (octal)</b></td>
    <td align="center"><b>POSIX<br>
    macro</b></td>
    <td><b>Definition or notes</b></td>
  </tr>

<tr><td><code>none</code></td><td><code>0</code></td><td></td>
  <td>There are no permissions set for the file.</td>
</tr>
<tr><td><code>owner_read</code></td><td><code>0400</code></td><td> <code>S_IRUSR</code></td>
  <td> Read permission, owner</td>
</tr>
<tr><td><code>owner_write</code></td><td><code>0200</code></td><td> <code>S_IWUSR</code></td>
  <td> Write permission, owner</td>
</tr>
<tr><td><code>owner_exec</code></td><td><code>0100</code></td><td>  <code>S_IXUSR</code></td>
  <td> Execute/search permission, owner</td>
</tr>
<tr><td><code>owner_all</code></td><td><code>0700</code></td><td>  <code>S_IRWXU</code></td>
  <td> Read, write, execute/search by owner; <code>owner_read | owner_write | owner_exec</code></td>
</tr>
<tr><td><code>group_read</code></td><td><code>040</code></td><td>  <code>S_IRGRP</code></td>
  <td> Read permission, group</td>
</tr>
<tr><td><code>group_write</code></td><td><code>020</code></td><td> <code>S_IWGRP</code></td>
  <td> Write permission, group</td>
</tr>
<tr><td><code>group_exec</code></td><td><code>010</code></td><td>   <code>S_IXGRP</code></td>
  <td> Execute/search permission, group</td>
</tr>
<tr><td><code>group_all</code></td><td><code>070</code></td><td>   <code>S_IRWXG</code></td>
  <td> Read, write, execute/search by group; <code>group_read | group_write | group_exec</code></td>
</tr>
<tr><td><code>others_read</code></td><td><code>04</code></td><td>  <code>S_IROTH</code></td>
  <td> Read permission, others</td>
</tr>
<tr><td><code>others_write</code></td><td><code>02</code></td><td> <code>S_IWOTH</code></td>
  <td> Write permission, others</td>
</tr>
<tr><td><code>others_exec</code></td><td><code>01</code></td><td>   <code>S_IXOTH</code></td>
  <td> Execute/search permission, others</td>
</tr>
<tr><td><code>others_all</code></td><td><code>07</code></td><td>   <code>S_IRWXO</code></td>
  <td>Read, write, execute/search by others; <code>others_read | others_write | others_exec</code></td>
</tr>
<tr><td><code>all</code></td><td><code>0777</code></td><td> </td><td><code>owner_all | group_all | others_all</code></td>
</tr>
<tr><td><code>set_uid</code></td><td><code>04000</code></td><td> <code>S_ISUID</code></td>
  <td> Set-user-ID on execution</td>
</tr>
<tr><td><code>set_gid</code></td><td><code>02000</code></td><td> <code>S_ISGID</code></td>
  <td> Set-group-ID on execution</td>
</tr>
<tr><td><code><a name="sticky_bit">sticky_bit</a> </code></td><td><code>01000</code></td><td> <code>S_ISVTX</code></td>
  <td> Operating system dependent.</td>
</tr>
<tr><td><code><a name="perms_mask">mask</a></code></td><td><code>07777</code></td><td> &nbsp;</td>
  <td><code>all | set_uid | set_gid | sticky_bit</code></td>
</tr>
<tr><td><code>unknown</code></td><td><code>0xFFFF</code></td><td></td><td> 
  The permissions are not known, such as when a <code>file_status</code> object 
  is created without specifying the permissions</td>
</tr>
<tr><td><code><a name="add_perms">add_perms</a></code></td><td><code>0x10000</code></td><td>&nbsp;</td><td>
  <code>permissions()</code> shall bitwise <i>or</i> the <code>perm</code> argument&#39;s permission bits to the 
  file's current permission bits.</td>
</tr>

<tr><td><code><a name="remove_perms">remove_perms</a></code></td><td><code>
  0x20000</code></td><td>&nbsp;</td><td>
  <code>permissions()</code> shall bitwise <i>and</i> the complement of
    <code>perm</code> argument&#39;s permission bits to the 
  file's current permission bits.</td>
</tr>

<tr><td><code><a name="symlink_perms">resolve_symlinks</a></code></td><td><code>
  0x40000</code></td><td>&nbsp;</td><td>
  <code>permissions()</code> shall resolve symlinks</td>
</tr>

</table>

  <h4>27.10.10.4  Enum class <code>directory_options</code> [<a name="enum.directory_options">enum.directory_options</a>]
  </h3>
  <p para_num="1">The <tt>enum class</tt> type <code>directory_options</code> is a bitmask 
  type (Â§17.5.2.1.3) that specifies bitmask constants used to identify 
  directory traversal options. </p>
  <table style="border-collapse: collapse" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0">
    <tr>
      <td><b>Name</b> </td>
      <td align="center"><b>Value</b> </td>
      <td><b>Meaning</b> </td>
    </tr>
    <tr>
      <td><code>none</code> </td>
      <td align="center"><code>0</code> </td>
      <td>(Default) Skip directory symlinks, permission denied is an error.</td>
    </tr>
    <tr>
      <td><code>follow_directory_symlink</code> </td>
      <td align="center"><code>1</code> </td>
      <td>Follow rather than skip directory symlinks.</td>
    </tr>
    <tr>
      <td><code>skip_permission_denied</code> </td>
      <td align="center"><code>2</code> </td>
      <td>Skip directories that would otherwise result in permission denied 
      errors.</td>
    </tr>
  </table>

<h3>27.10.11  <a name="file_status">Class <code>file_status</code></a> [<a name="class.file_status">class.file_status</a>]</h2>
<pre para_num="1">namespace std { <del>namespace experimental {</del> namespace filesystem { <del>inline namespace v1 {</del>

  class file_status
  {
  public:

    // <a href="p0218r0.html#file_status-constructors">constructors</a>
    explicit file_status(<a href="p0218r0.html#enum.file_type">file_type</a> ft = file_type::none,
                         <a href="p0218r0.html#enum.perms">perms</a> prms = perms::unknown) noexcept;
    file_status(const file_status&amp;) noexcept = default;
    file_status(file_status&amp;&amp;) noexcept = default;
   ~file_status();

    file_status&amp; operator=(const file_status&amp;) noexcept = default;
    file_status&amp; operator=(file_status&amp;&amp;) noexcept = default;

    // <a href="p0218r0.html#file_status-observers">observers</a>
    <a href="p0218r0.html#enum.file_type">file_type</a>  type() const noexcept;
    <a href="p0218r0.html#enum.perms">perms</a>      permissions() const noexcept;

    // <a href="p0218r0.html#file_status-modifiers">modifiers</a>
    void       type(<a href="p0218r0.html#enum.file_type">file_type</a> ft) noexcept;
    void       permissions(<a href="p0218r0.html#enum.perms">perms</a> prms) noexcept;
  };
} }<del> } }</del></pre>
<p para_num="2">An object of type <code>file_status</code> stores information about the type 
and permissions of a file.</p>
<h4>27.10.11.1  <a name="file_status-constructors"><code>file_status</code> constructors</a> 
[file_status.cons]</h3>
<pre para_num="1">explicit file_status() noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Postconditions:</i> <code>type() == file_type::none</code>, <code>permissions() == perms::unknown</code>.</p>
</blockquote>
<pre para_num="3">explicit file_status(<a href="p0218r0.html#enum.file_type">file_type</a> ft, <a href="p0218r0.html#enum.perms">perms</a> prms = perms::unknown) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Postconditions:</i> <code>type() == ft</code>, <code>permissions() == prms</code>.</p>
</blockquote>
  <h4>27.10.11.2  <a name="file_status-observers"><code>file_status</code> observers</a> [file_status.obs]</h3>
<pre para_num="1"><a href="p0218r0.html#enum.file_type">file_type</a> type() const noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns: </i>The value of <code>type()</code> specified by the <i>postconditions</i> of the most recent call to a constructor, 
  <code>operator=</code>, or <code>type(file_type)</code> function.</p>
</blockquote>
<pre para_num="3"><a href="p0218r0.html#enum.perms">perms</a> permissions() const noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns: </i>The value of <code>permissions()</code> specified by the <i>postconditions</i> of the most recent call to a constructor, 
  <code>operator=</code>, or <code>permissions(perms)</code> function.</p>
</blockquote>
<h4>27.10.11.3  <a name="file_status-modifiers"><code>file_status</code> modifiers</a> [file_status.mods]</h3>
<pre para_num="1">void type(<a href="p0218r0.html#enum.file_type">file_type</a> ft) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Postconditions:</i> <code>type() == ft</code>.</p>
</blockquote>
<pre para_num="3">void permissions(<a href="p0218r0.html#enum.perms">perms</a> prms) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Postconditions:</i> <code>permissions() == prms</code>.</p>
</blockquote>
<h3>27.10.12  <a name="Class-directory_entry">Class <code>directory_entry</code></a> [class.directory_entry]</h2>

<pre para_num="1">namespace std { <del>namespace experimental {</del> namespace filesystem { <del>inline namespace v1 {</del>

  class directory_entry
  {
  public:

    // <a href="p0218r0.html#directory_entry-constructors">constructors</a> and destructor
    directory_entry() noexcept = default;
    directory_entry(const directory_entry&amp;) = default;
    directory_entry(directory_entry&amp;&amp;) noexcept = default;
    explicit directory_entry(const path&amp; p);
   ~directory_entry();

    // <a href="p0218r0.html#directory_entry-modifiers">modifiers</a>
    directory_entry&amp; operator=(const directory_entry&amp;) = default;
    directory_entry&amp; operator=(directory_entry&amp;&amp;) noexcept = default;
    void assign(const path&amp; p);
    void replace_filename(const path&amp; p);

    // <a href="p0218r0.html#directory_entry-observers">observers</a>
    const path&amp;  path() const noexcept;
    operator const path&amp;() const noexcept;
    file_status  status() const;
    file_status  status(error_code&amp; ec) const noexcept;
    file_status  symlink_status() const;
    file_status  symlink_status(error_code&amp; ec) const noexcept;

    bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
    bool operator==(const directory_entry&amp; rhs) const noexcept;
    bool operator!=(const directory_entry&amp; rhs) const noexcept;
    bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
    bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
    bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;
  private:
    path   m_path; // for exposition only
  };

} }<del> } }</del>  </pre>
<p para_num="2">A <code>directory_entry</code> object stores a <code>path</code> object.</p>
<h4>27.10.12.1  <a name="directory_entry-constructors"><code>directory_entry</code> 
constructors </a>[directory_entry.cons] </h3>
<pre para_num="1">explicit directory_entry(const path&amp; p);</pre>
<blockquote>
  <p para_num="2"><i>Effects: </i>Constructs an object of type <code>directory_entry</code>.
  </p>
  <p para_num="3"><i>Postcondition:</i> <code>path() == p</code>.</p>
</blockquote>
<h4>27.10.12.2  <a name="directory_entry-modifiers"><code>directory_entry</code> 
modifiers </a>[directory_entry.mods] </h3>
<pre para_num="1">void assign(const path&amp; p);</pre>
<blockquote>
  <p para_num="2"><i>Postcondition:</i> <code>path() == p</code>. </p>
</blockquote>
<pre para_num="3">void replace_filename(const path&amp; p);</pre>
<blockquote>
  <p para_num="4"><i>Postcondition:</i> <code>path() == x.parent_path() / p</code> where
  <code>x</code> is the value of <code>path()</code> before the function is 
  called. </p>
</blockquote>
</blockquote>
<h4>27.10.12.3  <a name="directory_entry-observers"><code>directory_entry</code> 
observers </a>[directory_entry.obs] </h3>
<pre para_num="1">const path&amp; path() const noexcept;
operator const path&amp;() const noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>m_path</code> </p>
</blockquote>
<pre para_num="3">file_status status() const;
file_status status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code> status(path()<i>[, ec]</i>)</code>.
  </p>
  <p para_num="5"><i>Throws:</i> As specified in
  <a href="p0218r0.html#Error-reporting">Error 
  reporting (27.10.7)</a>. </p>
</blockquote>
<pre para_num="6">file_status  symlink_status() const;
file_status  symlink_status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
   <p para_num="7"><i>Returns:</i> <code> symlink_status(path()<i>[, 
  ec]</i>)</code>. </p>
  <p para_num="8"><i>Throws:</i> As specified in
  <a href="p0218r0.html#Error-reporting">Error 
  reporting (27.10.7)</a>. </p>
</blockquote>
<pre para_num="9">bool operator==(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="10"><i>Returns:</i> <code>m_path == rhs.m_path</code>. </p>
</blockquote>
<pre para_num="11">bool operator!=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="12"><i>Returns:</i> <code>m_path != rhs.m_path</code>. </p>
</blockquote>
<pre para_num="13">bool operator&lt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="14"><i>Returns:</i> <code>m_path &lt; rhs.m_path</code>. </p>
</blockquote>
<pre para_num="15">bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="16"><i>Returns:</i> <code>m_path &lt;= rhs.m_path</code>. </p>
</blockquote>
<pre para_num="17">bool operator&gt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="18"><i>Returns:</i> <code>m_path &gt; rhs.m_path</code>. </p>
</blockquote>
<pre para_num="19">bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="20"><i>Returns:</i> <code>m_path &gt;= rhs.m_path</code>. </p>
</blockquote>
<h3>27.10.13  <a name="Class-directory_iterator">Class <code>directory_iterator</code> 
[class.directory_iterator]</a></h2>
<p para_num="1">An object of type <code>directory_iterator</code> provides an iterator for a 
sequence of <code>directory_entry</code> elements representing the files in a 
directory.&nbsp; 
[<i>Note:</i> For iteration into sub-directories,&nbsp; see class <code>recursive_directory_iterator</code> 
(<a href="p0218r0.html#class.rec.dir.itr">27.10.14</a>). <i>&mdash;end note</i>]</p>

<div dir="ltr">

<pre para_num="2">namespace std { <del>namespace experimental {</del> namespace filesystem { <del>inline namespace v1 {</del>

  class directory_iterator
  {
  public:
    typedef directory_entry        value_type;
    typedef ptrdiff_t              difference_type;
    typedef const directory_entry* pointer;
    typedef const directory_entry&amp; reference;
    typedef input_iterator_tag     iterator_category;

    // <a href="p0218r0.html#directory_iterator-members">member functions</a>
    directory_iterator() noexcept;
    explicit directory_iterator(const path&amp; p);
    directory_iterator(const path&amp; p, directory_options options);
    directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
    directory_iterator(const path&amp; p,
      directory_options options, error_code&amp; ec) noexcept;
    directory_iterator(const directory_iterator&amp; rhs);
    directory_iterator(directory_iterator&amp;&amp; rhs) noexcept;
   ~directory_iterator();

    directory_iterator&amp; operator=(const directory_iterator&amp; rhs);
    directory_iterator&amp; operator=(directory_iterator&amp;&amp; rhs) noexcept;
    
    const directory_entry&amp; operator*() const;
    const directory_entry* operator-&gt;() const;
    directory_iterator&amp;    operator++();
    directory_iterator&amp;    increment(error_code&amp; ec) noexcept;

    // other members as required by Â§24.1.1 Input iterators 
  };

} }<del> } }</del></pre>

</div>

<p para_num="3"> <code>directory_iterator</code> satisfies the requirements of an input 
iterator&nbsp; Â§24.2.3).</p>
<p para_num="4">If an iterator of type <code>directory_iterator</code> is advanced past the 
last directory element, that iterator shall become equal to the end iterator 
value. The <code>directory_iterator</code> default constructor&nbsp;shall 
create an iterator equal to the end iterator value, and this shall be the only 
valid iterator for the end condition. </p>
<p para_num="5">The result of <code>operator*</code> on an end iterator is undefined behavior. For any other iterator value 
a <code>const directory_entry&amp;</code> is returned. The result of <code>operator-&gt;</code> on an end iterator is 
undefined behavior. For any other iterator value a <code>const directory_entry*</code> is 
returned.</p>
<p para_num="6">Two end iterators are always equal. An end iterator shall not be equal to a non-end 
iterator.</p>
<p para_num="7">The result of calling the <code>path()</code> member of the <code>directory_entry</code> object obtained by dereferencing a <code>directory_iterator</code> is a reference to a <code>path</code> object composed of the directory argument from which the iterator was 
constructed with filename of the directory entry appended as if by <code>operator/=</code>. </p>
<p para_num="8">Directory iteration shall not yield directory entries for the current (<i>dot</i>) 
and parent (<i>dot-dot</i>) directories.</p>
<p para_num="9">The order of directory entries obtained by dereferencing successive 
increments of a <code>directory_iterator</code> is unspecified.</p>
<blockquote>
<p para_num="10">[<i>Note:</i> Programs performing directory iteration may wish to test if the 
path obtained by dereferencing a directory iterator actually exists. It could be 
a
symbolic link to a non-existent file. Programs recursively 
walking directory trees for purposes of removing and renaming entries may wish 
to avoid following symbolic links.</p>
<p para_num="11">If a file  is removed from or added to a directory after the 
construction of a <code>directory_iterator</code> for the directory, it is 
unspecified whether or not subsequently incrementing the iterator will ever 
result in an iterator referencing the removed or added directory entry. See 
POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/readdir_r.html">readdir_r()</a></code>. <i>&mdash;end note</i>]</p>
</blockquote>
<h4>27.10.13.1  <a name="directory_iterator-members"><code>directory_iterator</code> members</a> 
[directory_iterator.members]</h3>

<p para_num="1"><code><a name="directory_iterator-default-ctor">directory_iterator</a>() 
noexcept;</code></p>

<blockquote>

<p para_num="2"><i>Effects:</i> Constructs the end iterator.</p>

</blockquote>

<pre para_num="3">explicit <a name="directory_iterator-ctor-path">directory_iterator</a>(const path&amp; p);
directory_iterator(const path&amp; p, directory_options options);
directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
directory_iterator(const path&amp; p,
  directory_options options, error_code&amp; ec) noexcept;
</pre>
<blockquote>

<p para_num="4"><i>Effects:</i> For the directory that <code>p</code> resolves to, constructs an 
iterator for the first element in a sequence of <code>directory_entry</code> 
elements representing the files in the directory, if any; otherwise the end 
iterator. However, if <code>(options &amp; directory_options::skip_permissions_denied) != 
directory_options::none</code> and construction encounters an error indicating 
that permission to access&nbsp; <code>p</code> is denied, constructs the end iterator 
and does not report an error.</p>

<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>

<p para_num="6">[<i>Note:</i> To iterate over the current directory, use <code>directory_iterator(&quot;.&quot;)</code> rather than <code>directory_iterator(&quot;&quot;)</code>. <i>&mdash;end note</i>]</p>
</blockquote>
<pre para_num="7">directory_iterator(const directory_iterator&amp; rhs);
directory_iterator(directory_iterator&amp;&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="8"><i>Effects:</i> Constructs an object of class <code>directory_iterator</code>.
  </p>
  <p para_num="9"><i>Postconditions:</i> <code>*this</code> has the original value of <code>
  rhs</code>. </p>
</blockquote>
<pre para_num="10">directory_iterator&amp; operator=(const directory_iterator&amp; rhs);
directory_iterator&amp; operator=(directory_iterator&amp;&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="11"><i>Effects:</i> If <code>*this</code> and <code>rhs</code> are the same 
  object, the member has no effect. </p>
  <p para_num="12"><i>Postconditions:</i> <code>*this</code> has the original value of <code>
  rhs</code>. </p>
  <p para_num="13"><i>Returns:</i> <code>*this</code>. </p>
</blockquote>
<pre para_num="14">directory_iterator&amp; <a name="directory_iterator-increment">operator++</a>();
directory_iterator&amp; increment(error_code&amp; ec)<code> noexcept</code>;</pre>
<blockquote>

<p para_num="15"><i>Effects:</i> As specified by Â§24.1.1 Input iterators.</p>

<p para_num="16"><i>Returns:</i> <code>*this</code>.</p>

<p para_num="17"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>

</blockquote>
<h4>27.10.13.2  <a name="directory_iterator-non-member-functions"><code>directory_iterator</code> non-member functions</a> 
[directory_iterator.nonmembers]</h3>
<p para_num="1">These functions enable use of <code>directory_iterator</code> with 
range-based for statements.</p>
<pre para_num="2">directory_iterator begin(directory_iterator iter) noexcept;</pre>
<blockquote>
  <p para_num="3"><i>Returns: </i><code>iter</code>.</p>
</blockquote>
<pre para_num="4">directory_iterator end(const directory_iterator&amp;) noexcept;</pre>
<blockquote>
  <p para_num="5"><i>Returns: </i><code>directory_iterator()</code>.</p>
</blockquote>
<h3>27.10.14  Class <code>recursive_directory_iterator</code> 
[<a name="class.rec.dir.itr">class.rec.dir.itr</a>]</h2>
<p para_num="1">An object of type <code>recursive_directory_iterator</code> provides an iterator for 
a sequence of <code>directory_entry</code> elements representing the files in a 
directory and its sub-directories.</p>
<pre para_num="2">namespace std { <del>namespace experimental {</del> namespace filesystem { <del>inline namespace v1 {</del>

  class recursive_directory_iterator 
  {
  public:
    typedef directory_entry        value_type;
    typedef ptrdiff_t              difference_type;
    typedef const directory_entry* pointer;
    typedef const directory_entry&amp; reference;
    typedef input_iterator_tag     iterator_category;

    // constructors and destructor
    recursive_directory_iterator() noexcept;
    explicit recursive_directory_iterator(const path&amp; p);
    recursive_directory_iterator(const path&amp; p, directory_options options);
    recursive_directory_iterator(const path&amp; p,
      <a href="p0218r0.html#symlink_option">directory_options</a> options, error_code&amp; ec) noexcept;
    recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
    recursive_directory_iterator(const recursive_directory_iterator&amp; rhs);
    recursive_directory_iterator(recursive_directory_iterator&amp;&amp; rhs) noexcept;
   ~recursive_directory_iterator();

    // observers
    directory_options  options() const;
    int                depth() const;
    bool               recursion_pending() const;

    const directory_entry&amp; operator*() const;
    const directory_entry* operator-&gt;() const;

    // modifiers
    recursive_directory_iterator&amp;
      operator=(const recursive_directory_iterator&amp; rhs);
    recursive_directory_iterator&amp;
      operator=(recursive_directory_iterator&amp;&amp; rhs) noexcept;

    recursive_directory_iterator&amp; operator++();
    recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;

    void pop();
    void disable_recursion_pending();

   // other members as required by Â§24.1.1 Input iterators
  };

} }<del> } }</del></pre>


<p para_num="3">The behavior of a <code>recursive_directory_iterator</code> is the same 
as a <code>directory_iterator</code> unless otherwise specified.</p>

<p para_num="4">[<i>Note: </i>If the directory structure being iterated over contains cycles 
then the end iterator may be unreachable. <i>&mdash;end note</i>]</p>
<h4>27.10.14.1  <code><a name="recursive_directory_iterator-members">recursive_directory_iterator</a></code> members 
[<a name="rec.dir.itr.members">rec.dir.itr.members</a>]</h3>

<pre para_num="1">recursive_directory_iterator() noexcept;</pre>
<blockquote>

<p para_num="2"><i>Effects:</i> Constructs the end iterator.</p>

</blockquote>

<pre para_num="3">explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p,
  <a href="p0218r0.html#symlink_option">directory_options</a> options, error_code&amp; ec) noexcept;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>

<p para_num="4"><i>Effects:</i>&nbsp; Constructs a iterator representing the first 
entry in the directory <code>p</code> resolves to, if any; otherwise, the end iterator. 
However, if <code>(options &amp; directory_options::skip_permissions_denied) != 
directory_options::none</code> and construction encounters an error indicating 
that permission to access&nbsp; <code>p</code> is denied, constructs the end iterator 
and does not report an error.</p>

<p para_num="5"><i>Postcondition: </i><code>options() == options</code> for the signatures with a <code>
directory_options</code> argument, otherwise <code>options() == 
directory_options::none</code>.</p>

<p para_num="6"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>

<p para_num="7">[<i>Note:</i> To iterate over the current directory, use <code>recursive_directory_iterator(&quot;.&quot;)</code>
 rather than <code>recursive_directory_iterator(&quot;&quot;)</code>. <i>&mdash;end note</i>]</p>

<p para_num="8">[<i>Note:</i> By default, <code>recursive_directory_iterator</code> does not 
follow directory symlinks. To follow directory symlinks, specify <code>options</code> as <code>
directory_options::follow_directory_symlink</code> <i>&mdash;end note</i>]</p>
</blockquote>

<pre para_num="9">recursive_directory_iterator(const recursive_directory_iterator&amp; rhs);</pre>
<blockquote>
  <p para_num="10"><i>Effects:</i> Constructs an object of class <code>
  recursive_directory_iterator</code>.</p>
  <p para_num="11"><i>Postconditions:</i> <code>this-&gt;options() == rhs.options() &amp;&amp; 
  this-&gt;depth() == rhs.depth()<br> &amp;&amp; this-&gt;recursion_pending() == rhs.recursion_pending()</code>. </p>
</blockquote>
<pre para_num="12">recursive_directory_iterator(recursive_directory_iterator&amp;&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="13"><i>Effects:</i> Constructs an object of class <code>
  recursive_directory_iterator</code>. </p>
  <p para_num="14"><i>Postconditions:</i> <code>this-&gt;options()</code>, <code>this-&gt;depth()</code>, 
  and <code>this-&gt;recursion_pending()</code> return the values that <code>
  rhs.options()</code>, <code>rhs.depth()</code>, and <code>
  rhs.recursion_pending()</code>, respectively, had before the function call.
  </p>
</blockquote>
<pre para_num="15">recursive_directory_iterator&amp; operator=(const recursive_directory_iterator&amp; rhs);</pre>
<blockquote>
  <p para_num="16"><i>Effects:</i> If <code>*this</code> and <code>rhs</code> are the same 
  object, the member has no effect.</p>
  <p para_num="17"><i>Postconditions:</i> <code>this-&gt;options() == rhs.options() &amp;&amp; 
  this-&gt;depth() == rhs.depth()<br> &amp;&amp; this-&gt;recursion_pending() == 
  rhs.recursion_pending()</code>. </p>
  <p para_num="18"><i>Returns:</i> <code>*this</code>.</p>
</blockquote>
<pre para_num="19">recursive_directory_iterator&amp; operator=(recursive_directory_iterator&amp;&amp; rhs) noexcept;</pre>
<blockquote>
  <p para_num="20"><i>Effects:</i> If <code>*this</code> and <code>rhs</code> are the same 
  object, the member has no effect.</p>
  <p para_num="21"><i>Postconditions:</i> <code>this-&gt;options()</code>, <code>this-&gt;depth()</code>, 
  and <code>this-&gt;recursion_pending()</code> return the values that <code>
  rhs.options()</code>, <code>rhs.depth()</code>, and <code>
  rhs.recursion_pending()</code>, respectively, had before the function call.
  </p>
  <p para_num="22"><i>Returns:</i> <code>*this</code>. </p>
</blockquote>
<pre para_num="23">directory_options options() const;</pre>
<blockquote>
  <p para_num="24"><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
<p para_num="25"><i>Returns:</i> The value of the constructor <code>options</code> argument, 
if present, otherwise <code>directory_options::none</code>.</p>
<p para_num="26"><i>Throws:</i> Nothing.</p>
</blockquote>
<pre para_num="27">int depth() const;</pre>
<blockquote>
  <p para_num="28"><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p para_num="29"><i>Returns:</i> The current depth of the directory tree being traversed. [<i>Note:</i> 
  The initial directory is depth 0, its immediate subdirectories are depth 1, 
  and so forth. <i>&mdash;end note</i>]</p>
<p para_num="30"><i>Throws:</i> Nothing.</p>
</blockquote>
<pre para_num="31">bool recursion_pending() const;</pre>
<blockquote>
  <p para_num="32"><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p para_num="33"><i>Returns:</i> <code>true</code> if <code>disable_recursion_pending()</code> 
  has not been called subsequent to the prior construction or increment 
  operation, otherwise <code>false</code>.</p>
  <p para_num="34"><i>Throws:</i> Nothing.</p>
</blockquote>
<pre para_num="35">recursive_directory_iterator&amp; <a name="recursive_directory_iterator-increment">operator++</a>();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;</pre>
<blockquote>

  <p para_num="36"><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>

<p para_num="37"><i>Effects:</i> As specified by Â§24.2.3 Input iterators, 
except that:</p>

<ul>
  <li para_num="38">If there are no more  entries at this depth, then if <code>depth()!= 0</code> 
iteration over the parent directory resumes; otherwise <code>*this = recursive_directory_iterator()</code>.

  </li>
  <li para_num="39">Otherwise if <code>recursion_pending() &amp;&amp; is_directory(this-&gt;status())<br>
 &nbsp;
 &amp;&amp; (!is_symlink(this-&gt;symlink_status())<br>
&nbsp; || (options() &amp; directory_options::follow_directory_symlink) !=
 <br>  directory_options::none) </code>then either directory <code>
(*this)-&gt;path()</code> is recursively iterated into or, if <code>(options() 
&amp; directory_options::skip_permissions_denied)<br>
&nbsp;!= directory_options::none </code>
and an error occurs indicating that permission to access directory <code>
(*this)-&gt;path()</code> is denied, then directory <code>(*this)-&gt;path()</code> is 
treated as an empty directory and no error is reported.

  </li>
</ul>

<p para_num="40"><i>Returns:</i> <code>*this</code>.</p>

<p para_num="41"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>

</blockquote>
<pre para_num="42">void pop();</pre>
<blockquote>
  <p para_num="43"><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p para_num="44"><i>Effects:</i> If <code>depth() == 0</code>, set <code>*this</code> to <code>recursive_directory_iterator()</code>. 
  Otherwise, cease iteration of the directory currently being 
  iterated over, and continue iteration over the parent directory.</p>
</blockquote>
<pre para_num="45">void disable_recursion_pending();</pre>
<blockquote>
  <p para_num="46"><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
<p para_num="47"><i>Postcondition:</i> <code>recursion_pending() == false</code>.</p>
  <p para_num="48">[<i>Note:</i> <code>disable_recursion_pending</code><code>()</code> is used to prevent 
  unwanted recursion into a directory. <i>&mdash;end note</i>]</p>
</blockquote>
<h4>27.10.14.2  <code>recursive_directory_iterator</code> non-member functions 
[<a name="rec.dir.itr.nonmembers">rec.dir.itr.nonmembers</a>]</h3>
<p para_num="1">These functions enable use of <code>recursive_directory_iterator</code> 
with range-based for statements.</p>
<pre para_num="2">recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;</pre>
<blockquote>
  <p para_num="3"><i>Returns: </i><code>iter</code>.</p>
</blockquote>
<pre para_num="4">recursive_directory_iterator end(const recursive_directory_iterator&amp;) noexcept;</pre>
<blockquote>
  <p para_num="5"><i>Returns: </i><code>recursive_directory_iterator()</code>.</p>
</blockquote>
<h3>27.10.15  <a name="Operational-functions">Operational functions</a> [fs.op.funcs]</h2>
<p para_num="1">Operational functions query or modify files, including directories, in external 
storage.</p>
<p para_num="2">[<i>Note: </i>Because hardware failures, network failures, <a href="p0218r0.html#file-system-race">file system races</a>, and many 
other kinds of errors occur frequently in file system operations, users should be aware 
that any filesystem operational function, no matter how apparently innocuous, may encounter 
an error.&nbsp;See <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>. <i>&mdash;end note</i>]</p>
<h4>27.10.15.1  Absolute&nbsp; [<a name="fs.op.absolute">fs.op.absolute</a>]</h3>
<pre para_num="1">path <a name="absolute">absolute</a>(const path&amp; p, const path&amp; base=current_path());</pre>
  <blockquote>
  <p para_num="2"><i>Returns:</i> An <a href="p0218r0.html#Absolute-path">absolute path</a> composed according to the 
  following table</p>
  <table border="1" cellpadding="5" cellspacing="0" bordercolor="#111111" style="border-collapse: collapse">
    <tr>
      <td align="center">&nbsp;</td>
      <td align="center"><b><code>p.has_root_directory()</code></b></td>
      <td align="center"><b><code>!p.has_root_directory()</code></b></td>
    </tr>
    <tr>
      <td align="center"><b><code>p.has_root_name()</code></b></td>
      <td align="center"><code>return p</code></td>
      <td align="center"><code>return p.root_name()<br>/ absolute(base).root_directory()<br>
      / absolute(base).relative_path()<br>/ p.relative_path()</code></td>
    </tr>
    <tr>
      <td align="center"><b><code>!p.has_root_name()</code></b></td>
      <td align="center"><code>return<br>absolute(base).root_name()<br>/ p</code></td>
      <td align="center"><code>return<br>absolute(base) / p</code></td>
    </tr>
  </table>
  <p para_num="3">[<i>Note:</i> For the returned path, <code>rp,</code> <code>rp.is_absolute()</code> is true. <i>&mdash;end note</i>]</p>
  <p para_num="4"><i>Throws:</i> As specified in
  <a href="p0218r0.html#Error-reporting">Error 
  reporting (27.10.7)</a>.</p>
</blockquote>
<h4>27.10.15.2  Canonical&nbsp; [<a name="fs.op.canonical">fs.op.canonical</a>]</h3>
<pre para_num="1">path <a name="canonical">canonical</a>(const path&amp; p, const path&amp; base = current_path());
path canonical(const path&amp; p, error_code&amp; ec);
path canonical(const path&amp; p, const path&amp; base, error_code&amp; ec);</pre>
<blockquote>
<p para_num="2"><i>Overview:</i> Converts <code>p</code>, which must exist, to an absolute 
path that has no symbolic link, <code>&quot;.&quot;</code>, 
or <code>&quot;..&quot;</code> elements. </p>
<p para_num="3"><i>Returns:</i> A path that refers to 
the same file system object as <code>absolute(p,base)</code>. For the overload 
without a <code>base</code> argument, <code>base</code> is <code>current_path()</code>. 
Signatures with argument <code>ec</code> return <code>path()</code> if an error occurs.</p>
  <p para_num="4"><i>Throws:</i>&nbsp; As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  
  <p para_num="5"><i>Remarks:</i> <code>!exists(p)</code> is an error.</p>
  
  <p para_num="6">[<i>Note:</i> Canonical pathnames allow security checking of a path (e.g. 
  does this path live in /home/goodguy or /home/badguy?)&nbsp; <i>&mdash;end note</i>]</p>
  
</blockquote>
<h4>27.10.15.3  Copy&nbsp; [<a name="fs.op.copy">fs.op.copy</a>]</h3>
<pre para_num="1">void <a name="copy">copy</a>(const path&amp; from, const path&amp; to);
void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects: </i><code>copy(from, to, copy_options::none<i>[, ec]</i>)</code>.</p>
  
</blockquote>

<pre para_num="3">void <a name="copy2">copy</a>(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> options);
void copy(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> options,
  error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Precondition:</i> At most one constant from each option group (<a href="p0218r0.html#enum.copy_options">27.10.10.2</a>) 
  is present in <code>options</code>.</p>
  <p para_num="5"><i>Effects:</i></p>
  
  <blockquote>
  <p para_num="6">Before the first use of <code>f</code> and <code>t</code>:</p>
  
    <ul>
      <li para_num="7">If <code>(options &amp; copy_options::create_symlinks) != 
      copy_options::none<br>
      || (options &amp; copy_options::skip_symlinks) 
      != copy_options::none</code>, then <code>auto f = 
      symlink_status(from) </code>and if needed <code>auto t = symlink_status(to)</code>.</li>
      <li para_num="8">Otherwise, <code>auto f = status(from)</code> and if needed <code>auto 
      t = status(to)</code>.</li>
    </ul>
  <p para_num="9">Report an error as specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a> 
  if:</p>
  
    <ul>
      <li para_num="10"><code>!exists(f)</code>, or</li>
      <li para_num="11"><code>equivalent(from, to)</code>, or</li>
      <li para_num="12"><code>is_other(f) || is_other(t)</code>, or</li>
      <li para_num="13"><code>is_directory(f) &amp;&amp; is_regular_file(t)</code>.</li>
    </ul>
  <p para_num="14">If <code>is_symlink(f)</code>, then:</p>
  
    <ul>
      <li para_num="15">If <code>(options &amp; copy_options::skip_symlinks) != 
      copy_options::none</code>, then return.</li>
      <li para_num="16">Otherwise if <code>!exists(t)<br>
&nbsp; &amp;&amp; (options &amp; 
      copy_options::copy_symlinks) != copy_options::none</code>, then <code>copy_symlink(from, 
      to, options)</code>.</li>
      <li para_num="17">Otherwise report an error as specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</li>
    </ul>
  <p para_num="18">Otherwise if <code>is_regular_file(f)</code>, then:</p>
  
    <ul>
      <li para_num="19">If <code>(options &amp; copy_options::directories_only)<br>
&nbsp;!= copy_options::none</code>, then return. </li>
      <li para_num="20">Otherwise if <code>(options &amp; copy_options::create_symlinks)<br>
&nbsp;!= copy_options::none</code>, then create a symbolic link to the 
      source file. </li>
      <li para_num="21">Otherwise if <code>(options &amp; 
      copy_options::create_hard_links)<br>
&nbsp;!= copy_options::none</code>, 
      then create a hard link to the source file. </li>
      <li para_num="22">Otherwise if <code>is_directory(t)</code>, then <code>copy_file(from, to/from.filename(), 
        options)</code>.</li>
      <li para_num="23">Otherwise, <code>copy_file(from, to, options)</code>.</li>
    </ul>
  </blockquote>
</blockquote>
<blockquote>
  <blockquote>
  <p para_num="24">Otherwise if <code>is_directory(f) &amp;&amp; ((options &amp; copy_options::recursive)<br>
&nbsp; 
  != copy_options::none || options == copy_options::none)
  </code>then:</p>
  
    <ul>
      <li para_num="25">If&nbsp; <code>!exists(t)</code>, then <code>create_directory(to, 
      from)</code>.</li>
      <li para_num="26">Then, iterate over the files in <code>from</code>, as if by <code>for 
      (directory_entry&amp; x : directory_iterator(from))</code>, and for each 
      iteration <code>copy(x.path(), to/x.path().filename(), options | 
      copy_options::<i>unspecified</i>)</code>.</li>
    </ul>
  <p para_num="27">Otherwise no effects.</p>
  
  </blockquote>
  <p para_num="28"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  
  <p para_num="29"><i>Remarks: </i>For the signature with argument <code>ec</code>, any 
  Filesystem library functions called by the implementation shall have an <code>
  error_code</code> argument if applicable. </p>
  
  <p para_num="30">[<i>Example:</i> Given this directory structure:</p>
  
  <pre para_num="31">/dir1
  file1
  file2
  dir2
    file3</pre>
  <p para_num="32">Calling <code>copy(&quot;/dir1&quot;, &quot;/dir3&quot;)</code> would result in: </p>
  <pre para_num="33">/dir1
  file1
  file2
  dir2
    file3
/dir3
  file1
  file2
</pre>
  <p para_num="34">Alternatively, calling <code>copy(&quot;/dir1&quot;, &quot;/dir3&quot;, 
  copy_options::recursive)</code> would result in: </p>
  
  <pre para_num="35">/dir1
  file1
  file2
  dir2
    file3  
/dir3
  file1
  file2
  dir2
    file3</pre>

<p para_num="36"><i>&mdash;end example</i>]</p>
  
</blockquote>

<h4>27.10.15.4  Copy file&nbsp; [<a name="fs.op.copy_file">fs.op.copy_file</a>]</h3>
<pre para_num="1">bool copy_file(const path&amp; from, const path&amp; to);
bool copy_file(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns: </i><code>copy_file(from, to, copy_options::none</code><i>[</i><code>, ec</code><i>]</i><code>)</code>.</p>
  
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  
</blockquote>
<pre para_num="4">bool <a name="copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> options);
bool <a name="copy_file2">copy_file</a>(const path&amp; from, const path&amp; to, <a href="p0218r0.html#copy_option">copy_options</a> options,
               error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="5"><i>Precondition:</i> At most one constant from each <code>copy_options</code> 
  option group (<a href="p0218r0.html#enum.copy_options">27.10.10.2</a>) is present 
  in <code>options</code>.</p>
  <p para_num="6"><i>Effects:</i> </p>
  <blockquote>
    <p para_num="7">Report a file already exists error as specified in
    <a href="p0218r0.html#Error-reporting">
    Error reporting (27.10.7) </a>if: </p>
    <ul>
      <li para_num="8"><code>exists(to)</code> and <code>equivalent(from, to)</code>, or
      </li>
      <li para_num="9"><code>exists(to)</code> and <code>(options &amp; (copy_options::skip_existing<br>
&nbsp;| copy_options::overwrite_existing | copy_options::update_existing))<br>
&nbsp;&nbsp; == copy_options::none. </code></li>
    </ul>
    <p para_num="10">Otherwise copy the contents and attributes of the file <code>from</code> 
    resolves to to the file <code>to</code> resolves to if: </p>
    <ul>
      <li para_num="11"><code>!exists(to)</code>, or </li>
      <li para_num="12"><code>exists(to)</code> and <code>(options &amp; 
      copy_options::overwrite_existing) != copy_options::none</code>, or 
      </li>
      <li para_num="13"><code>exists(to)</code> and <code>(options &amp; 
      copy_options::update_existing) != copy_options::none </code>and <code>from</code> 
      is more recent than <code>to</code>, determined as if by use of the <code>
      last_write_time </code>function. </li>
    </ul>
    <p para_num="14">Otherwise no effects.</p>
  </blockquote>
  <p para_num="15"><i>Returns</i>: <code>true</code> if the <code>from</code> file 
  was copied, otherwise <code>false</code>. The signature with argument <code>ec</code> return
  <code>false</code> if an error occurs.</p>
  <p para_num="16"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="17"><i>Complexity:</i> At most one direct or indirect invocation of <code>
  status(to)</code>.</p>
</blockquote>
<h4>27.10.15.5  Copy symlink&nbsp; [<a name="fs.op.copy_symlink">fs.op.copy_symlink</a>]</h3>
<pre para_num="1">void <a name="copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink);
void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink,
                  error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects: </i><code><i>function</i>(read_symlink(existing_symlink</code><i>[</i><code>, ec</code><i>]</i><code>), new_symlink</code><i>[</i><code>, ec</code><i>]</i><code>)</code>, 
  where <i><code>function</code></i> is <code>create_symlink</code> or <code>
  create_directory_symlink</code>, as appropriate.</p>
  
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  
</blockquote>

<h4>27.10.15.6  Create directories&nbsp; [<a name="fs.op.create_directories">fs.op.create_directories</a>]</h3>

<pre para_num="1">bool <a name="create_directories">create_directories</a>(const path&amp; p);
bool <a name="create_directories2">create_directories</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Establishes the postcondition by calling <code>
  create_directory()</code> for any element of <code>p</code> that does not 
  exist.</p>
  <p para_num="3"><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p para_num="4"><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>
  false</code>. The signature with argument <code>ec</code> returns false if an 
  error occurs.</p>
  <p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="6"><i>Complexity:</i> <i>O(n+1)</i> where <i>n</i> is the number of elements 
  of <code>p</code> that do not exist.</p>
</blockquote>

<h4>27.10.15.7  Create directory&nbsp; [<a name="fs.op.create_directory">fs.op.create_directory</a>]</h3>

<pre para_num="1">bool <a name="create_directory">create_directory</a>(const path&amp; p);
bool create_directory(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Establishes the postcondition by attempting to create the 
  directory <code>p</code> resolves to, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/mkdir.html">
  mkdir()</a></code> with a second argument of 
  <code>static_cast&lt;int&gt;(perms::all)</code>. Creation 
  failure because <code>p</code> resolves to an existing directory shall not be 
  treated as an error. </p>
  <p para_num="3"><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p para_num="4"><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>false</code>. 
  The signature with argument <code>ec</code> returns false if an error occurs.</p>
  <p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<pre para_num="6">bool <a name="create_directory2">create_directory</a>(const path&amp; p, const path&amp; existing_p);
bool create_directory(const path&amp; p, const path&amp; existing_p, error_code&amp; ec) noexcept;</pre>
<blockquote>

  <p para_num="7"><i>Effects: </i>Establishes the postcondition by attempting to create the 
  directory <code>p</code> resolves to, with 
  attributes copied from directory <code>existing_p</code>. The set of attributes 
  copied is operating system dependent. Creation failure because <code>p</code> resolves to an existing directory shall not be 
  treated as an error. </p>
  
<blockquote>
[<i>Note:</i> For POSIX based operating systems the 
      attributes are those copied by native API <code>stat(existing_p.c_str(), &amp;attributes_stat)</code> 
      followed by <code>mkdir(p.c_str(), attributes_stat.st_mode)</code>.&nbsp; For 
      Windows based operating systems the attributes are those copied by native 
      API <code>CreateDirectoryExW(existing_p.c_str(), p.c_str(), 0)</code>.&nbsp; <i>
      &mdash;end note</i>]
</blockquote>
  
  <p para_num="8"><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p para_num="9"><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>false</code>. 
  The signature with argument <code>ec</code> returns false if an error occurs.</p>
  
  <p para_num="10"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>

</blockquote>

<h4>27.10.15.8  Create directory symlink&nbsp; [<a name="fs.op.create_dir_symlk">fs.op.create_dir_symlk</a>]</h3>

<pre para_num="1">void <a name="create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink);
void create_directory_symlink(const path&amp; to, const path&amp; new_symlink,
                              error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">symlink()</a></code>.</p>
  <p para_num="3"><i>
  Postcondition:</i> <code>new_symlink</code> resolves to a symbolic link file that 
  contains an unspecified representation of <code>to</code>.</p>
  <p para_num="4"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="5">[<i>Note:</i> Some operating systems require symlink creation to 
  identify that the link is to a directory. Portable code should use <code>create_directory_symlink()</code> to create directory symlinks rather than <code>create_symlink()</code> <i>&mdash;end note</i>]</p>
  <p para_num="6">[<i>Note:</i> Some operating systems do not support symbolic links at all or support 
  them only for regular files. 
  Some file systems do not 
  support 
  symbolic links regardless of the operating system - the FAT file system used on 
  memory cards and flash drives, for example. <i>&mdash;end note</i>]</p>
  </blockquote>

<h4>27.10.15.9  Create hard link&nbsp; [<a name="fs.op.create_hard_lk">fs.op.create_hard_lk</a>]</h3>

<pre para_num="1">void <a name="create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link);
void <a name="create_hard_link2">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link,
                                      error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/link.html">link()</a></code>.</p>
  <p para_num="3"><i>Postcondition:</i></p>
  <ul>
    <li para_num="4">&nbsp;<code>exists(to) &amp;&amp; 
    exists(</code><code>new_hard_link</code><code>) &amp;&amp; equivalent(to, 
     
    </code><code>new_hard_link</code><code>)</code></li>
    <li para_num="5">The contents of the file or directory
    <code>to</code> resolves to are unchanged.</li>
  </ul>
  <p para_num="6"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="7">[<i>Note:</i> Some operating systems do not support hard links at all or support 
  them only for regular files. Some file systems do not support hard 
  links regardless of the operating system - the FAT file system used on memory 
  cards and flash drives, for example. Some file systems limit the number of 
  links per file. <i>&mdash;end note</i>]</p>
  </blockquote>

<h4>27.10.15.10  Create symlink&nbsp; [<a name="fs.op.create_symlink">fs.op.create_symlink</a>]</h3>

<pre para_num="1">void <a name="create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink);
void <a name="create_symlink2">create_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                    error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">symlink()</a></code>.</p>
  <p para_num="3"><i>
  Postcondition:</i> <code>new_symlink</code> resolves to a symbolic link file that 
  contains an unspecified representation of <code>to</code>.</p>
  <p para_num="4"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="5">[<i>Note:</i> Some operating systems do not support symbolic links at all or support 
  them only for regular files. 
  Some file systems do not 
  support 
  symbolic links regardless of the operating system - the FAT system used on 
  memory cards and flash drives, for example. <i>&mdash;end note</i>]</p>
  </blockquote>

<h4>27.10.15.11  Current path&nbsp; [<a name="fs.op.current_path">fs.op.current_path</a>]</h3>

<pre para_num="1">path <a name="current_path">current_path</a>();
path <a name="current_path2">current_path</a>(error_code&amp; ec);</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> The absolute path of the current working directory, 
  obtained as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/getcwd.html">getcwd()</a></code>. 
  The signature with argument <code>ec</code> returns <code>path()</code> if an 
  error occurs.</p>
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="4"><i>Remarks: </i>The current working directory is the directory, associated 
  with the process, that is used as the starting location in pathname resolution 
  for relative paths.</p>
  <p para_num="5">[<i>Note: </i>The <code>current_path()</code> name was chosen to emphasize that the return is a 
  path, not just a single directory name.</p>
  <p para_num="6">The current path as returned by many operating systems is a dangerous 
  global variable. It may be changed unexpectedly by a third-party or system 
  library functions, or by another thread.&nbsp; <i>&mdash;end note</i>]</p>
</blockquote>

<pre para_num="7">void current_path(const path&amp; p);
void current_path(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="8"><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/chdir.html">chdir()</a></code>.</p>
<p para_num="9"><i>Postcondition:</i> <code>equivalent(p, current_path())</code>.</p>
<p para_num="10"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="11">[<i>Note: </i>The current path for many operating systems is a dangerous 
  global state. It may be changed unexpectedly by a third-party or system 
  library functions, or by another thread.&nbsp; <i>&mdash;end note</i>]</p>
</blockquote>

<h4>27.10.15.12  Exists&nbsp; [<a name="fs.op.exists">fs.op.exists</a>]</h3>

<pre para_num="1">bool <a name="exists">exists</a>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>status_known(s) &amp;&amp; s.type() != 
  file_type::not_found</code></p>
</blockquote>
<pre para_num="3">bool <a name="exists2">exists</a>(const path&amp; p);
bool <a name="exists3">exists</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>exists(status(p))</code> or <code>exists(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.13  Equivalent&nbsp; [<a name="fs.op.equivalent">fs.op.equivalent</a>]</h3>

<pre para_num="1">bool <a name="equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
bool <a name="equivalent2">equivalent</a>(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Determines <code>file_status s1</code> and <code>s2</code>, as if by <code>status(p1)</code> and&nbsp; <code>status(p2)</code>, 
  respectively.</p>
  <p para_num="3"><i>Returns:</i> <code>true</code>, if <code> s1 == 
   s2</code> and <code>p1</code> and <code>p2</code> resolve to the same file 
  system entity, else <code>false</code>. The signature with argument <code>ec</code> 
  returns <code>false</code> if an error occurs.</p>
  <blockquote>
  <p para_num="4">Two paths are considered to resolve to the same file system entity if two 
  candidate entities reside on the same device at the same location. This is 
  determined as if by the values of the POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure<code>,</code> obtained as if by <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code> for the two paths, having equal <code>st_dev</code> values 
  and equal <code>st_ino</code> values.</p>
  </blockquote>
  <p para_num="5"><i>Throws:</i> <code>filesystem_error</code> if <code>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; is_other(s2))</code>, 
  otherwise as specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.14  File size&nbsp; [<a name="fs.op.file_size">fs.op.file_size</a>]</h3>

<pre para_num="1">uintmax_t <a name="file_size">file_size</a>(const path&amp; p);
uintmax_t <a name="file_size2">file_size</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> If <code>!exists(p)  || !is_regular_file(p)</code> 
  an error is reported (27.10.7). Otherwise, the size in bytes of the file <code>
  p</code> resolves to, determined as if by the value of the POSIX <code>stat</code> 
  structure member <code>st_size</code> obtained as if by POSIX <code>stat()</code>.
   The signature 
  with argument <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> 
  if an error occurs.</p>
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.15  Hard link count&nbsp; [<a name="fs.op.hard_lk_ct">fs.op.hard_lk_ct</a>]</h3>

<pre para_num="1">uintmax_t <a name="hard_link_count">hard_link_count</a>(const path&amp; p);
uintmax_t hard_link_count(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>

  <p para_num="2"><i>Returns:</i> The number of hard links for <code>p</code>. The signature 
  with argument <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> 
  if an error occurs.</p>
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>

</blockquote>

<h4>27.10.15.16  Is block file&nbsp; [<a name="fs.op.is_block_file">fs.op.is_block_file</a>]</h3>

<pre para_num="1">bool <code><a name="is_block_file">is_block_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() == file_type::block</code></p>
</blockquote>

<pre para_num="3">bool is_block_file(const path&amp; p);
bool is_block_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_block_file(status(p))</code> or <code>
  is_block_file(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>


<h4>27.10.15.17  Is character file&nbsp; [<a name="fs.op.is_char_file">fs.op.is_char_file</a>]</h3>

<pre para_num="1">bool <code><a name="is_character_file">is_character_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() == file_type::character</code></p>
</blockquote>
<pre para_num="3">bool is_character_file</a>(const path&amp; p);
bool is_character_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_character_file(status(p))</code> 
  or <code>is_character_file(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.18  Is directory&nbsp; [<a name="fs.op.is_directory">fs.op.is_directory</a>]</h3>

<pre para_num="1">bool <a name="is_directory">is_directory</a>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() == file_type::directory</code></p>
</blockquote>
<pre para_num="3">bool <a name="is_directory2">is_directory</a>(const path&amp; p);
bool <a name="is_directory3">is_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_directory(status(p))</code> or <code>
  is_directory(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.19  Is empty&nbsp; [<a name="fs.op.is_empty">fs.op.is_empty</a>]</h3>

<pre para_num="1">bool <a name="is_empty">is_empty</a>(const path&amp; p);
bool <a name="is_empty2">is_empty</a></a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Determines <code>file_status s</code>, as if by <code>status(p, ec)</code>.</p>
  <p para_num="3"><i>Returns:</i> <code>is_directory(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? directory_iterator(p) == directory_iterator()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : file_size(p) == 0;</code></p>
  <blockquote>
  <p para_num="4">The signature with argument <code>ec</code> returns <code>false</code> if 
  an error occurs.</p>
  </blockquote>

<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.20  Is fifo&nbsp; [<a name="fs.op.is_fifo">fs.op.is_fifo</a>]</h3>

<pre para_num="1">bool <code><a name="is_fifo">is_fifo</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() == file_type::fifo</code></p>
</blockquote>

<pre para_num="3">bool is_fifo(const path&amp; p);
bool is_fifo(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_fifo(status(p))</code> or <code>is_fifo(status(p, 
  ec))</code>, respectively. The signature with argument <code>ec</code> returns <code>
  false</code> if an error occurs.</p>
<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.21  Is other&nbsp; [<a name="fs.op.is_other">fs.op.is_other</a>]</h3>

<pre para_num="1">bool <a name="is_other">is_other</a>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>return exists(s) &amp;&amp; !is_regular_file(s) &amp;&amp; !is_directory(s) &amp;&amp; !is_symlink(s)</code></p>
</blockquote>
<pre para_num="3">bool <a name="is_other2">is_other</a>(const path&amp; p);
bool <a name="is_other3">is_other</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_other(status(p))</code> or <code>is_other(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
  <p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.22  Is regular file&nbsp; [<a name="fs.op.is_regular_file">fs.op.is_regular_file</a>]</h3>

<pre para_num="1">bool <code><a name="is_regular_file">is_regular_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() == file_type::regular</code>.</p>
</blockquote>
<pre para_num="3">bool <a name="is_regular_file2">is_regular_file</a>(const path&amp; p);</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_regular_file(status(p))</code>.</p>
  <p para_num="5"><i>Throws:</i> <code>filesystem_error</code> if <code>status(p)</code> would throw <code>filesystem_error.</code></p>
  </blockquote>
<pre para_num="6">bool <a name="is_regular_file3">is_regular_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="7"><i>Effects:</i> Sets <code>ec</code> as if by <code>status(p, ec)</code>. [<i>Note:</i> <code>
  file_type::none</code>, <code>file_type::not_found</code> and <code>
  file_type::unknown</code> cases set <code>ec</code> to error values. To distinguish between cases, call the <code>status</code> function directly. <i>&mdash;end 
  note</i>] </p>
  <p para_num="8"><i>Returns:</i> <code>is_regular_file(status(p, ec))</code>. Returns <code>
  false</code> if an error occurs.</p>
</blockquote>

<h4>27.10.15.23  Is socket&nbsp; [<a name="fs.op.is_socket">fs.op.is_socket</a>]</h3>

<pre para_num="1">bool <code><a name="is_socket">is_socket</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() == file_type::socket</code></p>
</blockquote>
<pre para_num="3">bool is_socket(const path&amp; p);
bool is_socket(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_socket(status(p))</code> or <code>
  is_socket(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.24  Is symlink&nbsp; [<a name="fs.op.is_symlink">fs.op.is_symlink</a>]</h3>

<pre para_num="1">bool <a name="is_symlink">is_symlink</a>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() == file_type::symlink</code></p>
</blockquote>
<pre para_num="3">bool <a name="is_symlink2">is_symlink</a>(const path&amp; p);
bool <a name="is_symlink3">is_symlink</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="4"><i>Returns:</i> <code>is_symlink(symlink_status(p))</code> or <code>is_symlink(symlink_status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
  <p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.25  Last write time&nbsp; [<a name="fs.op.last_write_time">fs.op.last_write_time</a>]</h3>

<pre para_num="1">file_time_type <a name="last_write_time">last_write_time</a>(const path&amp; p);
file_time_type <a name="last_write_time2">last_write_time</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> The time of last data modification of <code>p</code>, 
  determined as if by the value of the POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure member <code>st_mtime</code>&nbsp; 
  obtained as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>. 
  The signature with argument <code>ec</code> returns <tt>file_time_type::min()</tt> 
  if an error occurs.</p>
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>
<pre para_num="4">void <a name="last_write_time3">last_write_time</a>(const path&amp; p, file_time_type new_time);
void <a name="last_write_time4">last_write_time</a>(const path&amp; p, file_time_type new_time,
                     error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="5"><i>Effects:</i> Sets the time of last data modification of the file 
  resolved to by <code>p</code> to <code>new_time</code>, as if by POSIX <code>futimens()</code>.</p>
  <p para_num="6"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="7">[<i>Note:</i> A postcondition of <code>last_write_time(p) == new_time</code> is not specified since it might not hold for file systems 
  with coarse time granularity. <i>&mdash;end note</i>]</p>
</blockquote>

<h4>27.10.15.26  Permissions&nbsp; [<a name="fs.op.permissions">fs.op.permissions</a>]</h3>

<pre para_num="1">void <a name="permissions">permissions</a>(const path&amp; p, <a href="p0218r0.html#symlink_perms">perms</a> prms);
void permissions(const path&amp; p, <a href="p0218r0.html#symlink_perms">perms</a> prms, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2">
  <i>Requires:</i> <code>!((prms &amp; perms::add_perms) != 
  perms::none<br>
  &nbsp;&amp;&amp; (prms &amp; perms::remove_perms) != 
  perms::none)</code>.</p>
  <p para_num="3"><i>Effects:</i> Applies the effective permissions bits from <code>prms</code> to the file <code>p</code> 
  resolves to, as if by POSIX <code><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html">fchmodat()</a></code>. The effective permission bits are determined as 
  specified by the following table. </p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td><b>bits present in <code>prms</code></b></td>
      <td><b>Effective bits applied</b></td>
    </tr>
    <tr>
      <td>Neither <code>add_perms</code> nor <code>remove_perms</code></td>
      <td><code>prms &amp; perms::mask</code></td>
    </tr>
    <tr>
      <td><code>add_perms</code></td>
      <td>
      <p para_num="4"><code>status(p).permissions() | (prms &amp; <a href="p0218r0.html#perms_mask">perms::mask</a>)</code> </td>
    </tr>
    <tr>
      <td><code>remove_perms</code></td>
      <td><code>status(p)</code><code>.permissions() &amp; ~(prms &amp; <a href="p0218r0.html#perms_mask">perms::mask</a>) </code></td>
    </tr>
  </table>
  <p para_num="5">[<i>Note:</i> Conceptually permissions are viewed as bits, but the actual 
  implementation may use some other mechanism. <i>â€”end note</i>]</p>
  <p para_num="6"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.27  Read symlink&nbsp; [<a name="fs.op.read_symlink">fs.op.read_symlink</a>]</h3>

<pre para_num="1">path <a name="read_symlink">read_symlink</a>(const path&amp; p);
path read_symlink(const path&amp; p, error_code&amp; ec);</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i>&nbsp; If <code>p</code> resolves to a symbolic 
  link, a <code>path</code> object containing the contents of that symbolic 
  link. The signature with argument <code>ec</code> 
  returns <code>path()</code> if an error occurs.</p>
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>. [<i>Note:</i> It is an error if <code>p</code> does not 
  resolve to a symbolic link. <i>&mdash;end note</i>]</p>
</blockquote>

<h4>27.10.15.28  Remove&nbsp; [<a name="fs.op.remove">fs.op.remove</a>]</h3>

<pre para_num="1">bool <a name="remove">remove</a>(const path&amp; p);
bool <a name="remove2">remove</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i>&nbsp; If <code>exists(symlink_status(p,ec))</code>, it is 
  removed as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p para_num="3">[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>&mdash;end note</i>]</p>
  </blockquote>
  <p para_num="4"><i>Postcondition:</i> <code>!exists(symlink_status(p))</code>.</p>
  <p para_num="5"><i>Returns:</i>&nbsp; <code>false</code> if p did not exist in the first 
  place, otherwise <code>true</code>. The signature with argument <code>ec</code> 
  returns <code>false</code> if an error occurs.</p>
  <p para_num="6"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.29  Remove all&nbsp; [<a name="fs.op.remove_all">fs.op.remove_all</a>]</h3>

<pre para_num="1">uintmax_t <a name="remove_all">remove_all</a>(const path&amp; p);
uintmax_t <a name="remove_all2">remove_all</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i>&nbsp; Recursively deletes the contents of p if it exists, 
  then deletes file <code>p</code> itself, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p para_num="3">[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>&mdash;end note</i>]</p>
  </blockquote>
  <p para_num="4"><i>Postcondition:</i> <code>!exists(p)</code></p>
  <p para_num="5"><i>Returns:</i> The number of files removed. The signature with argument
  <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> if an error 
  occurs.</p>
  <p para_num="6"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.30  Rename&nbsp; [<a name="fs.op.rename">fs.op.rename</a>]</h3>

<pre para_num="1">void <a name="rename">rename</a>(const path&amp; old_p, const path&amp; new_p);
void <a name="rename2">rename</a>(const path&amp; old_p, const path&amp; new_p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Renames <code>old_p</code> to <code>new_p</code>, as if by 
  POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/rename.html">rename()</a></code>.</p>
  <blockquote>
  <p para_num="3">[<i>Note:</i> If <code>old_p</code> and <code>new_p</code> resolve to the 
  same existing file, no action is taken. Otherwise, if <code>new_p</code> resolves to an 
  existing non-directory file, it is removed, while if <code>new_p</code> 
  resolves to an existing directory, it is removed if empty on POSIX compliant operating 
  systems but is an error on some other operating systems. A symbolic link is itself renamed, rather than 
  the file it resolves to being renamed. <i>&mdash;end note</i>]</p>
  </blockquote>
  <p para_num="4"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.31  Resize file&nbsp; [<a name="fs.op.resize_file">fs.op.resize_file</a>]</h3>

<pre para_num="1">void <a name="resize_file">resize_file</a>(const path&amp; p, uintmax_t new_size);
void <a name="resize_file2">resize_file</a>(const path&amp; p, uintmax_t new_size, error_code&amp; ec) noexcept;</pre>
<blockquote>
<p para_num="2"><i>Postcondition:</i> <code>file_size() == new_size</code>.</p>
<p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  <p para_num="4"><i>Remarks:</i> Achieves its postconditions as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/truncate.html">truncate()</a></code>.</p>
</blockquote>

<h4>27.10.15.32  Space&nbsp; [<a name="fs.op.space">fs.op.space</a>]</h3>

<pre para_num="1">space_info <a name="space">space</a>(const path&amp; p);
space_info <a name="space2">space</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> An object of type <code><a href="p0218r0.html#space_info">space_info</a></code>. The value of the <code>space_info</code> 
  object is determined as if by using POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/statvfs.html"
   style="text-decoration: none">statvfs()</a></code> to obtain a POSIX struct
  <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/statvfs.h.html" style="text-decoration: none">statvfs</a></code>,
   and then multiplying its <code>f_blocks</code>, <code>f_bfree</code>,
   and <code>f_bavail</code> members by its <code>f_frsize</code> member,
   and assigning the results to the <code>capacity</code>, <code>free</code>, 
  and <code>available</code> members respectively. Any members for which the 
  value cannot be determined shall be set to <code>static_cast&lt;uintmax_t&gt;(-1)</code>. 
  For the signature with argument <code>ec</code>, all members are set to <code>
  static_cast&lt;uintmax_t&gt;(-1)</code> if an error occurs.</p>
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
      <p para_num="4"><i>Remarks:</i> The value of member <code>space_info::available</code> 
      is operating system dependent. [<i>Note:</i> <code>available</code> may be 
      less than <code>free</code>. <i>â€” end note</i>] </p>
</blockquote>

<h4>27.10.15.33  Status&nbsp; [<a name="fs.op.status">fs.op.status</a>]</h3>

<pre para_num="1"><a href="p0218r0.html#file_status">file_status</a> <a name="status">status</a>(const path&amp; p);</pre>
<blockquote>
  <p para_num="2"><i>Effects: </i>As if:</p>
  <blockquote>
    <pre para_num="3">error_code ec;
file_status result = status(p, ec);
if (result == file_type::none)
  throw filesystem_error(<i>implementation-supplied-message</i>, p, ec);
return result;</pre>
  </blockquote>
  <p para_num="4"><i>Returns:</i> See above.</p>
  <p para_num="5"><i>Throws:</i> <code>filesystem_error</code>. 
[<i>Note:</i> <code>result</code> values of <code>
  file_status(file_type::not_found)</code> 
  and <code>file_status(file_type::unknown)</code> are not considered failures and do not 
  cause an exception to be 
thrown.<i> &mdash;end note</i>] </p>
  </blockquote>
<pre para_num="6"><a href="p0218r0.html#file_status">file_status</a> <a name="status2">status</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="7"><i>Effects: </i></p>
  <blockquote>
    <p para_num="8">If possible, determines the attributes 
    of the file <code>p</code> resolves to, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>.</p>
      If, during attribute determination, the underlying file system API reports 
    an error, sets <code>ec</code> to indicate the specific error reported. 
    Otherwise, <code>ec.clear()</code>.<blockquote>
      <p para_num="9">[<i>Note:</i> This allows users to inspect the specifics of underlying 
      API errors even when the value returned by <code>status()</code> is not <code>
      file_status(file_type::none)</code>.&nbsp; <i>&mdash;end note</i>]</p>
    </blockquote>
    </blockquote>
  <p para_num="10"><i>Returns:</i></p>
  <blockquote>
    <p para_num="11">If <code>ec != error_code()</code>:</p>
    <ul>
      <li para_num="12">If the specific error indicates that <code>p</code> cannot be resolved 
      because some element of the path does not exist, return <code>
      file_status(file_type::not_found)</code>.</li>
      <li para_num="13">Otherwise, if the specific error indicates that <code>p</code> can be resolved 
      but the attributes cannot be determined, return <code>
      file_status(file_type::unknown)</code>.</li>
      <li para_num="14">Otherwise, return <code>
      file_status(file_type::none)</code>.</li>
    </ul>
        <blockquote>
        <p para_num="15">[<i>Note:</i> These semantics distinguish between <code>p</code> being known not to exist, <code>p</code> existing but not being able to determine its attributes, 
        and there being an error that prevents even knowing if <code>p</code> exists. These 
        distinctions are important to some use cases.&nbsp;<i>&mdash;end note</i>]</p>
    </blockquote>
    <p para_num="16">Otherwise,</p>
    <ul>
      <li para_num="17">If the attributes indicate a regular file, as if by POSIX&nbsp;<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISREG()</a>, 
      return <code>
      file_status(file_type::regular)</code>. [<i>Note:</i> <code>
      file_type::regular</code> implies appropriate <code>&lt;fstream&gt;</code> operations 
      would succeed, assuming no hardware, permission, access, or file system 
      race 
      errors. Lack of
<code>file_type::regular</code> does not necessarily imply <code>&lt;fstream&gt;</code> operations would 
fail on a directory.
<i>&mdash;end note</i>]</li>
      <li para_num="18">Otherwise, if the attributes indicate a directory, as if by POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISDIR()</a>, 
      return <code>
      file_status(file_type::directory)</code>. [<i>Note:</i> <code>
      file_type::directory</code> implies <code>
directory_iterator(p)</code>would succeed.
<i>&mdash;end note</i>]</li>
      <li para_num="19">Otherwise, if the attributes indicate a block special file, as if by 
      POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISBLK()</a>, 
      return <code>
      file_status(file_type::block)</code>.</li>
      <li para_num="20">Otherwise, if the attributes indicate a character special file, as if 
      by POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISCHR()</a>, 
      return <code>
      file_status(file_type::character)</code>.</li>
      <li para_num="21">Otherwise, if the attributes indicate a fifo or pipe file, as if by 
      POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISFIFO()</a>, 
      return <code>
      file_status(file_type::fifo)</code>.</li>
      <li para_num="22">Otherwise, if the attributes indicate a socket, as if by POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISSOCK()</a>, 
      return <code>
      file_status(file_type::socket)</code>.</li>
      <li para_num="23">Otherwise, return <code>
      file_status(file_type::unknown)</code>.</li>
    </ul>
    </blockquote>
      <p para_num="24"><i>Remarks:</i> If a symbolic link is encountered during pathname 
      resolution, 
      pathname resolution continues using the contents of the symbolic link.</p>
</blockquote>

<h4>27.10.15.34  Status known&nbsp; [<a name="fs.op.status_known">fs.op.status_known</a>]</h3>

<pre para_num="1">bool <a name="status_known">status_known</a>(file_status s) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> <code>s.type() != file_type::none</code></p>
</blockquote>

<h4>27.10.15.35  Symlink status&nbsp; [<a name="fs.op.symlink_status">fs.op.symlink_status</a>]</h3>

<pre para_num="1">file_status <a name="symlink_status">symlink_status</a>(const path&amp; p);
file_status <a name="symlink_status2">symlink_status</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i>&nbsp; Same as <a href="p0218r0.html#status">status()</a>, above, 
  except that the attributes 
    of <code>p</code> are determined as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/lstat.html">lstat()</a></code>.</p>
</blockquote>
<blockquote>
      <p para_num="3"><i>Returns:</i> Same as <a href="p0218r0.html#status">status()</a>, above, except 
      that if the attributes indicate a symbolic link, as if by POSIX <a class="external" href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISLNK()</a>, return <code>
      file_status(file_type::symlink)</code>. 
      The signature with argument <code>ec</code> returns <code>
      file_status(file_type::none)</code> if an error occurs.</p>
      <p para_num="4"><i>Remarks:</i> Pathname resolution terminates if <code>p</code> names a symbolic link.</p>
  <p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
</blockquote>

<h4>27.10.15.36  System complete&nbsp; [<a name="fs.op.system_complete">fs.op.system_complete</a>]</h3>

<pre para_num="1">path <a name="system_complete">system_complete</a>(const path&amp; p);
path <a name="system_complete2">system_complete</a>(const path&amp; p, error_code&amp; ec);</pre>
<blockquote>
  <p para_num="2"><i>Effects:</i> Composes an absolute path from <code>p</code>, using the 
  same rules used by the operating system to resolve a path passed as the 
  filename argument to standard library open functions.</p>
  <p para_num="3"><i>Returns:</i> The composed path. The signature with argument <code>ec</code> 
  returns <code>path()</code> if an error occurs.</p>
  <p para_num="4"><i>Postcondition:</i> For the returned path, <code>rp,</code> <code>rp.is_absolute()</code> is true.</p>
  <p para_num="5"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>
  
<p para_num="6">[<i>Example:</i> For POSIX based operating systems, <code>system_complete(p)</code>
  has the same semantics as <code>absolute(p, current_path())</code>.</p>
  <p para_num="7">For Windows based operating systems, <code>system_complete(p)</code> has the 
  same semantics as <code>absolute(p, current_path())</code> if <code>p.is_absolute() ||
  !p.has_root_name()</code> or <code>p</code> and <code>base</code> have the same
  <code>root_name()</code>. 
  Otherwise it acts like <code>absolute(p, cwd)</code> is
  the current directory for the <code>p.root_name()</code> drive. This will 
  be the current directory for that drive the last time it was set, and thus may 
  be residue left over from a prior program run by the command 
  processor. Although these semantics are useful, they may be surprising.
   <i>&mdash;end example</i>]</p>
  
</blockquote>

<h4>27.10.15.37  Temporary directory path&nbsp; [<a name="fs.op.temp_dir_path">fs.op.temp_dir_path</a>]</h3>

<pre para_num="1">path <a name="temp_directory_path">temp_directory_path</a>();
path temp_directory_path(error_code&amp; ec);</pre>
<blockquote>
  <p para_num="2"><i>Returns:</i> An unspecifed directory path suitable for temporary files. An error shall be reported if<code> !exists(p) 
  || !is_directory(p)</code>, where <code>p</code> is the path to be returned. 
  The signature with argument <code>ec</code> returns <code>path()</code> if an 
  error occurs.</p>
  <p para_num="3"><i>Throws:</i> As specified in <a href="p0218r0.html#Error-reporting">Error reporting (27.10.7)</a>.</p>

  <p para_num="4">[<i>Example:</i> For POSIX based operating systems, an implementation might 
  return the path 
  supplied by the first environment variable found in the list TMPDIR, TMP, TEMP, TEMPDIR, 
  or if none of these are found, <code>&quot;/tmp&quot;</code>.</p>
  <p para_num="5">For Windows based operating systems, an implementation might return the path
  reported by the <i>Windows</i> <code>GetTempPath</code> API function.<i> &mdash;end example</i>] </p> 
  
</blockquote>

<hr><!-- end include --></p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to Eric Fiselier, Stephan T. Lavavej, P.J. Plauger, and Jonathan Wakely for their work on implementations, and for reporting issues based on their experience.</p>
<p>Thanks to Jamie Allsop and Nicolai Josuttis for teasing out the details of the relative path problem, and proposing a solution.</p>
<h2 id="references">References</h2>
<p>[<a name="1">1</a>] Beman Dawes, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf">N4100, Programming Languages â€” C++ â€” File System Technical Specification</a>, 2014.<br><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf</a></p>
<p>[<a name="2">2</a>] Beman Dawes, others, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm">Boost Filesystem Library, V3</a>, 2015.<br><a href="https://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm" class="uri">https://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm</a></p>
<p>[<a name="3">3</a>] Microsoft, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/msdn.microsoft.com/en-us/library/hh874694.aspx">&lt;filesystem&gt; (v3), Visual Studio 2015</a>, 2015.<br><a href="https://msdn.microsoft.com/en-us/library/hh874694.aspx" class="uri">https://msdn.microsoft.com/en-us/library/hh874694.aspx</a></p>
<p>[<a name="4">4</a>] Eric Fiselier, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/github.com/efcs/filesystem-standalone">Experimental work on the standard filesystem proposal</a>, 2014.<br><a href="https://github.com/efcs/filesystem-standalone" class="uri">https://github.com/efcs/filesystem-standalone</a></p>
<p>[<a name="5">5</a>] Jamie Allsop, Nicolai Josuttis, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0011r0.html">P0011R0, Additions to Filesystem supporting Relative Paths</a>, 2015.<br><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0011r0.html" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0011r0.html</a></p>
<p>[<a name="6">6</a>] Beman Dawes, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r0.html">P0218R0, Relative Paths for Filesystem</a>, 2016.<br><a href="p0218r0.html" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r0.html</a></p>
<p>[<a name="7">7</a>] GNU, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/gcc.gnu.org/gcc-5/">GCC 5 Release Series</a>, 2016.<br><a href="https://gcc.gnu.org/gcc-5/" class="uri">https://gcc.gnu.org/gcc-5/</a></p>
<hr />
</body>
</html>
