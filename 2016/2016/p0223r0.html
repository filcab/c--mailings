<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Class Namespace</title>
<meta name="date" content="2016-02-09" />
<meta name="author" content="Matthew Woehlke (mwoehlke.floss&#64;gmail.com)" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="class-namespace">
<h1 class="title">Class Namespace</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">Document:</th><td class="field-body">P0223R0</td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>2016-02-09</td></tr>
<tr class="field"><th class="docinfo-name">Project:</th><td class="field-body">ISO/IEC JTC1 SC22 WG21 Programming Language C++</td>
</tr>
<tr class="field"><th class="docinfo-name">Audience:</th><td class="field-body">Evolution Working Group</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Matthew Woehlke (<a class="reference external" href="mailto:mwoehlke.floss&#64;gmail.com">mwoehlke.floss&#64;gmail.com</a>)</td></tr>
</tbody>
</table>
<style>
  html { color: black; background: white; }
  table.docinfo { margin: 2em 0; }
</style><div class="section" id="abstract">
<h1><a class="toc-backref" href="p0223r0.html#id1">Abstract</a></h1>
<p>This proposal provides a new language feature, &quot;class namespace&quot;, as a shortcut for providing a series of definitions belonging to a class scope, similar to the manner in which a traditional namespace can provide a series of definitions belonging to a namespace scope.</p>
<p>This proposal is effectively a continuation / resurrection of <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1420.pdf">N1420</a> which was tagged for further consideration without being either accepted or rejected. However, much of the text of this proposal was written prior to the author's discovery of the same.</p>
<p>In contrast to N1420, we avoid use of the term &quot;reopen&quot;, which implies the ability to add to a class. Class definitions are currently closed; members may only be added to a class during the initial definition thereof (template specialization notwithstanding). Although many have asked for the ability to add members to classes after the definition, such proposals are generally not well received. Although it is not the intent of this proposal to categorically forbid any such future direction, we also recognize these concerns and specifically do not wish to suggest any movement in that direction.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="p0223r0.html#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="p0223r0.html#rationale" id="id2">Rationale</a></li>
<li><a class="reference internal" href="p0223r0.html#proposal" id="id3">Proposal</a></li>
<li><a class="reference internal" href="p0223r0.html#specification" id="id4">Specification</a></li>
<li><a class="reference internal" href="p0223r0.html#interactions" id="id5">Interactions</a></li>
<li><a class="reference internal" href="p0223r0.html#additional-examples" id="id6">Additional Examples</a></li>
<li><a class="reference internal" href="p0223r0.html#discussion" id="id7">Discussion</a><ul>
<li><a class="reference internal" href="p0223r0.html#syntax" id="id8">Syntax</a></li>
<li><a class="reference internal" href="p0223r0.html#inline" id="id9">Inline</a></li>
</ul>
</li>
<li><a class="reference internal" href="p0223r0.html#acknowledgments" id="id10">Acknowledgments</a></li>
<li><a class="reference internal" href="p0223r0.html#references" id="id11">References</a></li>
</ul>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="p0223r0.html#id2">Rationale</a></h1>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">Don't Repeat Yourself</a> (DRY) is a well known principle of software design. However, there are certain instances when providing definitions of class members that can fall prey to repetition, to the detriment of readability and maintainability.</p>
<p>We will present, as a particularly egregious example, a complicated template class:</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">CharType</span><span class="punctuation">,</span> <span class="keyword">typename</span> <span class="name">Traits</span><span class="punctuation">,</span> <span class="keyword">typename</span> <span class="name">Allocator</span><span class="operator">&gt;</span>
<span class="keyword">class</span> <span class="name class">MyString</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">};</span>
</pre>
<p>There are strong reasons why method definitions should not be inline. For starters, they inhibit readability; it is difficult to quickly parse the interface — especially the public interface — as declarations and definitions are necessarily interleaved. Additionally, they are <em>inline</em>, which results in all manner of compile time and cross-version compatibility issues. Even for template classes, it is sometimes preferred to keep definitions in a separate TU (e.g. extern templates with only specific, exported explicit instantiations).</p>
<p>The problem that arises is the necessity to repeat a long prefix for all definitions provided outside of the class definition. For example:</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">CharType</span><span class="punctuation">,</span> <span class="keyword">typename</span> <span class="name">Traits</span><span class="punctuation">,</span> <span class="keyword">typename</span> <span class="name">Allocator</span><span class="operator">&gt;</span>
<span class="name">MyString</span><span class="operator">&lt;</span><span class="name">CharType</span><span class="punctuation">,</span> <span class="name">Traits</span><span class="punctuation">,</span> <span class="name">Allocator</span><span class="operator">&gt;::</span><span class="name">MyString</span><span class="punctuation">(...)</span>
<span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
</pre>
<p>This repetition increases the space over which accidental errors may be introduced, and increases the work required for refactoring. The problem is compounded for templates within templates.</p>
<p>This is a real, extant problem. Presumably as a result of this overhead, some authors will use only inline definitions of methods, which can make it difficult to separate implementation details — which are often unnecessary noise for a user trying to understand a class — from a class's interface. Other authors may resort to separating return types, template parameters, class names, and method names, placing each on separate lines, resulting in method headers that are four lines long even before the argument list is considered. In the latter case, the need to repeat the class prefix is frustrating and, in the author's opinion, unnecessary.</p>
<p>(See <a class="reference external" href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/e0_ceXFQX-A">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/e0_ceXFQX-A</a> for additional discussion.)</p>
<p>It is also worth noting that this situation is inconsistent with namespaces. Given a function declared in a namespace:</p>
<pre class="code c++ literal-block">
<span class="keyword">namespace</span> <span class="name">Foo</span>
<span class="punctuation">{</span>
  <span class="keyword type">void</span> <span class="name">foo</span><span class="punctuation">();</span>
<span class="punctuation">}</span>
</pre>
<p>...there are currently two ways to provide the definition:</p>
<pre class="code c++ literal-block">
<span class="comment single">// Method 1: fully qualified
</span><span class="keyword type">void</span> <span class="name">Foo</span><span class="operator">::</span><span class="name">foo</span><span class="punctuation">()</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>

<span class="comment single">// Method 2: namespace scope
</span><span class="keyword">namespace</span> <span class="name">Foo</span>
<span class="punctuation">{</span>
  <span class="keyword type">void</span> <span class="name">foo</span><span class="punctuation">()</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
<span class="punctuation">}</span>
</pre>
<p>There is currently no equivalent to the second form for class members. This proposal would remove this inconsistency.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="p0223r0.html#id3">Proposal</a></h1>
<p>This proposal is to eliminate the redundancy by introducing a new &quot;class scope&quot; syntax, as follows:</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="punctuation">...</span><span class="operator">&gt;</span> <span class="comment single">// optional; only used for template classes
</span><span class="keyword">namespace</span> <span class="keyword">class</span> <span class="name class">Name</span>
<span class="punctuation">{</span>
  <span class="comment single">// definitions of class members
</span><span class="punctuation">}</span>
</pre>
<p>The effect of this scope is to treat each member definition (variable or method) as if it were prefixed by the class template specification and name. Specifically, these two codes would be exactly equivalent:</p>
<pre class="code c++ literal-block">
<span class="comment single">// Declarations
</span><span class="keyword">class</span> <span class="name class">Part</span> <span class="punctuation">{</span> <span class="keyword">enum</span> <span class="name">Type</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">};</span> <span class="punctuation">...</span> <span class="punctuation">};</span>

<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="keyword">class</span> <span class="name class">List</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">};</span>

<span class="comment single">// Existing syntax
</span><span class="name">Part</span><span class="operator">::</span><span class="name">Part</span><span class="punctuation">(...)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
<span class="name">Part</span><span class="operator">::</span><span class="name">Type</span> <span class="name">Part</span><span class="operator">::</span><span class="name">type</span><span class="punctuation">(...)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
<span class="keyword type">int</span> <span class="name">Part</span><span class="operator">::</span><span class="name">radius</span> <span class="operator">=</span> <span class="punctuation">...;</span>

<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="name">List</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;::</span><span class="name">List</span><span class="punctuation">(...)</span> <span class="punctuation">{</span> <span class="keyword">struct</span> <span class="name">iterator</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">};</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="name">List</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;&amp;</span> <span class="name">List</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;::</span><span class="keyword">operator</span><span class="operator">=</span><span class="punctuation">(</span><span class="name">List</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;</span> <span class="keyword">const</span><span class="operator">&amp;</span> <span class="name">other</span><span class="punctuation">)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="keyword">typename</span> <span class="name">List</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;::</span><span class="name">iterator</span> <span class="name">List</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;::</span><span class="name">find</span><span class="punctuation">(...)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>

<span class="comment single">// Proposed syntax
</span><span class="keyword">namespace</span> <span class="keyword">class</span> <span class="name class">Part</span> <span class="punctuation">{</span>
  <span class="name">Part</span><span class="punctuation">(...)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
  <span class="name">Type</span> <span class="name">type</span><span class="punctuation">()</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
  <span class="keyword type">int</span> <span class="name">radius</span> <span class="operator">=</span> <span class="punctuation">...;</span>
<span class="punctuation">}</span>

<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span>
<span class="keyword">namespace</span> <span class="keyword">class</span> <span class="name class">List</span> <span class="punctuation">{</span>
  <span class="name">List</span><span class="punctuation">(...)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
  <span class="name">List</span><span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span><span class="punctuation">(</span><span class="name">List</span> <span class="keyword">const</span><span class="operator">&amp;</span> <span class="name">other</span><span class="punctuation">)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
  <span class="name">iterator</span> <span class="name">find</span><span class="punctuation">(...)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
<span class="punctuation">}</span>
</pre>
<p>Following the introduction of the scope (i.e. the keywords <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">class</span></code>), the template parameters shall be implicitly applied to the class name and any subsequent mention of the class name that does not have an explicit argument list. It shall be an error to provide an argument list for the introducing class name except in the case of specialization. Type name look-up within the scope shall additionally consider the class scope first (note in the above example the use of <code class="cpp c++"><span class="name">Type</span></code> without the <code class="cpp c++"><span class="name">Part</span><span class="operator">::</span></code> qualifier). (These rules should be applied in the same manner as for a class definition. Note that this only affects non-trailing return types, as other types already use the class scope for type resolution.)</p>
<p>Some consequences of the scope acting simply as a name transformation should be noted. First, such a scope can be &quot;opened&quot; on the same class name any number of times. Second, definitions in a class name scope may be mixed with traditional, fully qualified definitions (provided that no definitions are duplicated, as always). Third, an empty scope is permissible as long as the named class is recognized. Last, but perhaps most important, the scope does not permit the addition of members not present in the class definition, nor in general does it allow the user to accomplish anything that could not be accomplished otherwise.</p>
<p>Additionally:</p>
<ul class="simple">
<li>While <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">class</span></code> is being used for illustrative purposes, <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">struct</span></code> and <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">union</span></code> shall also be permitted, and shall provide equivalent function. (In general, the use of &quot;class&quot; throughout should be understood to mean any class-type.)</li>
<li>Use of a class name scope requires that the named class has been defined. Forward declaration is not sufficient.</li>
<li>Nested class name scopes are permitted.</li>
<li>Any members that may legally be defined using their qualified name may be defined within a class name scope. This includes member types, member functions, and static member variables.</li>
<li>As with traditional namespaces, a <code class="cpp c++"><span class="punctuation">;</span></code> is not required following the closing <code class="cpp c++"><span class="punctuation">}</span></code>.</li>
<li>Access modifiers are not allowed in a class name scope. The <code class="cpp c++"><span class="keyword">virtual</span></code> and <code class="cpp c++"><span class="keyword">static</span></code> modifiers are not allowed in a class name scope. (None of these are allowed outside of a class definition, and the class name scope is not a class definition.)</li>
<li>A class name scope may not add class members to a class definition.</li>
<li>This proposal does not affect <code class="cpp c++"><span class="keyword">using</span></code> directives. (A <code class="cpp c++"><span class="keyword">using</span></code> directive on a class name scope remains illegal.)</li>
</ul>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="p0223r0.html#id4">Specification</a></h1>
<p>The most straight forward way in which to describe this feature is with a syntax transformation. Specifically, the syntax:</p>
<pre class="literal-block">
<em>[&lt;template_specification&gt;]</em> <strong>namespace class</strong> <em>&lt;name&gt;</em> <strong>{</strong>
  <em>[&lt;type&gt;]</em> <em>&lt;member_name&gt;&lt;...&gt;</em>
<strong>}</strong>
</pre>
<p>...shall be equivalent to:</p>
<pre class="literal-block">
<em>[&lt;template_specification&gt;]</em> <em>[&lt;type&gt;]</em> <em>&lt;name&gt;</em><strong>::</strong><em>&lt;member_name&gt;&lt;...&gt;</em>
</pre>
<p>...for each <em>&lt;member_name&gt;</em> in the scope. Rules for interpretation of members within a class name scope, and for what sorts of code is permitted or ill-formed, may all be derived directly from this transformation. Type resolution for the return type (where applicable) shall proceed according to the same rules that would apply within the class definition.</p>
</div>
<div class="section" id="interactions">
<h1><a class="toc-backref" href="p0223r0.html#id5">Interactions</a></h1>
<p>The token sequences <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">class</span></code>, <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">struct</span></code> and <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">union</span></code> are currently ill-formed, so no existing code would be affected by this proposal. This proposal does not make any changes to other existing language or library features (although implementations would be free to make use of it in their standard library implementations, should they desire to do so).</p>
</div>
<div class="section" id="additional-examples">
<h1><a class="toc-backref" href="p0223r0.html#id6">Additional Examples</a></h1>
<p>This feature is particularly useful for template members of template classes, including nested template types:</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="keyword">class</span> <span class="name class">Foo</span>
<span class="punctuation">{</span>
  <span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">U</span><span class="operator">&gt;</span> <span class="keyword type">void</span> <span class="name">foo</span><span class="punctuation">(</span><span class="name">U</span><span class="punctuation">);</span>
  <span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">U</span><span class="operator">&gt;</span> <span class="keyword">class</span> <span class="name class">Bar</span> <span class="punctuation">{</span> <span class="name">Bar</span><span class="punctuation">()</span> <span class="punctuation">};</span>
<span class="punctuation">};</span>

<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="keyword">namespace</span> <span class="keyword">class</span> <span class="name class">Foo</span>
<span class="punctuation">{</span>
  <span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">U</span><span class="operator">&gt;</span> <span class="keyword type">void</span> <span class="name">foo</span><span class="punctuation">(</span><span class="name">U</span><span class="punctuation">)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>

  <span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">U</span><span class="operator">&gt;</span> <span class="keyword">class</span> <span class="name class">Bar</span>
  <span class="punctuation">{</span>
    <span class="name">Bar</span><span class="punctuation">()</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span>

<span class="comment single">// Compare to the old syntax:
</span><span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span>
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">U</span><span class="operator">&gt;</span>
<span class="keyword type">void</span> <span class="name">Foo</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;::</span><span class="name">foo</span><span class="operator">&lt;</span><span class="name">U</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">U</span><span class="punctuation">)</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>

<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">T</span><span class="operator">&gt;</span>
<span class="keyword">template</span> <span class="operator">&lt;</span><span class="keyword">typename</span> <span class="name">U</span><span class="operator">&gt;</span>
<span class="keyword type">void</span> <span class="name">Foo</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;::</span><span class="name">Bar</span><span class="operator">&lt;</span><span class="name">U</span><span class="operator">&gt;::</span><span class="name">Bar</span><span class="punctuation">()</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
</pre>
<p>Per the transformation rule, it works with specializations, as one would expect:</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span> <span class="operator">&lt;&gt;</span> <span class="keyword">namespace</span> <span class="keyword">class</span> <span class="name class">Foo</span><span class="operator">&lt;</span><span class="keyword type">int</span><span class="operator">&gt;</span>
<span class="punctuation">{</span>
  <span class="punctuation">...</span>
<span class="punctuation">}</span>
</pre>
<p>(Note that this is allowed with or without a specialization of <code class="cpp c++"><span class="name">Foo</span><span class="operator">&lt;</span><span class="keyword type">int</span><span class="operator">&gt;</span></code>, just as it is currently permitted to specialize class members without specializing the entire class definition. Naturally, if the class definition <em>is</em> specialized, then definitions in the corresponding class name scope must match members declared in said specialization.)</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="p0223r0.html#id7">Discussion</a></h1>
<div class="section" id="syntax">
<h2><a class="toc-backref" href="p0223r0.html#id8">Syntax</a></h2>
<p>The proposed syntax for introducing the scope is open for debate. Alternative suggestions include:</p>
<ol class="arabic simple">
<li><code class="cpp c++"><span class="keyword">class</span> <span class="name class">namespace</span> <span class="operator">&lt;</span><span class="name">name</span><span class="operator">&gt;</span></code></li>
<li><code class="cpp c++"><span class="keyword">namespace</span> <span class="operator">&lt;</span><span class="name">classname</span><span class="operator">&gt;</span></code></li>
<li>Introduction of a new contextual keyword, e.g. <code class="cpp c++"><span class="keyword">class</span> <span class="error">&lt;</span><span class="name class">name</span><span class="operator">&gt;</span> <span class="name">implementation</span></code>.</li>
<li>Introduction of a new (global) keyword, e.g. <code class="cpp c++"><span class="name">implement</span> <span class="keyword">class</span> <span class="error">&lt;</span><span class="name class">name</span><span class="operator">&gt;</span></code>.</li>
</ol>
<p>The author considers #1 to be very nearly as good as the suggested syntax. #2 is okay, but risks confusion, as the reader must know a priori if the named scope is a class (the #2 syntax would only introduce a class name scope if the identifier following the <code class="cpp c++"><span class="keyword">namespace</span></code> keyword is an already declared class-type). #3 is of similar quality to #2; it lacks the ambiguity problem, but the indication that &quot;something is different&quot; occurs later, and it does require a new (albeit contextual) keyword. #4 has the advantage of maximum possible clarity, but introducing new keywords without breaking existing code is always tricky.</p>
<p>We additionally feel that the proposed syntax is the most consistent with the current state of the language. It maintains the traditional order of tokens, e.g. compared to use of traditional namespaces. It uses tokens in an order than makes sense according to English grammar rules, i.e. <em>&lt;verb&gt; &lt;adjective&gt; &lt;noun&gt;</em> (with <code class="cpp c++"><span class="keyword">namespace</span></code> here acting as a verb, indicating that a scope block is starting) with <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">class</span> <span class="name class">Foo</span></code> comparable to e.g. &quot;open blue ball&quot;.</p>
</div>
<div class="section" id="inline">
<h2><a class="toc-backref" href="p0223r0.html#id9">Inline</a></h2>
<p>Should <code class="cpp c++"><span class="keyword reserved">inline</span> <span class="keyword">namespace</span> <span class="keyword">class</span> <span class="error">&lt;</span><span class="name class">name</span><span class="operator">&gt;</span></code> be permitted? The &quot;inline namespace&quot; concept does not make sense in this context. If it is permitted, it should be equivalent to including <code class="cpp c++"><span class="keyword reserved">inline</span></code> as part of every contained definition. The author's inclination is to forbid use of <code class="cpp c++"><span class="keyword reserved">inline</span></code> with <code class="cpp c++"><span class="keyword">namespace</span> <span class="keyword">class</span></code>.</p>
</div>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="p0223r0.html#id10">Acknowledgments</a></h1>
<p>This proposal is a continuation of <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1420.pdf">N1420</a> by Carl Daniel. It was originally written prior to the author's discovery of N1420. The original feature request that spawned this new proposal comes from John Yates. Miro Knejp and Péter Radics contributed valuable suggestions. Other contemporary participants include Larry Evans, Russell Greene, Bjorn Reese, Evan Teran and Andrew Tomazos. (The author also acknowledges prior discussion of a very similar feature: see <a class="reference external" href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/xukd1mgd21I/uHjx6YR_EnQJ">https://groups.google.com/a/isocpp.org/d/msg/std-proposals/xukd1mgd21I/uHjx6YR_EnQJ</a> and <a class="reference external" href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/xukd1mgd21I/gh5W0KS856oJ">https://groups.google.com/a/isocpp.org/d/msg/std-proposals/xukd1mgd21I/gh5W0KS856oJ</a>.)</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="p0223r0.html#id11">References</a></h1>
<ul>
<li><p class="first"><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1420.pdf">N1420</a> Class Namespaces</p>
<p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1420.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1420.pdf</a></p>
</li>
</ul>
<!-- .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. -->
<!-- kate: hl reStructuredText -->
</div>
</div>
</body>
</html>
