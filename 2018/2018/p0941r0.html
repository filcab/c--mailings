<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en-us" xml:lang="en-us">
<head>
  <title>Integrating feature-test macros into the C++ WD</title>
  <meta charset="us-ascii" />
  <style type="text/css">
    tr {
      page-break-inside: avoid;
    }

    .editornote {
      /* display: none; */
      font-family: Cursive;
      background-color: Yellow;
    }

    .note {
      font-style: italic;
    }

    ins, .ins {
      text-decoration: underline;
      background-color: #CFC;
    }

    del {
      text-decoration: line-through;
      background-color: #FCC;
    }

    h2, h3, h4, p, pre, dl, table {
      background-color: inherit;
    }

      h2:before {
        content: "[" counter(h2) "]";
        padding-right: 0.25in;
      }

      h3:before {
        content: "[" counter(h2) "." counter(h3) "]";
        padding-right: 0.25in;
      }

      h4:before {
        content: "[" counter(h2) "." counter(h3) "." counter(h4) "]";
        padding-right: 0.25in;
      }

      h2.annex:before, h2.annex ~ h2:before {
        content: "[" counter(h2, upper-alpha) "]";
        padding-right: 0.25in;
      }

      h2.annex ~ h3:before, h2.annex ~ ins h3:before {
        content: "[" counter(h2, upper-alpha) "." counter(h3) "]";
        padding-right: 0.25in;
      }

      h2.annex ~ h4:before, h2.annex ~ ins h4:before {
        content: "[" counter(h2, upper-alpha) "." counter(h3) "." counter(h4) "]";
        padding-right: 0.25in;
      }

    h1 {
      counter-reset: h2 -2;
    }

    h2.annex {
      counter-reset: h2;
    }

    h2 {
      page-break-after: avoid;
      counter-increment: h2;
      counter-reset: h3 h4 p;
    }

    h3 {
      page-break-after: avoid;
      counter-increment: h3;
      counter-reset: h4 p;
    }

    h4 {
      page-break-after: avoid;
      counter-increment: h4;
      counter-reset: p;
    }

    p:before {
      content: "[" counter(p) "]";
      padding-right: 0.25in;
    }

    p {
      counter-increment: p;
    }
  </style>
</head>
<body>
  <table border="1">
    <tbody>
      <tr>
	<th>Doc. No.:</th>
	<td>P0941R0</td>
      </tr>
      <tr>
	<th>Date:</th>
	<td>2018-02-09</td>
      </tr>
      <tr>
	<th>Reply to:</th>
	<td>Clark Nelson</td>
      </tr>
      <tr>
	<th>Audience:</th>
	<td>SG10, EWG, LEWG</td>
      </tr>
    </tbody>
  </table>
  <h1>Integrating feature-test macros into the C++ WD</h1>
  <h2>Preface</h2>
  <p>
    This revision of this paper is a hastily-prepared starting point,
    describing proposed directions for incorporating feature-test macros
    into the working draft of the C++ standard.
  </p>
  <p>
    Obviously, its life started by incorporating the text of SD-6.
    I have deleted all the rationale and examples for individual features,
    and written this new preface.
    Other than that, virtually all the changes are added
    <span class="editornote">editorial notes</span>
    suggesting what should be done with the text that follows;
    this is mainly to make life easier for both the reader and the author.
  </p>
  <h2>Contents</h2>
  <ol>
    <li><a href="p0941r0.html#intro">Introduction</a></li>
    <li><a href="p0941r0.html#expl">Explanation and rationale for the approach</a>
      <ol>
	<li><a href="p0941r0.html#expl.prob">Problem statement</a></li>
	<li><a href="p0941r0.html#expl.status">Status quo</a></li>
	<li><a href="p0941r0.html#expl.soln">Characteristics of the proposed solution</a></li>
      </ol>
    </li>
    <li><a href="p0941r0.html#recs">Recommendations</a>
      <ol>
	<li><a href="p0941r0.html#recs.intro">Introduction</a></li>
	<li><a href="p0941r0.html#recs.hasinc">Testing for the presence of a header: <code>__has_include</code></a></li>
	<li><a href="p0941r0.html#recs.hasattr">Testing for the presence of an attribute: <code>__has_cpp_attribute</code></a></li>
	<li><a href="p0941r0.html#recs.cpp17">C++17 features</a></li>
	<li><a href="p0941r0.html#recs.cpp14">C++14 features</a></li>
	<li><a href="p0941r0.html#recs.cpp11">C++11 features</a></li>
	<li><a href="p0941r0.html#recs.cpp98">C++98 features</a></li>
	<li><a href="p0941r0.html#recs.removed">Features published and later removed</a></li>
      </ol>
    </li>
    <li><a href="p0941r0.html#ts">Annex: Recommendations from Technical Specifications</a></li>
    <li><a href="p0941r0.html#model">Annex: Model wording for a Technical Specification</a></li>
    <li><a href="p0941r0.html#hist">Revision history</a></li>
  </ol>
  <h2 id="intro">Introduction</h2>
  <p>
    <span class="editornote">There would be no point in adding this,
      or anything like it, to the WD.</span>
  </p>
  <p>
    At the September 2013 (Chicago) meeting of WG21, there was a five-way poll of
		all of the C++ experts in attendance &ndash; approximately 80 &ndash; concerning
		their support for the approach described herein for feature-testing in C++. The
		results of the poll:
  </p>
  <table border="1">
    <thead>
      <tr>
	<th>Strongly favor</th>
	<th>Favor</th>
	<th>Neutral</th>
	<th>Oppose</th>
	<th>Strongly oppose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td>lots</td>
	<td>lots</td>
	<td>1</td>
	<td>0</td>
	<td>0</td>
      </tr>
    </tbody>
  </table>
  <p>
    General support for these recommendations was reaffirmed
    at the 2015 October (Kona) meeting,
    as indicated by the following straw poll:
  </p>
  <blockquote>
    <p>
      Should WG21 encourage, but not require, feature-test macros for proposals?
    </p>
    <table border="1">
      <thead>
	<tr>
	  <th>Strongly favor</th>
	  <th>Favor</th>
	  <th>Neutral</th>
	  <th>Against</th>
	  <th>Strongly against</th>
	</tr>
      </thead>
      <tr>
	<td>50</td>
	<td>13</td>
	<td>7</td>
	<td>3</td>
	<td>2</td>
      </tr>
    </table>
  </blockquote>
  <p>
    This document was subsequently designated WG21's SD-6 (sixth standing document),
		which will continue to be maintained by SG10.
  </p>
  <h2 id="expl">Explanation and rationale for the approach</h2>
  <p>
    <span class="editornote">Probably some parts of this section
      should become a new informative annex.
    </span>
  </p>
  <h3 id="expl.prob">Problem statement</h3>
  <p>
    <span class="editornote">Some of this may make sense in the annex,
      or it may be better to rewrite it.</span>
  </p>
  <p>
    The pace of innovation in the standardization of C++ makes long-term stability of
		implementations unlikely. Features are added to the language because programmers
		want to use those features. Features are added to (the working draft of) the standard
		as the features become well-specified. In many cases a feature is added to an implementation
		well before or well after the standard officially introducing it is approved.
  </p>
  <p>
    This process makes it difficult for programmers who want to use a feature to know
		whether it is available in any given implementation. Implementations rarely leap
		from one formal revision of the standard directly to the next; the implementation
		process generally proceeds by smaller steps. As a result, testing for a specific
		revision of the standard (e.g. by examining the value of the <code>__cplusplus</code>
    macro) often gives the wrong answer. Implementers generally don't want to appear
		to be claiming full conformance to a standard revision until all of its features
		are implemented. That leaves programmers with no portable way to determine which
		features are actually available to them.
  </p>
  <p>
    It is often possible for a program to determine, in a manner specific to a single
		implementation, what features are supported by that implementation; but the means
		are often poorly documented and ad hoc, and sometimes complex &ndash; especially
		when the availability of a feature is controlled by an invocation option. To make
		this determination for a variety of implementations in a single source base is complex
		and error-prone.
  </p>
  <h3 id="expl.status">Status quo</h3>
  <p>
    <span class="editornote">This section should probably not be added to the WD.</span>
  </p>
  <p>
    Here is some code that attempts to determine whether rvalue references are available
		in the implementation in use:
  </p>
  <pre>#ifndef __USE_RVALUE_REFERENCES
  #if (__GNUC__ &gt; 4 || __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3) || \
      _MSC_VER &gt;= 1600
    #if __EDG_VERSION__ &gt; 0
      #define __USE_RVALUE_REFERENCES (__EDG_VERSION__ &gt;= 410)
    #else
      #define __USE_RVALUE_REFERENCES 1
    #endif
  #elif __clang__
    #define __USE_RVALUE_REFERENCES __has_feature(cxx_rvalue_references)
  #else
    #define __USE_RVALUE_REFERENCES 0
  #endif
#endif</pre>
  <p>
    First, the GNU and Microsoft version numbers are checked to see if they are high
		enough. But then a check is made of the EDG version number, since that front end
		also has compatibility modes for both those compilers, and defines macros indicating
		(claimed) compatibility with them. If the feature wasn't implemented in the indicated
		EDG version, it is assumed that the feature is not available &ndash; even though
		it is possible for a customer of EDG to implement a feature before EDG does.
  </p>
  <p>
    Fortunately Clang has ways to test specifically for the presence of specific features.
		But unfortunately, the function-call-like syntax used for such tests won't work
		with a standard preprocessor, so this fine new feature winds up adding its own flavor
		of complexity to the mix.
  </p>
  <p>
    Also note that this code is only the beginning of a real-world solution. A complete
		solution would need to take into account more compilers, and also command-line option
		settings specific to various compilers.
  </p>
  <h3 id="expl.soln">Characteristics of the proposed solution</h3>
  <p>
    <span class="editornote">This section should probably be incorporated
      into the informative annex much as it is,
      although it's easy to imagine that it could be improved
      by tweaks and additions.</span>
  </p>
  <p>
    To preserve implementers' freedom to add features in the order that makes the most
		sense for themselves and their customers, implementers should indicate the availability
		of each separate feature by adding a definition of a macro with the name corresponding
		to that feature.
  </p>
  <p>
    <strong>Important note:</strong> By recommending the use of these macros, WG21 is
		<strong>not</strong> making any feature optional; the absence of a definition for
		the relevant feature-test macro does not make an implementation that lacks a feature
		conform to a standard that requires the feature. However, if implementers and programmers
		follow these recommendations, portability of code between real-world implementations
		should be improved.
  </p>
  <p>
    To a first approximation, a feature is identified by the WG21 paper in which it is
		specified, and by which it is introduced into the working draft of the standard.
		Not every paper introduces a new feature worth a feature-test macro, but every paper
		that is not just a collection of issue resolutions is considered a candidate; exceptions
		are explicitly justified.
  </p>
  <p>
    For C++14, the feature-test macro name generally consists of some combination of words from
		the title of the paper. In the future, it is hoped that every paper will include
		its own recommendations concerning feature-test macro names.
  </p>
  <p>
    The value specified for a feature-test macro is based on the year and month in which
		the feature is voted into the working draft. In a case where a feature is subsequently
		changed in a significant way, but arguably remains the same feature, the value of
		the macro is changed to indicate the &ldquo;revision
		level&rdquo; of the specification of the feature. However, in most cases it is expected
		that the presence of a feature can be determined by the presence of any non-zero
		macro value; for example:
  </p>
  <pre>template&lt;typename T&gt;
struct use_empty_base_opt :
	std::integral_constant&lt;bool, 
		std::is_empty&lt;T&gt;::value
#if __cpp_lib_is_final
		&amp;&amp; !std::is_final&lt;T&gt;::value
#endif
	&gt;
{ };
</pre>
  <p>
    To avoid the user's namespace, names of macros for language features are prefixed
		by &ldquo;<code>__cpp_</code>&rdquo;; for library features, by &ldquo;<code>__cpp_lib_</code>&rdquo;.
		A library feature that doesn't introduce a new header is expected to be defined
		by the header(s) that implement the feature.
  </p>
  <h2 id="recs">Recommendations</h2>
  <p>
    <span class="editornote">Most of this section should become a new normative annex.</span>
  </p>
  <h3 id="recs.intro">Introduction</h3>
  <p>
    <span class="editornote">This section would have to be modified
      to describe requirements (&ldquo;shall&rdquo;)
      instead of recommendations (&ldquo;should&rdquo;).</span>
  </p>
  <p>
    For the sake of improved portability between partial implementations of various C++
		standards, WG21 (the ISO technical committee for the C++ programming language) recommends
		that implementers and programmers follow the guidelines in this document concerning
		feature-test macros.
  </p>
  <p>
    Implementers who provide a new standard feature should define a macro with the recommended
		name and value, in the same circumstances under which the feature is available (for
		example, taking into account relevant command-line options), to indicate the presence
		of support for that feature.
  </p>
  <p>
    Programmers who wish to determine whether a feature is available in an implementation
		should base that determination on the state of the macro with the recommended name.
		(The absence of a tested feature may result in a program with decreased functionality,
		or the relevant functionality may be provided in a different way. A program that
		strictly depends on support for a feature can just try to use the feature unconditionally;
		presumably, on an implementation lacking necessary support, translation will fail.
	Therefore, if the most useful purpose for a feature-test macro
	    would be to control the inclusion of a <code>#error</code> directive
	    if the feature is unavailable,
	    that is considered inadequate justification for the macro.
	    Note that the usefulness of a test macro for a feature is completely independent
	    of the usefulness of the feature itself.)
  </p>
  <h3 id="recs.hasinc">Testing for the presence of a header: <code>__has_include</code></h3>
  <p>
    <span class="editornote">This section was already incorporated into C++17,
      so it should be ignored.</span>
  </p>
  <p>
    It is impossible for a C++ program to directly, reliably and portably determine whether
		or not a library header is available for inclusion. Conditionally including a header
		requires the use of a configuration macro, whose setting can be determined by a
		configuration-test process at build time (reliable, but less portable), or by some
		other means (often not reliable or portable).
  </p>
  <p>
    To solve this general problem, WG21 recommends that implementers provide, and programmers
		use, the <code>__has_include</code> feature.
  </p>
  <h4>Syntax</h4>
  <dl class="grammar">
    <dt><dfn>h-preprocessing-token</dfn>:</dt>
    <dd>any
      <var>preprocessing-token</var>
      other than <code>&gt;</code></dd>
  </dl>
  <dl class="grammar">
    <dt><dfn>h-pp-tokens</dfn>:</dt>
    <dd>
      <var>h-preprocessing-token</var></dd>
    <dd>
      <var>h-pp-tokens h-preprocessing-token</var></dd>
  </dl>
  <dl class="grammar">
    <dt><dfn>has-include-expression</dfn>:</dt>
    <dd><code>__has_include (</code>
      <var>header-name</var>
      <code>)</code></dd>
    <dd><code>__has_include (</code>
      <var>string-literal</var>
      <code>)</code></dd>
    <dd><code>__has_include ( &lt;</code>
      <var>h-pp-tokens</var>
      <code>&gt; )</code></dd>
  </dl>
  <h4>Semantics</h4>
  <p>
    In the first form of the
    <var>has-include-expression</var>,
	the parenthesized
    <var>header-name</var>
    token is not subject to macro expansion.
	The second and third
		forms are considered only if the first form does not match, and the preprocessing
		tokens are processed just as in normal text.
  </p>
  <p>
    A
    <var>has-include-expression</var>
    shall appear only in the controlling constant
		expression of a <code>#if</code> or <code>#elif</code> directive ([cpp.cond] 16.1).
		Prior to the evaluation of such an expression, the source file identified by the
		parenthesized preprocessing token sequence in each contained
    <var>has-include-expression</var>
    is searched for as if that preprocessing token sequence were the
    <var>pp-tokens</var>
    in a <code>#include</code> directive, except that no further macro expansion is
		performed. If such a directive would not satisfy the syntactic requirements of a
		<code>#include</code> directive, the program is ill-formed. The
    <var>has-include-expression</var>
    is replaced by the
    <var>pp-number</var>
    <code>1</code> if the search for the source
		file succeeds, and by the
    <var>pp-number</var>
    <code>0</code> if the search fails.
  </p>
  <p>
    The <code>#ifdef</code> and <code>#ifndef</code> directives, and the <code>defined</code>
    conditional inclusion operator, shall treat <code>__has_include</code> as if it
		were the name of a defined macro. The identifier <code>__has_include</code> shall
		not appear in any context not mentioned in this section.
  </p>
  <h4>Example</h4>
  <p>
    This demonstrates a way to
	use a library <code>optional</code> facility only if it is available.
  </p>
  <pre>
#ifdef __has_include
#  if __has_include(&lt;optional&gt;)
#    include &lt;optional&gt;
#    define have_optional 1
#  elif __has_include(&lt;experimental/optional&gt;)
#    include &lt;experimental/optional&gt;
#    define have_optional 1
#    define experimental_optional
#  else
#    define have_optional 0
#  endif
#endif
</pre>
  <h3 id="recs.hasattr">Testing for the presence of an attribute: <code>__has_cpp_attribute</code></h3>
  <p>
    <span class="editornote">This section should be incorporated into the description of the preprocessor.</span>
  </p>
  <p>
    A C++ program cannot directly, reliably, and portably determine whether or not
		a standard or vendor-specific attribute is available for use. Testing for attribute
		support generally requires complex macro logic, as illustrated above for language
		features in general.
  </p>
  <p>
    To solve this general problem, WG21 recommends that implementers provide, and
		programmers use, the <code>__has_cpp_attribute</code> feature.
  </p>
  <h4>Syntax</h4>
  <dl class="grammar">
    <dt><dfn>has-attribute-expression</dfn>:</dt>
    <dd><code>__has_cpp_attribute (</code>
      <var>attribute-token</var>
      <code>)</code></dd>
  </dl>
  <h4>Semantics</h4>
  <p>
    A
    <var>has-attribute-expression</var>
    shall appear only in the controlling constant
		expression of a <code>#if</code> or <code>#elif</code> directive ([cpp.cond] 16.1).
		The
    <var>has-attribute-expression</var>
    is replaced by a non-zero pp-number if the
		implementation supports an attribute with the specified name, and by the pp-number
		0 otherwise.
  </p>
  <p>
    For a standard attribute, the value of the <code>__has_cpp_attribute</code>
    macro is based on the year and month in which the attribute was voted into the working
		draft. In the case where the attribute is vendor-specific, the value is implementation-defined.
		However, in most cases it is expected that the availability of an attribute can
		be detected by any non-zero result.
  </p>
  <p>
    The <code>#ifdef</code> and <code>#ifndef</code> directives, and the <code>defined</code>
    conditional inclusion operator, shall treat <code>__has_cpp_attribute</code> as
		if it were the name of a defined macro. The identifier <code>__has_cpp_attribute</code>
    shall not appear in any context not mentioned in this section.
  </p>
  <h4>Example</h4>
  <p>
    This demonstrates a way to use the attribute <code>[[deprecated]]</code> only
		if it is available.
  </p>
  <pre>#ifndef __has_cpp_attribute
# define __has_cpp_attribute(x) 0
#endif
#if __has_cpp_attribute(deprecated)
# define ATTR_DEPRECATED(msg) [[deprecated(msg)]]
#else
# define ATTR_DEPRECATED(msg)
#endif
</pre>
  <h3 id="recs.cpp17">C++17 features</h3>
  <p>
    <span class="editornote">This paragraph probably isn't needed in the WD.</span>
  </p>
  <p>
    The following table itemizes all the changes that were made to the working draft
    for C++17 as specified in a WG21 technical document. (Changes that were made as
    specified in a core or library issue are not generally included.)
  </p>
  <p>
    <span class="editornote">Whether the "Primary Section" column should appear,
    how the table should be sorted, and what links should be included in the WD,
    are all editorial questions that will need to be decided.</span>
  </p>
  <p>
    The table is sorted by the section of the standard primarily affected. The &ldquo;Doc.
    No.&rdquo; column links to the paper itself on the committee web site. The &ldquo;Macro
    Name&rdquo; column links to the relevant portion of the &ldquo;Detailed explanation
    and rationale&rdquo; annex of this document.
    When the recommendation is to change the value
    of a macro previously recommended to be defined,
    the &ldquo;Value&rdquo; column links to the table entry
    for the previous recommendation.
  </p>
  <p>
    <span class="editornote">The most important change here would be that any library macro
      be defined by including <code>&lt;version&gt;</code>,
      as well as the header specified in the table.</span>
  </p>
  <p>
    For library features, the &ldquo;Header&ldquo; column identifies the header
		that is expected to define the macro, although the macro may also be predefined.
		For language features, the macro must be predefined.
  </p>
  <table border="1">
    <caption>Significant changes to C++17</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0296r2.html">P0296R2</a></td>
	<td>Forward progress guarantees: Base definitions</td>
	<td>4.7</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0296"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0299r1.html">P0299R1</a></td>
	<td>Forward progress guarantees for the Parallelism TS features</td>
	<td>4.7, 28.4</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0299"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4086.html">N4086</a></td>
	<td>Removing trigraphs??!</td>
	<td>5</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4086"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0245r1.html">P0245R1</a></td>
	<td>Hexadecimal floating literals for C++</td>
	<td>5.13</td>
	<td><a href="p0941r0.html#detail.cpp17.p0245"><code>__cpp_hex_float</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4267.html">N4267</a></td>
	<td>Adding u8 character literals</td>
	<td>5.13</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4267"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf">P0386R2</a></td>
	<td>Inline Variables</td>
	<td>6.2, 10.1</td>
	<td><a href="p0941r0.html#detail.cpp17.p0386"><code>__cpp_inline_variables</code></a></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0035r4.html">P0035R4</a></td>
	<td>Dynamic memory allocation for over-aligned data</td>
	<td>6.7, 8.3, 21.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0035"><code>__cpp_aligned_new</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">P0135R1</a></td>
	<td>Wording for guaranteed copy elision through simplified value categories</td>
	<td>6.10</td>
	<td><a href="p0941r0.html#detail.cpp17.p0135"><code>__cpp_guaranteed_copy_elision</code></a></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4261.html">N4261</a></td>
	<td>Proposed resolution for Core Issue 330: Qualification conversions and pointers to arrays of pointers</td>
	<td>7.5, 8.2</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4261"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html">P0012R1</a></td>
	<td>Make exception specifications be part of the type system</td>
	<td>7.13, 18.4</td>
	<td><a href="p0941r0.html#detail.cpp17.p0012" id="__cpp_noexcept_function_type"><code>__cpp_noexcept_function_type</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf">P0145R3</a></td>
	<td>Refining Expression Evaluation Order for Idiomatic C++</td>
	<td>8</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0145"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4295.html">N4295</a></td>
	<td>Folding expressions</td>
	<td>8.1, 17.6</td>
	<td><a href="p0941r0.html#detail.cpp17.n4295" id="__cpp_fold_expressions_201411"><code>__cpp_fold_expressions</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html">P0018R3</a></td>
	<td>Lambda Capture of *this by Value as [=,*this]</td>
	<td>8.1</td>
	<td><a href="p0941r0.html#detail.cpp17.p0018"><code>__cpp_capture_star_this</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0170r1.pdf">P0170R1</a></td>
	<td>Wording for Constexpr Lambda</td>
	<td>8.1</td>
	<td><a href="p0941r0.html#detail.cpp17.p0170"><code>__cpp_constexpr</code></a></td>
	<td><a href="p0941r0.html#__cpp_constexpr_201304">201603</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0002r1.html">P0002R1</a></td>
	<td>Remove Deprecated operator++(bool)</td>
	<td>8.3</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0002"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r2.html">P0292R2</a></td>
	<td>constexpr if: A slightly different syntax</td>
	<td>9.4</td>
	<td><a href="p0941r0.html#detail.cpp17.p0292"><code>__cpp_if_constexpr</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html">P0305R1</a></td>
	<td>Selection statements with initializer</td>
	<td>9.4</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0305"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html">P0184R0</a></td>
	<td>Generalizing the Range-Based For Loop</td>
	<td>9.5</td>
	<td><a href="p0941r0.html#detail.cpp17.p0184"><code>__cpp_range_based_for</code></a></td>
	<td><a href="p0941r0.html#__cpp_range_based_for_200907">201603</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3928.pdf">N3928</a></td>
	<td>Extending static_assert</td>
	<td>10</td>
	<td><a href="p0941r0.html#detail.cpp17.n3928" id="__cpp_static_assert"><code>__cpp_static_assert</code></a></td>
	<td><a href="p0941r0.html#__cpp_static_assert_200410">201411</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html">N3922</a></td>
	<td>New Rules for auto deduction from braced-init-list</td>
	<td>10.1</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n3922"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0001r1.html">P0001R1</a></td>
	<td>Remove Deprecated Use of the register Keyword</td>
	<td>10.1</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0001"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">P0091R3</a></td>
	<td>Template argument deduction for class templates</td>
	<td>10.1, 16.3, 17.9</td>
	<td><a href="p0941r0.html#detail.cpp17.p0091"><code>__cpp_deduction_guides</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0512r0.pdf">P0512R0</a></td>
	<td>Class Template Argument Deduction Assorted NB resolution and issues</td>
	<td>16.3, 17.9</td>
	<td><a href="p0941r0.html#detail.cpp17.p0512"><code>__cpp_deduction_guides</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0127r2.html">P0127R2</a></td>
	<td>Declaring non-type template parameters with auto</td>
	<td>10.1, 17.8</td>
	<td>
	  <a href="p0941r0.html#detail.cpp17.p0127"><code>__cpp_nontype_template_parameter_auto</code>
	    <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4266.html">N4266</a></td>
	<td rowspan="2">Attributes for namespaces and enumerators</td>
	<td rowspan="2">10.2, 10.3</td>
	<td><a href="p0941r0.html#detail.cpp17.n4266" id="__cpp_namespace_attributes"><code>__cpp_namespace_attributes</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.n4266" id="__cpp_enumerator_attributes"><code>__cpp_enumerator_attributes</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4230.html">N4230</a></td>
	<td>Nested namespace definition</td>
	<td>10.3</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4230"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html">P0136R1</a></td>
	<td>Rewording inheriting constructors (core issue 1941 et al)</td>
	<td>10.3, 15.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0136" id="__cpp_inheriting_constructors"><code>__cpp_inheriting_constructors</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td><a href="p0941r0.html#__cpp_inheriting_constructors_200802">201511</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0195r2.html">P0195R2</a></td>
	<td>Pack expansions in using-declarations</td>
	<td>10.3</td>
	<td><a href="p0941r0.html#detail.cpp17.p0195"><code>__cpp_variadic_using</code></a></td>
	<td>201611</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r1.pdf">P0188R1</a></td>
	<td>Wording for [[fallthrough]] attribute</td>
	<td>10.6</td>
	<td><code>__has_cpp_attribute(fallthrough)</code></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r1.pdf">P0189R1</a></td>
	<td>Wording for [[nodiscard]] attribute</td>
	<td>10.6</td>
	<td><code>__has_cpp_attribute(nodiscard)</code></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r1.pdf">P0212R1</a></td>
	<td>Wording for [[maybe_unused]] attribute</td>
	<td>10.6</td>
	<td><code>__has_cpp_attribute(maybe_unused)</code></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0028r4.html">P0028R4</a></td>
	<td>Using attribute namespaces without repetition</td>
	<td>10.6</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0028"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0283r2.html">P0283R2</a></td>
	<td>Standard and non-standard attributes</td>
	<td>10.6</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0283"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r3.html">P0217R3</a></td>
	<td>Proposed wording for structured bindings</td>
	<td>11.5</td>
	<td><a href="p0941r0.html#detail.cpp17.p0217"><code>__cpp_structured_bindings</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r1.html">P0017R1</a></td>
	<td>Extension to aggregate initialization</td>
	<td>11.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0017"><code>__cpp_aggregate_bases</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0138r2.pdf">P0138R2</a></td>
	<td>Construction Rules for enum class Values</td>
	<td>11.6</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0138"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0398r0.html">P0398R0</a></td>
	<td>Core issue 1518: Explicit default constructors and copy-list-initialization </td>
	<td>11.6</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0398"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0134r0.html">P0134R0</a></td>
	<td>Introducing a name for brace-or-equal-initializers for non-static data members</td>
	<td>12.2</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0134"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0391r0.html">P0391R0</a></td>
	<td>Introducing the term "templated entity"</td>
	<td>17</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0391"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4051.html">N4051</a></td>
	<td>Allow typename in a template template parameter</td>
	<td>17.1</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4051"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html">N4268</a></td>
	<td>Allow constant evaluation for all non-type template arguments</td>
	<td>17.3</td>
	<td><a href="p0941r0.html#detail.cpp17.n4268" id="__cpp_nontype_template_args"><code>__cpp_nontype_template_args</code></a></td>
	<td>201411</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html">P0522R0</a></td>
	<td>Matching of template template-arguments excludes compatible templates</td>
	<td>17.3</td>
	<td><a href="p0941r0.html#detail.cpp17.p0522"><code>__cpp_template_template_args</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td>201611</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0036r0.pdf">P0036R0</a></td>
	<td>Unary Folds and Empty Parameter Packs</td>
	<td>17.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0036" id="__cpp_fold_expressions"><code>__cpp_fold_expressions</code></a></td>
	<td><a href="p0941r0.html#__cpp_fold_expressions_201411">201603</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4262.pdf">N4262</a></td>
	<td>Wording for Forwarding References</td>
	<td>17.9</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4262"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4285.html">N4285</a></td>
	<td>Cleanup for exception-specification and throw-expression</td>
	<td>18</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4285"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r5.html">P0003R5</a></td>
	<td>Removing Deprecated Exception Specifications from C++17</td>
	<td>18.4</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0003"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0061r1.html">P0061R1</a></td>
	<td>__has_include for C++17</td>
	<td>19.1</td>
	<td><a href="p0941r0.html#detail.cpp17.p0061" id="__has_include"><code>__has_include</code></a></td>
	<td><em>defined</em></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0063r3.html">P0063R3</a></td>
	<td>C++17 should refer to C11 instead of C99</td>
	<td>20.5&nbsp;</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0063"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0180r2.html">P0180R2</a></td>
	<td>Reserve a New Library Namespace Future Standardization</td>
	<td>20.5</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0180"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0175r1.html">P0175R1</a></td>
	<td>Synopses for the C library</td>
	<td>21 etc.</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0175"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0298r3.pdf">P0298R3</a></td>
	<td>A byte type definition</td>
	<td>21.2</td>
	<td><a href="p0941r0.html#detail.cpp17.p0298"><code>__cpp_lib_byte</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;cstddef&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0154r1.html">P0154R1</a></td>
	<td>constexpr std::hardware_{constructive,destructive}_interference_size</td>
	<td>21.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0154"><code>__cpp_lib_hardware_interference_size</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;new&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html">P0137R1</a></td>
	<td>Core Issue 1776: Replacement of class objects containing reference members</td>
	<td>21.6, 4.5</td>
	<td><a href="p0941r0.html#detail.cpp17.p0137"><code>__cpp_lib_launder</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;new&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4259.pdf">N4259</a></td>
	<td>Wording for std::uncaught_exceptions</td>
	<td>21.8</td>
	<td><a href="p0941r0.html#detail.cpp17.n4259" id="__cpp_lib_uncaught_exceptions"><code>__cpp_lib_uncaught_exceptions</code></a></td>
	<td>201411</td>
	<td><code>&lt;exception&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4190.htm">N4190</a></td>
	<td>Removing auto_ptr, random_shuffle(), And Old &lt;functional&gt; Stuff</td>
	<td>23</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4190"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0007r1.html">P0007R1</a></td>
	<td>Constant View: A proposal for a std::as_const helper function template</td>
	<td>23.2</td>
	<td><a href="p0941r0.html#detail.cpp17.p0007"><code>__cpp_lib_as_const</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387">N4387</a></td>
	<td>Improving pair and tuple</td>
	<td>23.4, 23.5</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4387"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0209r2.pdf">P0209R2</a></td>
	<td>make_from_tuple: apply for construction</td>
	<td>23.5</td>
	<td><a href="p0941r0.html#detail.cpp17.p0209"><code>__cpp_lib_make_from_tuple</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;tuple&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="11"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html">P0220R1</a></td>
	<td rowspan="11">Adopt Library Fundamentals V1 TS Components
	  for C++17</td>
	<td>23.5</td>
	<td><a href="p0941r0.html#detail.cpp17.p0220"><code>__cpp_lib_apply</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;tuple&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="2">23.6</td>
	<td><code>__has_include(&lt;optional&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.p0220"><code>__cpp_lib_optional</code></a></td>
	<td id="__cpp_lib_optional_201603">201603</td>
	<td><code>&lt;optional&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="2">23.8</td>
	<td><code>__has_include(&lt;any&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.p0220"><code>__cpp_lib_any</code></a></td>
	<td>201603</td>
	<td><code>&lt;any&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="2">23.12</td>
	<td><code>__has_include(&lt;memory_resource&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.p0220"><code>__cpp_lib_memory_resource</code></a></td>
	<td>201603</td>
	<td><code>&lt;memory_resource&gt;</code></td>
      </tr>
      <tr>
	<td>23.14</td>
	<td><a href="p0941r0.html#detail.cpp17.p0220"><code>__cpp_lib_boyer_moore_searcher</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="2">24.4</td>
	<td><code>__has_include(&lt;string_view&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.p0220"><code>__cpp_lib_string_view</code></a></td>
	<td>201603</td>
	<td><code>&lt;string_view&gt;</code></td>
      </tr>
      <tr>
	<td>28.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0220"><code>__cpp_lib_sample</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;algorithm&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf">P0032R3</a></td>
	<td rowspan="2">Homogeneous interface for variant, any and optional</td>
	<td rowspan="2">23.6-8</td>
	<td><a href="p0941r0.html#detail.cpp17.p0032"><del><code>__lib_cpp_any</code></del><br />
	  <ins><code>__cpp_lib_any</code></ins></a>
	  <span class="editornote">ex.</span>
	</td>
	<td><a href="p0941r0.html#__cpp_lib_any_201603">201606</a></td>
	<td><code>&lt;any&gt;</code></td>
      </tr>
      <tr>
	<td><del><code>__lib_cpp_optional</code></del><br />
	  <ins><code>__cpp_lib_optional</code></ins>
	  <span class="editornote">ex.</span>
	</td>
	<td><a href="p0941r0.html#__cpp_lib_optional_201603">201606</a></td>
	<td><code>&lt;optional&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf">P0307R2</a></td>
	<td>Making Optional Greater Equal Again</td>
	<td>23.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0307"><code>__cpp_lib_optional</code></a></td>
	<td><a href="p0941r0.html#__cpp_lib_optional_201603">201606</a></td>
	<td><code>&lt;optional&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html">P0088R3</a></td>
	<td rowspan="2">Variant: a type-safe union for C++17</td>
	<td rowspan="2">23.7</td>
	<td><code>__has_include(&lt;variant&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.p0088"><code>__cpp_lib_variant</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td>201606</td>
	<td><code>&lt;variant&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0393r3.html">P0393R3</a></td>
	<td>Making Variant Greater Equal</td>
	<td>23.7</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0393"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0304r0.html">LWG2296</a></td>
	<td>std::addressof should be constexpr</td>
	<td>23.10</td>
	<td><a href="p0941r0.html#detail.cpp17.lwg2296" id="__cpp_lib_addressof_constexpr"><code>__cpp_lib_addressof_constexpr</code></a></td>
	<td>201603</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0040r3.html">P0040R3</a></td>
	<td>Extending memory management tools</td>
	<td>23.10</td>
	<td><a href="p0941r0.html#detail.cpp17.p0040"><code>__cpp_lib_raw_memory_algorithms</code></a></td>
	<td>201606</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html">P0174R2</a></td>
	<td>Deprecating Vestigial Library Parts in C++17</td>
	<td>23.10, 27.3</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0174"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0074r0.html">P0074R0</a></td>
	<td>Making std::owner_less more flexible</td>
	<td>23.11</td>
	<td><a href="p0941r0.html#detail.cpp17.p0074"><code>__cpp_lib_transparent_operators</code></a></td>
	<td><a href="p0941r0.html#__cpp_lib_transparent_operators_201210">201510</a></td>
	<td><code>&lt;memory&gt; &lt;functional&gt;</code>
	</td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4089.pdf">N4089</a></td>
	<td>Safe conversions in unique_ptr&lt;T[]&gt;</td>
	<td>23.11</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4089"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4366.html">N4366</a></td>
	<td>LWG 2228: Missing SFINAE rule in unique_ptr templated assignment</td>
	<td>23.11</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4366"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0033r1.html">P0033R1</a></td>
	<td>Re-enabling shared_from_this</td>
	<td>23.11</td>
	<td><a href="p0941r0.html#detail.cpp17.p0033"><code>__cpp_lib_enable_shared_from_this</code></a></td>
	<td>201603</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0163r0.html">P0163R0</a></td>
	<td>shared_ptr::weak_type</td>
	<td>23.11</td>
	<td><a href="p0941r0.html#detail.cpp17.p0163"><code>__cpp_lib_shared_ptr_weak_type</code></a></td>
	<td>201606</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0497r0.html">P0497R0</a></td>
	<td>Fixes to shared_ptr support for arrays</td>
	<td>23.11</td>
	<td><a href="p0941r0.html#detail.cpp17.p0497"><code>__cpp_lib_shared_ptr_arrays</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0337r0.html">P0337R0</a></td>
	<td>Delete operator= for polymorphic_allocator</td>
	<td>23.12</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0337"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html">N4169</a></td>
	<td>A proposal to add invoke function template</td>
	<td>23.14</td>
	<td><a href="p0941r0.html#detail.cpp17.n4169" id="__cpp_lib_invoke"><code>__cpp_lib_invoke</code></a></td>
	<td>201411</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4277.html">N4277</a></td>
	<td>TriviallyCopyable reference_wrapper</td>
	<td>23.14</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4277"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0005r4.html">P0005R4</a></td>
	<td>Adopt not_fn from Library Fundamentals 2 for C++17</td>
	<td>23.14</td>
	<td><a href="p0941r0.html#detail.cpp17.p0005"><code>__cpp_lib_not_fn</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0358r1.html">P0358R1</a></td>
	<td>Fixes for not_fn</td>
	<td>23.14</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0358"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0253r1.pdf">P0253R1</a></td>
	<td>Fixing a design mistake in the searchers interface
	  in Library Fundamentals</td>
	<td>23.14</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0253"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">P0302R1</a></td>
	<td>Removing Allocator Support in std::function</td>
	<td>23.14</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0302"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911.pdf">N3911</a></td>
	<td>TransformationTrait Alias void_t</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.n3911" id="__cpp_lib_void_t"><code>__cpp_lib_void_t</code></a></td>
	<td>201411</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4389.html">N4389</a></td>
	<td>Wording for bool_constant</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.n4389" id="__cpp_lib_bool_constant"><code>__cpp_lib_bool_constant</code></a></td>
	<td>201505</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0006r0.html">P0006R0</a></td>
	<td>Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.p0006"><code>__cpp_lib_type_trait_variable_templates</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a></td>
	<td>Logical Operator Type Traits</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.p0013"><code>__cpp_lib_logical_traits</code></a></td>
	<td>201510</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r1.html">P0185R1</a></td>
	<td>Adding [nothrow-]swappable traits</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.p0185" id="__cpp_lib_is_swappable"><code>__cpp_lib_is_swappable</code></a>
	</td>
	<td>201603</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html">P0604R0</a></td>
	<td>Resolving GB 55, US 84, US 85, US 86</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.p0604"><code>__cpp_lib_is_invocable</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0258r2.html">P0258R2</a></td>
	<td>has_unique_object_representations - wording</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.p0258"><code>__cpp_lib_has_unique_object_representations</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://wiki.edg.com/pub/Wg21kona2017/StrawPolls/P0625R0.html#2911">LWG2911</a></td>
	<td>An is_aggregate type trait is needed</td>
	<td>23.15</td>
	<td><a href="p0941r0.html#detail.cpp17.lwg2911"><code>__cpp_lib_is_aggregate</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0092r1.html">P0092R1</a></td>
	<td>Polishing &lt;chrono&gt;</td>
	<td>23.17</td>
	<td><a href="p0941r0.html#detail.cpp17.p0092"><code>__cpp_lib_chrono</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201510</td>
	<td><code>&lt;chrono&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0505r0.html">P0505R0</a></td>
	<td>Wording for GB 50</td>
	<td>23.17</td>
	<td><a href="p0941r0.html#detail.cpp17.p0505"><code>__cpp_lib_chrono</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><code>&lt;chrono&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="3"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html">P0024R2</a></td>
	<td rowspan="3">The Parallelism TS Should be Standardized</td>
	<td rowspan="2">23.19</td>
	<td><code>__has_include(&lt;execution&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.p0024"><del><code>__lib_cpp_execution</code></del><br />
	  <ins><code>__cpp_lib_execution</code></ins></a></td>
	<td>201603</td>
	<td><code>&lt;execution&gt;</code></td>
      </tr>
      <tr>
	<td>28, 29</td>
	<td><a href="p0941r0.html#detail.cpp17.p0024"><code>__cpp_lib_parallel_algorithm</code></a>
	  <span class="editornote">ex.</span>
	</td>
	<td>201603</td>
	<td><code>&lt;algorithm&gt;</code> <code>&lt;numeric&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0336r1.pdf">P0336R1</a></td>
	<td>Better Names for Parallel Execution Policies in C++17</td>
	<td>23.19</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0336"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0067r5.html">P0067R5</a></td>
	<td>Elementary string conversions</td>
	<td>23.20</td>
	<td><a href="p0941r0.html#detail.cpp17.p0067"><code>__cpp_lib_to_chars</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201611</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0254r2.pdf">P0254R2</a></td>
	<td>Integrating std::string_view and std::string</td>
	<td>24.3, 24.4</td>
	<td><a href="p0941r0.html#detail.cpp17.p0254"><code>__cpp_lib_string_view</code></a></td>
	<td>201606</td>
	<td><code>&lt;string&gt; &lt;string_view&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0272r1.html">P0272R1</a></td>
	<td>Give 'std::string' a non-const
	  '.data()' member function</td>
	<td>24.3</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0272"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html">P0618R0</a></td>
	<td>Deprecating &lt;codecvt&gt;</td>
	<td>25.4</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0618"><em>none</em></a>
	</td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf">N4258</a></td>
	<td>Cleaning-up noexcept in the Library</td>
	<td>26.3-26.5, 24.3</td>
	<td><a href="p0941r0.html#detail.cpp17.n4258" id="__cpp_lib_allocator_traits_is_always_equal"><code>__cpp_lib_allocator_traits_is_always_equal</code></a></td>
	<td>201411</td>
	<td><code>&lt;memory&gt;</code> <code>&lt;scoped_allocator&gt;</code><br />
	  <code>&lt;string&gt;</code> <code>&lt;deque&gt;</code><br />
	  <code>&lt;forward_list&gt;</code> <code>&lt;list&gt;</code><br />
	  <code>&lt;vector&gt;</code> <code>&lt;map&gt;</code><br />
	  <code>&lt;set&gt;</code> <code>&lt;unordered_map&gt;</code><br />
	  <code>&lt;unordered_set&gt;</code>
	</td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html">N4510</a></td>
	<td>Minimal incomplete type support for standard containers</td>
	<td>26.3, 20.5</td>
	<td><a href="p0941r0.html#detail.cpp17.n4510"><code>__cpp_lib_incomplete_container_elements</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201505</td>
	<td><code>&lt;forwardlist&gt<br />
	  &lt;list&gt; &lt;vector&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0084r2.pdf">P0084R2</a></td>
	<td>Emplace Return Type</td>
	<td>26.3</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0084"><em>none</em></a></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html">N4279</a></td>
	<td rowspan="2">Improved insertion interface for unique-key maps</td>
	<td>26.4</td>
	<td><a href="p0941r0.html#detail.cpp17.n4279" id="__cpp_lib_map_try_emplace"><code>__cpp_lib_map_try_emplace</code></a></td>
	<td>201411</td>
	<td><code>&lt;map&gt;</code></td>
      </tr>
      <tr>
	<td>26.5</td>
	<td>
	  <a href="p0941r0.html#detail.cpp17.n4279" id="__cpp_lib_unordered_map_try_emplace"><code>__cpp_lib_unordered_map_try_emplace</code></a></td>
	<td>201411</td>
	<td><code>&lt;unordered_map&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf">P0083R3</a></td>
	<td>Splicing Maps and Sets</td>
	<td>26.2</td>
	<td><a href="p0941r0.html#detail.cpp17.p0083"><code>__cpp_lib_node_extract</code></a></td>
	<td>201606</td>
	<td><code>&lt;map&gt; &lt;set&gt; &lt;unordered_map&gt; &lt;unordered_set&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4284.html">N4284</a></td>
	<td>Contiguous Iterators</td>
	<td>27.2</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.n4284"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html">P0031R0</a></td>
	<td>A Proposal to Add Constexpr Modifiers
	  to reverse_iterator, move_iterator, array
	  and Range Access</td>
	<td>27.3</td>
	<td><a href="p0941r0.html#detail.cpp17.p0031"><code>__cpp_lib_array_constexpr</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;iterator&gt; &lt;array&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf">N4280</a></td>
	<td>Non-member size() and more</td>
	<td>27.8</td>
	<td><a href="p0941r0.html#detail.cpp17.n4280" id="__cpp_lib_nonmember_container_access"><code>__cpp_lib_nonmember_container_access</code></a></td>
	<td>201411</td>
	<td><code>&lt;iterator&gt; &lt;array&gt; &lt;deque&gt; &lt;forward_list&gt;<br />
	  &lt;list&gt; &lt;map&gt; &lt;regex&gt; &lt;set&gt; &lt;string&gt;<br />
	  &lt;unordered_map&gt; &lt;unordered_set&gt; &lt;vector&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0394r4.html">P0394R4</a></td>
	<td>Hotel Parallelifornia: terminate() for Parallel Algorithms Exception Handling</td>
	<td>28.4, 21.8</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0394"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0025r0.html">P0025R0</a></td>
	<td>An algorithm to "clamp" a value
	  between a pair of boundary values</td>
	<td>28.7</td>
	<td><a href="p0941r0.html#detail.cpp17.p0025"><code>__cpp_lib_clamp</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;algorithm&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0346r1.pdf">P0346R1</a></td>
	<td>A &lt;random&gt; Nomenclature Tweak</td>
	<td>29.6</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0346"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0295r0.pdf">P0295R0</a></td>
	<td>Adopt Selected Library Fundamentals V2 Components for C++17</td>
	<td>29.8</td>
	<td><a href="p0941r0.html#detail.cpp17.p0295"><code>__cpp_lib_gcd_lcm</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201606</td>
	<td><code>&lt;numeric&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0030r1.pdf">P0030R1</a></td>
	<td>Proposal to Introduce a 3-Argument Overload
	  to std::hypot</td>
	<td>29.9</td>
	<td><a href="p0941r0.html#detail.cpp17.p0030"><code>__cpp_lib_hypot</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;cmath&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0226r1.pdf">P0226R1</a></td>
	<td>Mathematical Special Functions for C++17</td>
	<td>29.9</td>
	<td><a href="p0941r0.html#detail.cpp17.p0226"><code>__cpp_lib_math_special_functions</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;cmath&gt;</code></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r1.html">P0218R1</a></td>
	<td rowspan="2">Adopt the File System TS for C++17</td>
	<td rowspan="2">30.10</td>
	<td><code>__has_include(&lt;filesystem&gt;)</code></td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="p0941r0.html#detail.cpp17.p0218"><code>__cpp_lib_filesystem</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0219r1.html">P0219R1</a></td>
	<td>Relative Paths for Filesystem</td>
	<td>30.10</td>
	<td><a href="p0941r0.html#detail.cpp17.p0219"><code>__cpp_lib_filesystem</code></a></td>
	<td>201606</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0392r0.pdf">P0392R0</a></td>
	<td>Adapting string_view by filesystem paths</td>
	<td>30.10</td>
	<td><a href="p0941r0.html#detail.cpp17.p0392"><code>__cpp_lib_filesystem</code></a></td>
	<td>201606</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0317r1.html">P0317R1</a></td>
	<td>Directory Entry Caching for Filesystem</td>
	<td>30.10</td>
	<td><a href="p0941r0.html#detail.cpp17.p0317"><code>__cpp_lib_filesystem</code></a></td>
	<td>201703</td>
	<td><code>&lt;filesystem&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0371r1.html">P0371R1</a></td>
	<td>Temporarily discourage memory_order_consume</td>
	<td>32.4</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0371"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0152r1.html">P0152R1</a></td>
	<td>constexpr atomic&lt;T&gt;::is_always_lock_free</td>
	<td>32.6&nbsp;</td>
	<td><a href="p0941r0.html#detail.cpp17.p0152"><code>__cpp_lib_atomic_is_always_lock_free</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201603</td>
	<td><code>&lt;atomic&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4508.html">N4508</a></td>
	<td>A proposal to add shared_mutex (untimed)</td>
	<td>33.4</td>
	<td><a href="p0941r0.html#detail.cpp17.n4508"><code>__cpp_lib_shared_mutex</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201505</td>
	<td><code>&lt;shared_mutex&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0156r2.html">P0156R2</a></td>
	<td>Variadic lock_guard (Rev. 5)</td>
	<td>33.4</td>
	<td><a href="p0941r0.html#detail.cpp17.p0156r2"><code>__cpp_lib_scoped_lock</code></a>
	  <span class="editornote">ex.</span></td>
	<td>201703</td>
	<td><code>&lt;mutex&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0004r1.html">P0004R1</a></td>
	<td>Remove Deprecated iostreams aliases</td>
	<td>D</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp17.p0004"><em>none</em></a></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.cpp14">C++14 features</h3>
  <p>
    <span class="editornote">Ideally, these paragraphs should not be repeated.</span>
  </p>
  <p>
    The following table itemizes all the changes that were made to the working draft
    for C++14 as specified in a WG21 technical document. (Changes that were made as
    specified in a core or library issue are not generally included.)
  </p>
  <p>
    The table is sorted by the section of the standard primarily affected. The &ldquo;Doc.
    No.&rdquo; column links to the paper itself on the committee web site. The &ldquo;Macro
    Name&rdquo; column links to the relevant portion of the &ldquo;Detailed explanation
    and rationale&rdquo; annex of this document.
    When the recommendation is to change the value
    of a macro previously recommended to be defined,
    the &ldquo;Value&rdquo; column links to the table entry
    for the previous recommendation.
  </p>
  <p>
    For library features, the &ldquo;Header&ldquo; column identifies the header
    that is expected to define the macro, although the macro may also be predefined.
    For language features, the macro must be predefined.
  </p>
  <p>
    <span class="editornote">Obviously, how far back to go with these tables
      will be an interesting question.
      From my perspective, it would be most useful to include all of them.</span>
  </p>
  <table border="1">
    <caption>Significant changes to C++14</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3910.html">N3910</a>
	</td>
	<td>What can signal handlers do? (CWG 1441)</td>
	<td>1.9-1.10</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3910">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3927.html">N3927</a>
	</td>
	<td>Definition of Lock-Free</td>
	<td>1.10</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3927">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3472.pdf">N3472</a>
	</td>
	<td>Binary Literals in the C++ Core Language</td>
	<td>2.14</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3472" id="__cpp_binary_literals">__cpp_binary_literals</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3781.pdf">N3781</a>
	</td>
	<td>Single-Quotation-Mark as a Digit Separator</td>
	<td>2.14</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp14.n3781"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3323.pdf">N3323</a>
	</td>
	<td>A Proposal to Tweak Certain C++ Contextual Conversions</td>
	<td>4</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3323">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3648.html">N3648</a>
	</td>
	<!--feedback-->
	<td>Wording Changes for Generalized Lambda-capture</td>
	<td>5.1</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3648" id="__cpp_init_captures">__cpp_init_captures</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3649.html">N3649</a>
	</td>
	<!--feedback-->
	<td>Generic (Polymorphic) Lambda Expressions</td>
	<td>5.1</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3649" id="__cpp_generic_lambdas">__cpp_generic_lambdas</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html">N3664</a>
	</td>
	<td>Clarifying Memory Allocation</td>
	<td>5.3</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3664">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3778.html">N3778</a>
	</td>
	<td>C++ Sized Deallocation</td>
	<td>5.3, 18.6</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3778" id="__cpp_sized_deallocation">__cpp_sized_deallocation</a></code></td>
	<td>201309</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3624.html">N3624</a>
	</td>
	<td>Core Issue 1512: Pointer comparison vs qualification conversions</td>
	<td>5.9, 5.10</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3624">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html">N3652</a>
	</td>
	<td>Relaxing constraints on constexpr functions / constexpr member functions and implicit
					const</td>
	<td>5.19, 7.1</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3652" id="__cpp_constexpr_201304">__cpp_constexpr</a></code></td>
	<td><a href="p0941r0.html#__cpp_constexpr_200704">201304</a></td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html">N3638</a></td>
	<!--feedback-->
	<td rowspan="2">Return type deduction for normal functions</td>
	<td rowspan="2">7.1</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3638" id="__cpp_decltype_auto">__cpp_decltype_auto</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><code><a href="p0941r0.html#detail.cpp14.n3638" id="__cpp_return_type_deduction">__cpp_return_type_deduction</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3760.html">N3760</a>
	</td>
	<td>[[deprecated]] attribute</td>
	<td>7.6</td>
	<td><code>__has_cpp_attribute(deprecated)</code></td>
	<td>201309</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html">N3653</a>
	</td>
	<td>Member initializers and aggregates</td>
	<td>8.5</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3653" id="__cpp_aggregate_nsdmi">__cpp_aggregate_nsdmi</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3667.html">N3667</a>
	</td>
	<td>Drafting for Core 1402</td>
	<td>12.8</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3667">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3651.pdf">N3651</a>
	</td>
	<td>Variable Templates</td>
	<td>14, 14.7</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3651" id="__cpp_variable_templates">__cpp_variable_templates</a></code></td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3669.pdf">N3669</a>
	</td>
	<td>Fixing constexpr member functions without const</td>
	<td><em>various</em></td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3669">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3673.html">N3673</a>
	</td>
	<td>C++ Library Working Group Ready Issues Bristol 2013</td>
	<td><em>various</em></td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3673">none</a></em></td>
      </tr>
      <!--
			<tr>
				<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a>
				</td>
				<td>Constexpr Library Additions: utilities</td>
				<td>20.2-20.4</td>
				<td rowspan="3"><code><a href="#detail.cpp14.n3471">__cpp_lib_constexpr_functions</a></code>
				</td>
				<td rowspan="3">201210</td>
				<td><code>&lt;utility&gt;</code></td>
			</tr>
			<tr>
				<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3469.html">N3469</a>
				</td>
				<td>Constexpr Library Additions: chrono</td>
				<td>20.11</td>
				<td><code>&lt;chrono&gt;</code></td>
			</tr>
			<tr>
				<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3470.html">N3470</a>
				</td>
				<td>Constexpr Library Additions: containers</td>
				<td>23.3</td>
				<td><code>&lt;array&gt;</code></td>
			</tr>
-->
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html">N3658</a>
	</td>
	<!--feedback-->
	<td>Compile-time integer sequences</td>
	<td>20</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3658" id="__cpp_lib_integer_sequence">__cpp_lib_integer_sequence</a></code></td>
	<td>201304</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3668.html">N3668</a>
	</td>
	<!--feedback-->
	<td>exchange() utility function</td>
	<td>20</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3668" id="__cpp_lib_exchange_function">__cpp_lib_exchange_function</a></code></td>
	<td>201304</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a>
	</td>
	<td>Constexpr Library Additions: utilities</td>
	<td>20.2-20.4</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp14.n3471"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3670.html">N3670</a>
	</td>
	<td>Wording for Addressing Tuples by Type</td>
	<td>20.2-20.4</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3670" id="__cpp_lib_tuples_by_type">__cpp_lib_tuples_by_type</a></code></td>
	<td>201304</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3887.pdf">N3887</a>
	</td>
	<td>Consistent Metafunction Aliases</td>
	<td>20.3-20.4</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3887" id="__cpp_lib_tuple_element_t">__cpp_lib_tuple_element_t</a></code></td>
	<td>201402</td>
	<td><code>&lt;utility&gt;</code></td>
      </tr>
      <!--<tr>
				<td><code>__cpp_lib_header_optional</code></td>
				<td>201304</td>
				<td><code>&lt;utility&gt;</code></td>
			</tr>-->
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656.htm">N3656</a>
	</td>
	<!--feedback-->
	<td>make_unique</td>
	<td>20.7</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3656" id="__cpp_lib_make_unique">__cpp_lib_make_unique</a></code></td>
	<td>201304</td>
	<td><code>&lt;memory&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">N3421</a>
	</td>
	<!--feedback-->
	<td>Making Operator Functors greater&lt;&gt;</td>
	<td>20.8</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3421" id="__cpp_lib_transparent_operators_201210">__cpp_lib_transparent_operators</a></code>
	</td>
	<td>201210</td>
	<td><code>&lt;functional&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3545.pdf">N3545</a>
	</td>
	<td>An Incremental Improvement to integral_constant</td>
	<td>20.9</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3545" id="__cpp_lib_integral_constant_callable">__cpp_lib_integral_constant_callable</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf">N3655</a>
	</td>
	<td>TransformationTraits Redux</td>
	<td>20.9</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3655" id="__cpp_lib_transformation_trait_aliases">__cpp_lib_transformation_trait_aliases</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3789.txt">N3789</a>
	</td>
	<td>Constexpr Library Additions: functional</td>
	<td>20.10</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp14.n3789"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3462.html">N3462</a>
	</td>
	<!--feedback-->
	<td>std::result_of and SFINAE</td>
	<td>20.9<br />
	  20.10</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3462" id="__cpp_lib_result_of_sfinae">__cpp_lib_result_of_sfinae</a></code></td>
	<td>201210</td>
	<td><code>&lt;functional&gt;</code><br />
	  <code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3945.html#2112">LWG 2112</a></td>
	<td>User-defined classes that cannot be derived from</td>
	<td>20.10</td>
	<td><code><a href="p0941r0.html#detail.cpp14.lwg2112" id="__cpp_lib_is_final">__cpp_lib_is_final</a></code></td>
	<td>201402</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3822.html#2247">LWG 2247</a></td>
	<td>Type traits and std::nullptr_t</td>
	<td>20.10</td>
	<td><code><a href="p0941r0.html#detail.cpp14.lwg2247" id="__cpp_lib_is_null_pointer">__cpp_lib_is_null_pointer</a></code></td>
	<td>201309</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3469.html">N3469</a>
	</td>
	<td>Constexpr Library Additions: chrono</td>
	<td>20.11</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp14.n3471"><em>none</em></a></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642.pdf">N3642</a></td>
	<td rowspan="2">User-defined Literals for Standard Library Types</td>
	<td>20.11</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3642" id="__cpp_lib_chrono_udls">__cpp_lib_chrono_udls</a></code></td>
	<td>201304</td>
	<td><code>&lt;chrono&gt;</code></td>
      </tr>
      <tr>
	<td>21.7</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3642" id="__cpp_lib_string_udls">__cpp_lib_string_udls</a></code></td>
	<td>201304</td>
	<td><code>&lt;string&gt;</code></td>
      </tr>
      <!--<tr>
				<td><code>__cpp_lib_header_dynarray</code></td>
				<td>201304</td>
				<td><code>&lt;utility&gt;</code></td>
			</tr>-->
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3470.html">N3470</a>
	</td>
	<td>Constexpr Library Additions: containers</td>
	<td>23.3</td>
	<td colspan="3"><a href="p0941r0.html#detail.cpp14.n3471"><em>none</em></a></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>
	</td>
	<!--feedback-->
	<td>Adding heterogeneous comparison lookup to associative containers</td>
	<td>23.4</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3657" id="__cpp_lib_generic_associative_lookup">__cpp_lib_generic_associative_lookup</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;map&gt;</code><br />
	  <code>&lt;set&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf">N3644</a>
	</td>
	<!--feedback-->
	<td>Null Forward Iterators</td>
	<td>24.2</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3644" id="__cpp_lib_null_iterators">__cpp_lib_null_iterators</a></code></td>
	<td>201304</td>
	<td><code>&lt;iterator&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3945.html#2285">LWG 2285</a></td>
	<td>make_reverse_iterator</td>
	<td>24.5</td>
	<td><code><a href="p0941r0.html#detail.cpp14.lwg2285" id="__cpp_lib_make_reverse_iterator">__cpp_lib_make_reverse_iterator</a></code>
	</td>
	<td>201402</td>
	<td><code>&lt;iterator&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3671.html">N3671</a>
	</td>
	<td>Making non-modifying sequence operations more robust</td>
	<td>25.2</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3671" id="__cpp_lib_robust_nonmodifying_seq_ops">__cpp_lib_robust_nonmodifying_seq_ops</a></code>
	</td>
	<td>201304</td>
	<td><code>&lt;algorithm&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3779.pdf">N3779</a>
	</td>
	<td>User-defined Literals for std::complex</td>
	<td>26.4</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3779" id="__cpp_lib_complex_udls">__cpp_lib_complex_udls</a></code></td>
	<td>201309</td>
	<td><code>&lt;complex&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3924.pdf">N3924</a>
	</td>
	<td>Discouraging rand() in C++14</td>
	<td>26.8</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3924">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3654.html">N3654</a>
	</td>
	<td>Quoted Strings Library Proposal</td>
	<td>27.7</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3654" id="__cpp_lib_quoted_string_io">__cpp_lib_quoted_string_io</a></code></td>
	<td>201304</td>
	<td><code>&lt;iomanip&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3945.html#2249">LWG 2249</a></td>
	<td>Remove gets from &lt;cstdio&gt;</td>
	<td>27.9</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.lwg2249">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3786.html">N3786</a>
	</td>
	<td>Prohibiting "out of thin air" results in C++14</td>
	<td>29.3</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3786">none</a></em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3659.html">N3659</a>
	</td>
	<td>Shared locking in C++</td>
	<td>30.4</td>
	<td><a href="p0941r0.html#detail.cpp14.n3659"><code>__has_include(&lt;shared_mutex&gt;)</code></a>
	</td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3891.htm">N3891</a>
	</td>
	<td>A proposal to rename shared_mutex to shared_timed_mutex</td>
	<td>30.4</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3891" id="__cpp_lib_shared_timed_mutex">__cpp_lib_shared_timed_mutex</a></code></td>
	<td>201402</td>
	<td><code>&lt;shared_mutex&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3776.pdf">N3776</a>
	</td>
	<td>Wording for ~future</td>
	<td>30.6</td>
	<td colspan="3"><em><a href="p0941r0.html#detail.cpp14.n3776">none</a></em></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.cpp11">C++11 features</h3>
  <table border="1">
    <caption>Significant features of C++11</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html">N2249</a></td>
	<td>New Character Types in C++</td>
	<td>2.13</td>
	<td><a id="__cpp_unicode_characters"><code>__cpp_unicode_characters</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="2"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">N2442</a></td>
	<td rowspan="2">Raw and Unicode String Literals Unified Proposal</td>
	<td rowspan="2">2.13</td>
	<td><a id="__cpp_raw_strings"><code>__cpp_raw_strings</code></a></td>
	<td>200710</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a id="__cpp_unicode_literals"><code>__cpp_unicode_literals</code></a></td>
	<td>200710</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf">N2765</a></td>
	<td>User-defined Literals</td>
	<td>2.13, 13.5</td>
	<td><a id="__cpp_user_defined_literals"><code>__cpp_user_defined_literals</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm">N2660</a></td>
	<td>Dynamic Initialization and Destruction with Concurrency</td>
	<td>3.6</td>
	<td><a><code>__cpp_threadsafe_static_init</code></a></td>
	<td>200806</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf">N2927</a></td>
	<td>New wording for C++0x lambdas</td>
	<td>5.1</td>
	<td><a id="__cpp_lambdas"><code>__cpp_lambdas</code></a></td>
	<td>200907</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a></td>
	<td>Generalized Constant Expressions</td>
	<td>5.19, 7.1</td>
	<td><a id="__cpp_constexpr_200704"><code>__cpp_constexpr</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">N2930</a></td>
	<td>Range-Based For Loop Wording (Without Concepts)</td>
	<td>6.5</td>
	<td><a id="__cpp_range_based_for_200907"><code>__cpp_range_based_for</code></a></td>
	<td>200907</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">N1720</a></td>
	<td>Proposal to Add Static Assertions to the Core Language</td>
	<td>7</td>
	<td><a id="__cpp_static_assert_200410"><code>__cpp_static_assert</code></a></td>
	<td>200410</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">N2343</a></td>
	<td>Decltype</td>
	<td>7.1</td>
	<td><a id="__cpp_decltype"><code>__cpp_decltype</code></a></td>
	<td>200707</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td rowspan="3"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">N2761</a></td>
	<td rowspan="3">Towards support for attributes in C++</td>
	<td rowspan="3">7.6</td>
	<td><a id="__cpp_attributes"><code>__cpp_attributes</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a><code>__has_cpp_attribute(noreturn)</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a><code>__has_cpp_attribute(carries_dependency)</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html">N2118</a></td>
	<td>A Proposal to Add an Rvalue Reference to the C++ Language</td>
	<td>8.3</td>
	<td><a id="__cpp_rvalue_references"><code>__cpp_rvalue_references</code></a></td>
	<td>200610</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">N2242</a></td>
	<td>Proposed Wording for Variadic Templates</td>
	<td>8.3, 14</td>
	<td><a id="__cpp_variadic_templates"><code>__cpp_variadic_templates</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.pdf">N2672</a></td>
	<td>Initializer List proposed wording</td>
	<td>8.5</td>
	<td><a id="__cpp_initializer_lists"><code>__cpp_initializer_lists</code></a></td>
	<td>200806</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">N1986</a></td>
	<td>Delegating Constructors</td>
	<td>12.6</td>
	<td><a id="__cpp_delegating_constructors"><code>__cpp_delegating_constructors</code></a></td>
	<td>200604</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm">N2756</a></td>
	<td>Non-static data member initializers</td>
	<td>12.6</td>
	<td><a id="__cpp_nsdmi"><code>__cpp_nsdmi</code></a></td>
	<td>200809</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm">N2540</a></td>
	<td>Inheriting Constructors</td>
	<td>12.9</td>
	<td><a id="__cpp_inheriting_constructors_200802"><code>__cpp_inheriting_constructors</code></a></td>
	<td>200802</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm">N2439</a></td>
	<td>Extending move semantics to *this</td>
	<td>13.3</td>
	<td><a id="__cpp_ref_qualifiers"><code>__cpp_ref_qualifiers</code></a></td>
	<td>200710</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">N2258</a></td>
	<td>Template Aliases</td>
	<td>14.5</td>
	<td><a id="__cpp_alias_templates"><code>__cpp_alias_templates</code></a></td>
	<td>200704</td>
	<td><em>predefined</em></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.cpp98">C++98 features</h3>
  <p>
    With very few exceptions,
    the features of C++98 have all been implemented
    in virtually every C++ compiler.
    But in many compilers, some of them can be enabled/disabled.
    It is recommended that the macros in the following table
    should be used to indicate whether one of these features
    is enabled in the current compilation.
  </p>
  <table border="1">
    <thead>
      <tr>
	<th>Feature</th>
	<th>Primary section</th>
	<th>Macro name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td>Run-time type identification</td>
	<td>5.2</td>
	<td><code><a id="__cpp_rtti">__cpp_rtti</a></code></td>
	<td>199711</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td>Exception handling</td>
	<td>15</td>
	<td><code><a id="__cpp_exceptions">__cpp_exceptions</a></code></td>
	<td>199711</td>
	<td><em>predefined</em></td>
      </tr>
    </tbody>
  </table>
  <h3 id="recs.removed">Features published and later removed</h3>
  <p>
    <span class="editornote">SG10 considered the stability
      of these recommendations to be very important,
      hence these tables.
      I believe that, going forward with having the macros in the WD,
      having information about features once included but later removed
      will still be necessary or desirable.
      But it may make more sense to have this information in SD-6
      instead of the WD.</span>
  </p>
  <h4>Features removed from C++17</h4>
  <table border="1">
    <caption>Features in the CD of C++17, subsequently removed</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html">P0077R2</a></td>
	<td>is_callable, the missing INVOKE related trait</td>
	<td>20.15</td>
	<td><a href="p0941r0.html#detail.cpp17.p0077"><code>__cpp_lib_is_callable</code></a></td>
	<td>201603</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0181r1.html">P0181R1</a></td>
	<td>Ordered By Default</td>
	<td>20.14, 23.4, 23.6</td>
	<td><a href="p0941r0.html#detail.cpp17.p0181"><code>__cpp_lib_default_order</code></a></td>
	<td>201606</td>
	<td><code>&lt;type_traits&gt;</code></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0156r0.html">P0156R0</a></td>
	<td>Variadic lock_guard</td>
	<td>30.4</td>
	<td><a href="p0941r0.html#detail.cpp17.p0156r0"><code>__cpp_lib_lock_guard_variadic</code></a></td>
	<td>201510</td>
	<td><code>&lt;mutex&gt;</code></td>
      </tr>
    </tbody>
  </table>
  <h4 id="recs.removed.cpp14">Features removed from C++14</h4>
  <table border="1">
    <caption>Features in the first CD of C++14, subsequently removed to a Technical Specification</caption>
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3639.html">N3639</a>
	</td>
	<td>Runtime-sized arrays with automatic storage duration</td>
	<td>8.3</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3639" id="__cpp_runtime_arrays">__cpp_runtime_arrays</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>
	</td>
	<td>201304</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">N3672</a>
	</td>
	<td>A proposal to add a utility class to represent optional objects</td>
	<td>20.5</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3672">__has_include(&lt;optional&gt;)</a></code>
	</td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
      <tr>
	<td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3662.html">N3662</a>
	</td>
	<!--feedback-->
	<td>C++ Dynamic Arrays</td>
	<td>23.2, 23.3</td>
	<td><code><a href="p0941r0.html#detail.cpp14.n3662">__has_include(&lt;dynarray&gt;)</a></code>
	</td>
	<td>1</td>
	<td><em>predefined</em></td>
      </tr>
    </tbody>
  </table>
  <p>
    The intention is that an implementation which provides runtime-sized arrays
        as specified in the first CD
        should define <code>__cpp_runtime_arrays</code> as 201304.
        The expectation is that a later document specifying runtime-sized arrays
        will specify a different value for <code>__cpp_runtime_arrays</code>.
  </p>
  <h2 id="ts" class="annex">Annex: Recommendations from Technical Specifications (informative)</h2>
  <p>
    <span class="editornote">These annexes to SD-6 would probably make no sense in the WD.</span>
  </p>
  <p>
    In this annex, feature-test macros from all WG21 Technical Specifications
    are collected, for convenience.
  </p>
  <h3>C++ Extensions for Library Fundamentals</h3>
  <p>
    The recommended macro name is &quot;<code>__cpp_lib_experimental_</code>&quot;
	    followed by the string in the &quot;Macro Name Suffix&quot; column.
  </p>
  <table border="1">
    <thead>
      <tr>
	<th>Doc. No.</th>
	<th>Title</th>
	<th>Primary Section</th>
	<th>Macro Name Suffix</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <!-- These rows are in the same order as their feature appears in this document. -->
    <tr>
      <td>N3915</td>
      <td>apply() call a function with arguments from a tuple</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#tuple.apply" title="tuple.apply">3.2.2</a></td>
      <td><code>apply</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/tuple&gt;</code></td>
    </tr>
    <tr>
      <td>N3932</td>
      <td>Variable Templates For Type Traits</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#meta.type.synop" title="meta.type.synop">3.3.1</a></td>
      <td><code>type_trait_variable_templates</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/type_traits&gt;</code></td>
    </tr>
    <tr>
      <td>N3866</td>
      <td>Invocation type traits</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#meta.trans.other" title="meta.trans.other">3.3.2</a></td>
      <td><code>invocation_type</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/type_traits&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Type-erased allocator for std::function</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#func.wrap.func" title="func.wrap.func">4.2</a></td>
      <td><code>function_erased_allocator</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/functional&gt;</code></td>
    </tr>
    <tr>
      <td>N3905</td>
      <td>Extending <code>std::search</code> to use Additional Searching Algorithms</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#func.searchers" title="func.searchers">4.3</a></td>
      <td><code>boyer_moore_searching</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/functional&gt;</code></td>
    </tr>
    <tr>
      <td>N3672, N3793</td>
      <td>A utility class to represent optional objects</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#optional" title="optional">5</a></td>
      <td><code>optional</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/optional&gt;</code></td>
    </tr>
    <tr>
      <td>N3804</td>
      <td>Any Library Proposal</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#any" title="any">6</a></td>
      <td><code>any</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/any&gt;</code></td>
    </tr>
    <tr>
      <td>N3921</td>
      <td><code>string_view</code>: a non-owning reference to a string</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#string.view" title="string.view">7</a></td>
      <td><code>string_view</code></td>
      <td>201411</td>
      <td><code>&lt;experimental/string_view&gt;</code></td>
    </tr>
    <tr>
      <td>N3920</td>
      <td>Extending shared_ptr to Support Arrays</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#memory.smartptr" title="memory.smartptr">8.2</a></td>
      <td><code>shared_ptr_arrays</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/memory&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Polymorphic Memory Resources</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#memory.resource.synop" title="memory.resource.synop">8.4</a></td>
      <td><code>memory_resources</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/memory_resource&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Type-erased allocator for std::promise</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#futures.promise" title="futures.promise">9.2</a></td>
      <td><code>promise_erased_allocator</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/future&gt;</code></td>
    </tr>
    <tr>
      <td>N3916</td>
      <td>Type-erased allocator for std::packaged_task</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#futures.task" title="futures.task">9.3</a></td>
      <td><code>packaged_task_erased_allocator</code></td>
      <td>201406</td>
      <td><code>&lt;experimental/future&gt;</code></td>
    </tr>
    <tr>
      <td>N3925</td>
      <td>A <code>sample</code> Proposal</td>
      <td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#alg.random.sample" title="alg.random.sample">10.3</a></td>
      <td><code>sample</code></td>
      <td>201402</td>
      <td><code>&lt;experimental/algorithm&gt;</code></td>
    </tr>
  </table>
  <h3>C++ Extensions for Parallelism</h3>
  <table border="1">
    <thead>
      <tr>
	<th>Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><code>__cpp_lib_experimental_parallel_algorithm</code></td>
	<td>201505</td>
	<td><code>&lt;experimental/algorithm&gt;<br />
	  &lt;experimental/exception_list&gt;<br />
	  &lt;experimental/execution_policy&gt;<br />
	  &lt;experimental/numeric&gt;</code>
	</td>
      </tr>
    </tbody>
  </table>
  <h3>File System Technical Specification</h3>
  <table border="1">
    <thead>
      <tr>
	<th>Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><code>__cpp_lib_experimental_filesystem</code></td>
	<td>201406</td>
	<td><code>&lt;experimental/filesystem></code>
	</td>
      </tr>
    </tbody>
  </table>
  <h3>C++ Extensions for Transactional Memory</h3>
  <table border="1">
    <thead>
      <tr>
	<th>Name</th>
	<th>Value</th>
	<th>Header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td><code>__cpp_transactional_memory</code></td>
	<td>201505</td>
	<td><em>predeclared</em></td>
      </tr>
      <tr>
	<td><code>__has_cpp_attribute(optimize_for_synchronized)</code></td>
	<td>201505</td>
	<td><em>predeclared</em></td>
      </tr>
    </tbody>
  </table>
  <p>
    The Technical Specification for transactional memory
      specifies a new attribute,
      but does not specify a value for a
	<var>has-attribute-expression</var>
    for that attribute.
  </p>
  <h2 id="model">Annex: Model wording for a Technical Specification</h2>
  <p>
    It is recommended that Technical Specifications include the wording below.
	<var>yyyymm</var>
    indicates the year and month of the date of the TS.
  </p>
  <blockquote>
    <p><strong>1.x Feature testing [intro.features]</strong></p>
    <p>
      An implementation that provides support for this Technical Specification
	    shall define the feature test macro(s) in Table
      <var>X</var>.
    </p>
    <table border="1">
      <caption>Table X &mdash; Feature Test Macro(s)</caption>
      <thead>
	<tr>
	  <th>Name</th>
	  <th>Value</th>
	  <th>Header</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td>__cpp_<var>name</var></td>
	  <td>
	    <var>yyyymm</var></td>
	  <td>&ldquo;<em>predefined</em>&rdquo; <strong>OR</strong> &ldquo;<code>&lt;<var>name</var>&gt;</code>&rdquo;</td>
	</tr>
      </tbody>
    </table>
  </blockquote>
  <h2 id="hist">Revision history</h2>
  <table border="1">
    <thead>
      <tr>
	<th>Date</th>
	<th>Document</th>
	<th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
	<td></td>
	<td>P0941R0</td>
	<td>Initial draft</td>
      </tr>
    </tbody>
  </table>
</body>
</html>
