<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <!--adapted from https://github.com/Thiht/markdown-viewer/blob/master/chrome/lib/sss/sss.css-->
  <style type="text/css">
  body {
      color: #333;
      font-family: 'Segoe UI', 'Lucida Grande', Helvetica, sans-serif;
      line-height: 1.5;
      margin: auto;
      max-width: 1000px;
  }
  
  h1, h2, h3, h4, h5, h6 {
      font-weight: normal;
      line-height: 1em;
      margin: 20px 0;
  }
  
  h1 {
      font-size: 2.25em;
  }
  
  h2 {
      font-size: 1.75em;
  }
  
  h3 {
      font-size: 1.5em;
  }
  
  h4, h5, h6 {
      font-size: 1.25em;
  }
  
  a {
      color: #08C;
      text-decoration: none;
  }
  
  a:hover, a:focus {
      text-decoration: underline;
  }
  
  a:visited {
      color: #058;
  }
  
  img {
      max-width: 100%;
  }
  
  li + li {
      margin-top: 3px;
  }
  
  dt {
      font-weight: bold;
  }
  
  code {
      background: #EEE;
      font-family: "Consolas", "Lucida Console", monospace;
      padding: 1px 5px;
  }
  
  pre {
      background: #EEE;
      padding: 5px 10px;
      white-space: pre-wrap;
  }
  
  pre code {
      padding: 0;
  }
  
  blockquote {
      border-left: 5px solid #EEE;
      margin: 0;
      padding: 0 10px;
  }
  
  table {
      border-collapse: collapse;
      width: 100%;
  }
  
  table + table {
      margin-top: 1em;
  }
  
  thead {
      background: #EEE;
      text-align: left;
  }
  
  th, td {
      border: 1px solid #EEE;
      padding: 5px 10px;
  }
  
  hr {
      background: #EEE;
      border: 0;
      height: 1px;
  }
  </style>
</head>
<body>
<p><strong>Document number</strong>: P0037R5<br />
<strong>Date</strong>: 2018-05-07<br />
<strong>Reply-to</strong>: John McFarlane, <a href="mailto:fixed-point@john.mcfarlane.name">fixed-point@john.mcfarlane.name</a><br />
<strong>Audience</strong>: SG6, SG14, LEWG</p>
<h1>Fixed-Point Real Numbers</h1>
<h2><a name="Introduction"></a>Introduction</h2>
<p>This proposal introduces a system for performing fixed-point arithmetic using integral types.</p>
<h2>Contents</h2>
<ul>
<li><a href="p0037r5.html#Motivation">Motivation</a></li>
<li><a href="p0037r5.html#Impact-On-the-Standard">Impact On the Standard</a></li>
<li><a href="p0037r5.html#Design-Decisions">Design Decisions</a>
<ul>
<li><a href="p0037r5.html#Class-Template">Class Template</a>
<ul>
<li><a href="p0037r5.html#Rep-Type-Template-Parameter"><code>Rep</code> Type Template Parameter</a></li>
<li><a href="p0037r5.html#Exponent-and-Radix-Non-Type-Template-Parameters"><code>Exponent</code> and <code>Radix</code> Non-Type Template Parameters</a></li>
</ul></li>
<li><a href="p0037r5.html#Conversion">Conversion</a></li>
<li><a href="p0037r5.html#Access-to-Rep-Value">Access to <code>Rep</code> Value</a></li>
<li><a href="p0037r5.html#Class-Template-Deduction">Class Template Deduction</a></li>
<li><a href="p0037r5.html#Operators">Operators</a></li>
<li><a href="p0037r5.html#Custom-Division">Custom Division</a></li>
<li><a href="p0037r5.html#Alternative-Types-for-Rep">Alternative Types for <code>Rep</code></a>
<ul>
<li><a href="p0037r5.html#Required-Specializations">Required Specializations</a></li>
</ul></li>
<li><a href="p0037r5.html#Example">Example</a></li>
</ul></li>
<li><a href="p0037r5.html#Technical-Specification">Technical Specification</a>
<ul>
<li><a href="p0037r5.html#Header-fixed_point-Synopsis">Header &lt;fixed_point&gt; Synopsis</a>
<ul>
<li><a href="p0037r5.html#fixed_point-Class-Template"><code>fixed_point&lt;&gt;</code> Class Template</a></li>
</ul></li>
</ul></li>
<li><a href="p0037r5.html#Open-Issues">Open Issues</a>
<ul>
<li><a href="p0037r5.html#Library-Support">Library Support</a></li>
<li><a href="p0037r5.html#Template-Parameter-Order">Template Parameter Order</a></li>
<li><a href="p0037r5.html#Extended-Comparison-Range">Extended Comparison Range</a></li>
<li><a href="p0037r5.html#Extensions-to-Exponent-Parameter">Extensions to Exponent Parameter</a></li>
<li><a href="p0037r5.html#Allow-Binary-Operations-if-Radixes-are-Different">Allow Binary Operations if Radixes are Different</a></li>
</ul></li>
<li><a href="p0037r5.html#Prior-Art">Prior Art</a>
<ul>
<li><a href="p0037r5.html#N1169">N1169</a></li>
<li><a href="p0037r5.html#P0106">P0106</a></li>
</ul></li>
<li><a href="p0037r5.html#Acknowledgements">Acknowledgements</a></li>
<li><a href="p0037r5.html#Revisions">Revisions</a></li>
<li><a href="p0037r5.html#Reference-Implementation">Appendix 1: Reference Implementation</a></li>
<li><a href="p0037r5.html#Performance">Appendix 2: Performance</a>
<ul>
<li><a href="p0037r5.html#Types">Types</a></li>
<li><a href="p0037r5.html#Basic-Arithmetic">Basic Arithmetic</a></li>
<li><a href="p0037r5.html#3-Dimensional-Magnitude-Squared">3-Dimensional Magnitude Squared</a></li>
<li><a href="p0037r5.html#Circle-Intersection">Circle Intersection</a></li>
</ul></li>
</ul>
<h2><a name="Motivation"></a>Motivation</h2>
<p>Floating-point types are an exceedingly versatile and widely supported method of expressing real numbers on modern architectures.</p>
<p>However, there are certain situations where fixed-point arithmetic is preferable:</p>
<ul>
<li>Some systems lack native floating-point registers and must emulate them in software;</li>
<li>many others are capable of performing some or all operations more efficiently using integer arithmetic;</li>
<li>certain applications can suffer from the variability in precision which comes from a dynamic radix point <a href="http://www.pathengine.com/Contents/Overview/FundamentalConcepts/WhyIntegerCoordinates/page.php">[pathengine]</a>;</li>
<li>in situations where a variable exponent is not desired, it takes valuable space away from the significand and reduces precision and</li>
<li>not all hardware and compilers produce exactly the same results, leading to non-deterministic results.</li>
</ul>
<p>Integer types provide the basis for an efficient representation of binary fixed-point real numbers. However, laborious, error-prone steps are required to normalize the results of certain operations and to convert to and from fixed-point types.</p>
<p>A set of tools for defining and manipulating fixed-point types is proposed. These tools are designed to make work easier for those who traditionally use integers to perform low-level, high-performance fixed-point computation. They are composable such that a wide range of trade-offs between speed, accuracy and safety are supported.</p>
<h2><a name="Impact-On-the-Standard"></a>Impact On the Standard</h2>
<p>This proposal is a pure library extension. It does not require changes to any standard classes or functions. It adds several new class and function templates to new header file, <code>&lt;fixed_point&gt;</code>. Some optional deduction guides, member functions and operator overloads rely on types proposed in <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p0828r0.md">[P0828]</a> and <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p1050r0.md">[P1050]</a>.</p>
<h2><a name="Design-Decisions"></a>Design Decisions</h2>
<p>The design is driven by the following aims in roughly descending order:</p>
<ol>
<li>to automate the task of using integer types to perform low-level fixed-point arithmetic;</li>
<li>to facilitate a style of code that is intuitive to anyone who is comfortable with integer and floating-point arithmetic;</li>
<li>to treat fixed-point as a super-set of integer such that a fixed-point type with an exponent of zero can provide a drop-in replacement for its underlying integer type</li>
<li>to avoid incurring expense for unused features - including compilation time.</li>
</ol>
<p>More generally, the aim of this proposal is to contain within a single API all the tools necessary to perform fixed-point arithmetic. The design facilitates a wide range of competing compile-time strategies for avoiding overflow and precision loss, but implements only the simplest by default. Similarly, orthogonal concerns such as run-time overflow detection and rounding modes are deferred to the underlying integer types used as storage.</p>
<h3><a name="Class-Template"></a>Class Template</h3>
<p>Fixed-point numbers are specializations of</p>
<pre><code>template &lt;class Rep, int Exponent, int Radix&gt;
class fixed_point;
</code></pre>
<p>where the template parameters are described as follows.</p>
<h4><a name="Rep-Type-Template-Parameter"></a><code>Rep</code> Type Template Parameter</h4>
<p>This parameter indicates the integral type used as storage. Fundamental integral types other than <code>bool</code> are ideal choices but any suitably integer-like type can be used.</p>
<p>Other than scale, the characteristics of <code>fixed_point&lt;Rep&gt;</code> are the characteristics of <code>Rep</code> including:</p>
<ul>
<li>signedness;</li>
<li>number of digits;</li>
<li>behavior or operators and</li>
<li>alignment.</li>
</ul>
<h4><a name="Exponent-and-Radix-Non-Type-Template-Parameters"></a><code>Exponent</code> and <code>Radix</code> Non-Type Template Parameters</h4>
<p>The radix (or base) of a fixed-point type is typically two to denote scaling by powers of two. In financial applications, accurate representation of decimal fractions requires a radix of ten. Thus while <code>Radix</code> can be any number greater than one, <code>2</code> is the default.</p>
<p>The exponent of a fixed-point type is the equivalent of the exponent field in a floating-point type and shifts the stored value by the requisite number of digits necessary to produce the desired range. The default value of <code>Exponent</code> is zero, giving <code>fixed_point&lt;T&gt;</code> the same range as <code>T</code>. By far the most common use of fixed-point is to store values with fractional digits. Thus, the exponent is typically a negative value.</p>
<p>The resolution of an instantiation of <code>fixed_point</code> is</p>
<pre><code>pow(Radix, Exponent)
</code></pre>
<p>and the minimum and maximum values are</p>
<pre><code>std::numeric_limits&lt;Rep&gt;::min() * pow(Radix, Exponent)
</code></pre>
<p>and</p>
<pre><code>std::numeric_limits&lt;Rep&gt;::max() * pow(Radix, Exponent)
</code></pre>
<p>respectively.</p>
<p>Any usage that results in values of <code>Exponent</code> which lie outside the range, (<code>INT_MIN / 2</code>, <code>INT_MAX / 2</code>), may result in undefined behavior and/or overflow or underflow. This range of exponent values is far in excess of the largest built-in floating-point type and should be adequate for all intents and purposes.</p>
<h3><a name="Conversion"></a>Conversion</h3>
<p>While effort is made to ensure that significant digits are not lost during conversion, no effort is made to avoid rounding errors. Whatever would happen when converting to and from <code>Rep</code> largely applies to <code>fixed_point</code> objects also. For example:</p>
<pre><code>fixed_point&lt;int, -1&gt;{.499}==0
</code></pre>
<p>...equates to <code>true</code> and is considered an acceptable rounding error.</p>
<h3><a name="Access-to-Rep-Value"></a>Access to <code>Rep</code> Value</h3>
<p>It is sometimes necessary to read from and write to the <code>Rep</code> value contained in a <code>fixed_point&lt;Rep&gt;</code> object. This is supported through numeric traits, <code>to_rep</code> and <code>from_rep</code> respectively. These traits are described in paper, <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p0675r0.md">[P0675]</a>.</p>
<pre><code>constexpr auto a = from_rep&lt;fixed_point&lt;int, -8&gt;&gt;()(320);
static_assert(a == 1.25);

constexpr auto b = to_rep(a);
static_assert(b == 320);    // 1.25*(1&lt;&lt;8)
</code></pre>
<h3><a name="Class-Template-Deduction"></a>Class Template Deduction</h3>
<p>The type of a <code>fixed_point</code> object can be deduced by an integer initializer:</p>
<pre><code>auto a = fixed_point(0ul);
static_assert(is_same_v&lt;decltype(a), fixed_point&lt;unsigned long, 0&gt;&gt;);
</code></pre>
<p>It can also be deduced with an integral constant of type <code>constant</code> (described in <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p0827r0.md">[P0827]</a>):</p>
<pre><code>constexpr auto b = fixed_point(constant&lt;0xFF00000000L&gt;{});
static_assert(is_same_v&lt;decltype(b), const fixed_point&lt;int, 32&gt;&gt;);
static_assert(to_rep(b) == 0xFF);
</code></pre>
<p>For <code>Exponent</code>, the highest value which does not incur data loss is used. This minimizes the required range of the underlying integer value which reduces the likelihood of out-of-range errors during arithmetic operations. For <code>Rep</code>, a fundamental integer type of <code>int</code> width is preferred unless a wider type is required.</p>
<h3><a name="Operators"></a>Operators</h3>
<p>Any arithmetic, comparison, logic and bitwise operators that might be applied to integer types can also be applied to fixed-point types. A guiding principle of operator overloads is that they perform as little run-time computation as is practically possible.</p>
<p>With the exception of shift and comparison operators, binary operators can take any combination of:</p>
<ul>
<li>one or two fixed-point arguments and</li>
<li>zero or one arguments of any arithmetic type, i.e. a type for which <code>numeric_limits</code> is specialized.</li>
</ul>
<p>Assuming a binary operation, <code>@</code>, in the form</p>
<pre><code>auto R = S @ T;
</code></pre>
<p>where <code>S</code> is of type <code>fixed_point&lt;RepS, ExponentS, 2&gt;</code> and <code>T</code> is a numeric type — possibly another <code>fixed_point</code> instantiation — then result, <code>R</code>, of the operation is determined as follows.</p>
<ol>
<li><p>If <code>T</code> is a floating-point type, <code>Float</code>, then <code>S</code> is cast to <code>Float</code> and a floating-point operation takes place, e.g.:</p>
<pre><code>auto a = fixed_point&lt;long long&gt;(3) + 4.f;
static_assert(is_same_v&lt;decltype(a), decltype(3.f + 4.f)&gt;);
</code></pre></li>
<li><p>If <code>T</code> is a <code>constant</code> of integer type, <code>Integer</code>, then:</p>
<p>a. If the operator is bitwise left shift (<code>&lt;&lt;</code>), then the result is <code>fixed_point&lt;RepS, ExponentS+T::value&gt;</code> with the shift operator applied.</p>
<p>b. If the operator is bitwise right shift (<code>&gt;&gt;</code>), then the result is <code>fixed_point&lt;RepS, ExponentS-T::value&gt;</code> with the shift operator applied.</p>
<p>c. Otherwise, <code>T</code> is converted to <code>fixed_point(T{})</code>, e.g.</p>
<pre><code>auto b = fixed_point(200U) - constant&lt;100L&gt;{};
static_assert(is_same_v&lt;decltype(b), decltype(fixed_point&lt;unsigned&gt;(200) - fixed_point&lt;int&gt;(100))&gt;);
</code></pre>
<p>and proceeding rule #4 subsequently applies.</p></li>
<li><p>If <code>T</code> is an integer type, <code>Integer</code>, then:</p>
<p>a. If the operator is bitwise shift (<code>&lt;&lt;</code> or <code>&gt;&gt;</code>), then the result is type <code>S</code> with the shift operator applied.</p>
<p>b. Otherwise, <code>T</code> is cast to <code>fixed_point&lt;Integer, 0&gt;</code>, e.g.</p>
<pre><code>auto c = fixed_point&lt;&gt;(5) * 6ul;
static_assert(is_same_v&lt;decltype(c), decltype(fixed_point&lt;&gt;(5) * fixed_point&lt;unsigned long&gt;(6))&gt;);
</code></pre>
<p>and proceeding rule #4 subsequently applies.</p></li>
<li><p>If <code>T</code> is type, <code>fixed_point&lt;RepT, ExponentT, 2&gt;</code>, then:</p>
<p>a. If the operator is multiplication (<code>*</code>), then the result is <code>fixed_point&lt;decltype(RepS*RepT), ExponentS+ExponentT&gt;</code>, e.g.:</p>
<pre><code>constexpr auto d = fixed_point&lt;uint8_t, -7&gt;{1.25} * fixed_point&lt;uint8_t, -3&gt;{8};
static_assert(is_same_v&lt;decltype(d), const fixed_point&lt;int, -10&gt;&gt;);
static_assert(d == 10);
</code></pre>
<p>b. If the operator is division (<code>/</code>), then the result is <code>fixed_point&lt;decltype(RepS/RepT), ExponentS-ExponentT&gt;</code>, e.g.:</p>
<pre><code>constexpr auto e = fixed_point&lt;short, -5&gt;{1.5} / fixed_point&lt;short, -3&gt;{2.5};
static_assert(is_same_v&lt;decltype(e), const fixed_point&lt;int, -2&gt;&gt;);
static_assert(e == .5);
</code></pre>
<p>c. If the operator is modulo (<code>%</code>), then the result is <code>fixed_point&lt;decltype(RepS%RepT), ExponentS&gt;</code>, e.g.:</p>
<pre><code>constexpr auto f = fixed_point&lt;short, -5&gt;{1.5} % fixed_point&lt;short, -3&gt;{2.5};
static_assert(is_same_v&lt;decltype(f), const fixed_point&lt;int, -5&gt;&gt;);
static_assert(f == .25);
</code></pre>
<p>d. If the operator is addition (<code>+</code>) or subtraction (<code>-</code>), then the operand with the greater exponent is converted such that its exponent matches the other operands' exponent. Then the result is <code>fixed_point&lt;decltype(RepS@RepT), min(ExponentS,ExponentT)&gt;</code>, eg.:</p>
<pre><code>constexpr auto g = fixed_point&lt;int8_t, -2&gt;{12.5} - fixed_point&lt;short, 0&gt;{8};
static_assert(is_same_v&lt;decltype(g), const fixed_point&lt;int, -2&gt;&gt;);
static_assert(g == 4.5);
</code></pre>
<p>e. If the operator is comparison (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> or <code>&gt;=</code>), then the operand with the greater exponent is converted such that its exponent matches the other operands' exponent. Then the result is <code>decltype(RepS@RepT)</code>, eg.:</p>
<pre><code>constexpr auto h = fixed_point&lt;int8_t, -2&gt;{12.5} &lt;= fixed_point&lt;short, 0&gt;{8};
static_assert(is_same_v&lt;decltype(h), const bool&gt;);
static_assert(h == false);
</code></pre>
<p>(See section, <a href="p0037r5.html#Extended-Comparison-Range">Extended Comparison Range</a>, for additional details.)</p>
<p>f. If the operator is bitwise or (<code>|</code>) or xor (<code>^</code>) then the same rules as addition (<code>+</code>) are applied.</p>
<p>g. If the operator is bitwise and (<code>&amp;</code>) then the same rules as bitwise or (<code>|</code>) are applied except that the greater — not less — exponent is preferred.</p></li>
</ol>
<p>Some details have been left out for brevity. Unary operators are supported. Some minor variations occur when <code>S</code> is not <code>fixed_point</code> and <code>T</code> is <code>fixed_point</code>. Rules for bit-shifting values where <code>Radix!=2</code> do not necessarily involve a different result type. Other binary operations involving different radixes produce a return type which is optimized to contain the precise result with the minimum value stored in <code>Rep</code> and the minimum viable value of <code>Radix</code>.</p>
<p>The complete set of rules may appear to be large and complex. However, this mostly reflects the existing complexity in the behavior of arithmetic types. Relatively few design principles govern these rules:</p>
<ol>
<li>A <code>fixed_point&lt;T, 0&gt;</code> should follow the same behavior as <code>T</code> to the greatest extend practical, reflecting the facts that: a) all integers are fixed-point — rather than floating-point types and b) integer arithmetic generally provides the best efficiency and performance characteristics.</li>
<li>In situations where a trade-off between overflow and underflow must be made, the design guards against underflow. This follows from principle #1. Far more operations can cause overflow and users are generally more wary of it. And detection/handling of overflow is an orthogonal concern which is best implemented using a custom numeric type such as the <code>safe_integer</code> and <code>elastic_integer</code> types discussed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0554r0.html#componentization">[P0554]</a>.</li>
</ol>
<h3><a name="Custom-Division"></a>Custom Division</h3>
<p>The <code>fixed_point</code> division operator, <code>/</code>, performs the least work possible and, combined with the modulo operator, <code>%</code>, produces lossless results. However, it behaves very differently from floating-point division and is likely to be a source of surprises for some users.</p>
<p>In particular, the choice of quotient type can have a dramatic effect on precision. If, for example, the dividend and divisor have the same <code>Exponent</code> and <code>Radix</code>, then the quotient's <code>Exponent</code> will be zero and all fractional digits will be dropped. In contrast to floating-point division, the choice of <code>Exponent</code> cannot be tailored to the result.</p>
<p>For this reason, the <code>fractional</code> type <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p1050r0.md">[P1050]</a> is provided in order to facilitate two important use cases.</p>
<p>Firstly a 'sane default' result type can be calculated automatically in line with the formula detailed in P0106 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0106r0.html#basic_operations">[P0106]</a>. Here, a deduction guide does the work of determining that a division involving a dividend with 31 integer digits should result in a quotient with 31 fractional digits:</p>
<pre><code>constexpr auto i = fixed_point{fractional{1, 3}};
static_assert(i == 0.333333333022892475128173828125L);
static_assert(is_same_v&lt;decltype(i), const fixed_point&lt;int64_t, -31&gt;&gt;);
</code></pre>
<p>Alternatively, the user can forgo CTAD and choose the template parameters explicitly:</p>
<pre><code>constexpr auto j = fixed_point&lt;int, -16&gt;{fractional{1, 3}};
static_assert(j == 0.3333282470703125);
static_assert(is_same_v&lt;decltype(j), const fixed_point&lt;int, -16&gt;&gt;);
</code></pre>
<h3><a name="Alternative-Types-for-Rep"></a>Alternative Types for <code>Rep</code></h3>
<p>Using built-in integral types as the default underlying representation minimizes certain costs:</p>
<ul>
<li>many fixed-point operations are as efficient as their integral equivalents;</li>
<li>compile-time complexity is kept relatively low and</li>
<li>the behavior of fixed-point types should cause few surprises.</li>
</ul>
<p>However, this choice also brings with it many of the deficiencies of built-in types. For example:</p>
<ul>
<li>the typical rounding behavior is distinct for:
<ul>
<li>conversion from floating-point types;</li>
<li>right shift and</li>
<li>divide operations;</li>
</ul></li>
<li>all of these rounding behaviors cause drift and propagate error;</li>
<li>overflow, underflow and flush are handled silently with wrap-around or undefined behavior;</li>
<li>divide-by-zero similarly results in undefined behavior and</li>
<li>the range of values is limited by the largest type: <code>long long int</code>.</li>
</ul>
<p>The effort involved in addressing these deficiencies is non-trivial and on-going (for example <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0105r0.html">[P0105]</a>). As solutions are made available, it should become easier to define custom integral types which address concerns surrounding robustness and correctness. How to combine such numeric types is the topic of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0554r0.html">[P0554]</a>, <strong>Composition of Arithmetic Types</strong>.</p>
<p>Of particular note is the <code>elastic_integer</code> type detailed in <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p0828r0.md">[P0828]</a>. When used in combination with <code>fixed_point</code>, the resultant composite type is able to avoid a large proportion of the out-of-range errors associated with fixed-point arithmetic while avoiding expensive run-time overflow checks.</p>
<h4><a name="Required-Specializations"></a>Required Specializations</h4>
<p>For a type to be suitable as parameter, <code>Rep</code>, of <code>fixed_point</code>, it must meet the following requirements:</p>
<ul>
<li>it must have specialized the following existing standard library types:
<ul>
<li><code>numeric_limits</code></li>
<li><code>make_signed</code> and <code>make_unsigned</code></li>
</ul></li>
<li>it must have specialized the following proposed standard library types as described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0675r0.html">[P0675]</a>:
<ul>
<li><code>num_digits</code> and <code>set_num_digits</code>,</li>
<li><code>to_rep</code>, <code>from_rep</code> and <code>from_value</code>.</li>
</ul></li>
</ul>
<p>Note that <code>make_signed</code> and <code>make_unsigned</code> cannot be specialized for custom types. Unless this rule can be relaxed, some equivalent mechanism must be introduced in order for custom types to be used with <code>fixed_point&lt;&gt;</code>. One possibility is the addition of <code>numeric_limits&lt;&gt;::signed</code> and <code>numeric_limits&lt;&gt;::unsigned</code> type aliases.</p>
<h3><a name="Example"></a>Example</h3>
<p>The following function, <code>magnitude</code>, calculates the magnitude of a 3-dimensional vector.</p>
<pre><code>template&lt;class Fp&gt;
constexpr auto magnitude(Fp x, Fp y, Fp z)
{
    return sqrt(x*x+y*y+z*z);
}
</code></pre>
<p>And here is a call to <code>magnitude</code>.</p>
<pre><code>auto m = magnitude(
        fixed_point&lt;uint16_t, -12&gt;(1),
        fixed_point&lt;uint16_t, -12&gt;(4),
        fixed_point&lt;uint16_t, -12&gt;(9));
// m === fixed_point&lt;uint32_t, -24&gt;{9.8994948863983154}
</code></pre>
<h2><a name="Technical-Specification"></a>Technical Specification</h2>
<h3><a name="Header-fixed_point-Synopsis"></a>Header &lt;fixed_point&gt; Synopsis</h3>
<pre><code>namespace std {
  template &lt;class Rep, int Exponent, int Radix&gt; class fixed_point;

  // for each unary arithmetic, comparison, logic and bitwise operator, @
  template &lt;class RhsRep, int RhsExponent, int RhsRadix&gt;
    constexpr auto operator@(
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  // for each binary arithmetic, comparison, logic and bitwise operator, @
  template &lt;class LhsRep, int LhsExponent, int LhsRadix, class RhsRep, int RhsExponent, int RhsRadix&gt;
    constexpr auto operator@(
      const fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  template &lt;class LhsRep, int LhsExponent, int LhsRadix, class RhsFloat, typename = _impl::enable_if_t&lt;numeric_limits&lt;RhsFloat&gt;::is_iec559&gt;&gt;
    constexpr auto operator@(
      const fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      const RhsFloat &amp; rhs);
  template &lt;class LhsFloat, class RhsRep, int RhsExponent, int RhsRadix, typename = _impl::enable_if_t&lt;numeric_limits&lt;LhsFloat&gt;::is_iec559&gt;&gt;
    constexpr auto operator@(
      const LhsFloat &amp; lhs,
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  template &lt;class LhsRep, int LhsExponent, int LhsRadix, class RhsInteger, typename = _impl::enable_if_t&lt;numeric_limits&lt;RhsInteger&gt;::is_integer&gt;&gt;
    constexpr auto operator@(
      const fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      const RhsInteger &amp; rhs);
  template &lt;class LhsInteger, class RhsRep, int RhsExponent, int RhsRadix, typename = _impl::enable_if_t&lt;numeric_limits&lt;LhsInteger&gt;::is_integer&gt;&gt;
    constexpr auto operator@(
      const LhsInteger &amp; lhs,
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  template &lt;class LhsRep, int LhsExponent, int LhsRadix, auto RhsValue&gt;
    constexpr auto operator@(
      const fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      constant&lt;RhsValue&gt;);
  template &lt;auto LhsValue, class RhsRep, int RhsExponent, int RhsRadix&gt;
    constexpr auto operator@(
      constant&lt;LhsValue&gt;,
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  // for each arithmetic, comparison, logic and bitwise compound assignment operator, @=
  template &lt;class LhsRep, int LhsExponent, int LhsRadix, class RhsRep, int RhsExponent, int RhsRadix&gt;
    constexpr auto operator@=(
      fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  template &lt;class LhsRep, int LhsExponent, int LhsRadix, class RhsFloat, typename = _impl::enable_if_t&lt;numeric_limits&lt;RhsFloat&gt;::is_iec559&gt;&gt;
    constexpr auto operator@=(
      fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      const RhsFloat &amp; rhs);
  template &lt;class LhsFloat, class RhsRep, int RhsExponent, int RhsRadix, typename = _impl::enable_if_t&lt;numeric_limits&lt;LhsFloat&gt;::is_iec559&gt;&gt;
    constexpr auto operator@=(
      LhsFloat &amp; lhs,
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  template &lt;class LhsRep, int LhsExponent, int LhsRadix, class RhsInteger, typename = _impl::enable_if_t&lt;numeric_limits&lt;RhsInteger&gt;::is_integer&gt;&gt;
    constexpr auto operator@=(
      fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      const RhsInteger &amp; rhs);
  template &lt;class LhsInteger, class RhsRep, int RhsExponent, int RhsRadix, typename = _impl::enable_if_t&lt;numeric_limits&lt;LhsInteger&gt;::is_integer&gt;&gt;
    constexpr auto operator@=(
      LhsInteger &amp; lhs,
      const fixed_point&lt;RhsRep, RhsExponent, int RhsRadix&gt; &amp; rhs);

  template &lt;class LhsRep, int LhsExponent, int LhsRadix, auto RhsValue&gt;
    constexpr auto operator@=(
      fixed_point&lt;LhsRep, LhsExponent, int LhsRadix&gt; &amp; lhs,
      constant&lt;RhsValue&gt;);

  template &lt;auto Value&gt;
  fixed_point(::cnl::constant&lt;Value&gt;)
  -&gt; /* ... */;

  template &lt;class Integer&gt;
  fixed_point(Integer)
  -&gt; fixed_point&lt;Integer, 0&gt;;
}
</code></pre>
<h4><a name="fixed_point-Class-Template"></a><code>fixed_point&lt;&gt;</code> Class Template</h4>
<div class="sourceCode"><pre class="sourceCode c++"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> Rep = <span class="dt">int</span>, <span class="dt">int</span> Exponent = <span class="dv">0</span>, <span class="dt">int</span> Radix = <span class="dv">0</span>&gt;
<span class="kw">class</span> fixed_point
{
<span class="kw">public</span>:
  <span class="kw">using</span> rep = Rep;
  <span class="kw">using</span> radix = Radix;

  <span class="kw">constexpr</span> <span class="at">static</span> <span class="dt">int</span> exponent;

  <span class="kw">constexpr</span> fixed_point();
  <span class="kw">template</span>&lt;<span class="kw">class</span> FromRep, <span class="dt">int</span> FromExponent, <span class="dt">int</span> FromRadix&gt;
    <span class="kw">constexpr</span> fixed_point(fixed_point&lt;FromRep, FromExponent&gt; <span class="at">const</span>&amp;);
  <span class="kw">template</span>&lt;CNL_IMPL_CONSTANT_VALUE_TYPE Value&gt;
    <span class="kw">constexpr</span> fixed_point(constant&lt;Value&gt;);
  <span class="kw">template</span>&lt;<span class="kw">class</span> S, _impl::<span class="dt">enable_if_t</span>&lt;numeric_limits&lt;S&gt;::is_integer, <span class="dt">int</span>&gt; Dummy = <span class="dv">0</span>&gt;
    <span class="kw">constexpr</span> fixed_point(S <span class="at">const</span>&amp;);
  <span class="kw">template</span>&lt;<span class="kw">class</span> S, _impl::<span class="dt">enable_if_t</span>&lt;numeric_limits&lt;S&gt;::is_iec559, <span class="dt">int</span>&gt; Dummy = <span class="dv">0</span>&gt;
    <span class="kw">constexpr</span> fixed_point(S);
  <span class="kw">template</span>&lt;<span class="kw">class</span> Numerator, <span class="kw">class</span> Denominator&gt;
    <span class="kw">constexpr</span> fixed_point(<span class="at">const</span> fractional&lt;Numerator, Denominator&gt;&amp;);
  <span class="kw">template</span>&lt;<span class="kw">class</span> S, _impl::<span class="dt">enable_if_t</span>&lt;numeric_limits&lt;S&gt;::is_integer, <span class="dt">int</span>&gt; Dummy = <span class="dv">0</span>&gt;
    <span class="kw">constexpr</span> fixed_point&amp; <span class="kw">operator</span>=(S);
  <span class="kw">template</span>&lt;<span class="kw">class</span> S, _impl::<span class="dt">enable_if_t</span>&lt;numeric_limits&lt;S&gt;::is_iec559, <span class="dt">int</span>&gt; Dummy = <span class="dv">0</span>&gt;
    <span class="kw">constexpr</span> fixed_point&amp; <span class="kw">operator</span>=(S);
  <span class="kw">template</span>&lt;<span class="kw">class</span> FromRep, <span class="dt">int</span> FromExponent, <span class="dt">int</span> FromRadix&gt;
    <span class="kw">constexpr</span> fixed_point&amp; <span class="kw">operator</span>=(fixed_point&lt;FromRep, FromExponent&gt; <span class="at">const</span>&amp;);
  <span class="kw">template</span>&lt;<span class="kw">class</span> S, _impl::<span class="dt">enable_if_t</span>&lt;numeric_limits&lt;S&gt;::is_integer, <span class="dt">int</span>&gt; Dummy = <span class="dv">0</span>&gt;
    <span class="kw">explicit</span> <span class="kw">constexpr</span> <span class="kw">operator</span> S() <span class="at">const</span>;
  <span class="kw">template</span>&lt;<span class="kw">class</span> S, _impl::<span class="dt">enable_if_t</span>&lt;numeric_limits&lt;S&gt;::is_iec559, <span class="dt">int</span>&gt; Dummy = <span class="dv">0</span>&gt;
    <span class="kw">explicit</span> <span class="kw">constexpr</span> <span class="kw">operator</span> S() <span class="at">const</span>;
};</code></pre></div>
<h2><a name="Open-Issues"></a>Open Issues</h2>
<h3><a name="Library-Support"></a>Library Support</h3>
<p>Because the aim is to provide an alternative to existing arithmetic types which are supported by the standard library, it is conceivable that a future proposal might specialize existing class templates and overload existing functions.</p>
<p>Possible candidates for overloading include the functions defined in &lt;cmath&gt; and a templated specialization of <code>numeric_limits</code>. A new type trait, <code>is_fixed_point</code>, would also be useful.</p>
<p>While <code>fixed_point</code> is intended to provide drop-in replacements to existing built-ins, it may be preferable to deviate slightly from the behavior of certain standard functions. For example, overloads of functions from &lt;cmath&gt; will be considerably less concise, efficient and versatile if they obey rules surrounding error cases. In particular, the guarantee of setting <code>errno</code> in the case of an error prevents a function from being defined as pure. This highlights a wider issue surrounding the adoption of the functional approach and compile-time computation that is beyond the scope of this document.</p>
<p>One suggested addition is a specialization of <code>std::complex</code>. This would take the form:</p>
<pre><code>template&lt;class Rep, int Exponent, int Radix&gt;
class complex&lt;fixed_point&lt;Rep, Exponent, Radix&gt;&gt;;
</code></pre>
<p>This type's arithmetic operators would differ from existing specializations because <code>fixed_point&lt;&gt;</code> operators often return results of a different type to their operands. Hence signatures such as</p>
<pre class="c+"><code>template&lt;class T&gt;
complex&lt;T&gt; operator*( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></pre>
<p>would need to be replaced with:</p>
<pre class="c+"><code>template&lt;class T&gt;
auto operator*( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></pre>
<h3><a name="Template-Parameter-Order"></a>Template Parameter Order</h3>
<p>It is quite possible that the order of the three template parameters of <code>fixed_point</code> are the wrong way around and should be</p>
<pre><code>template&lt;int Exponent=0, Rep=int, int Radix=2&gt;
class fixed_point;
</code></pre>
<p>or:</p>
<pre><code>template&lt;int Exponent=0, int Radix=2, Rep=int&gt;
class fixed_point;
</code></pre>
<p>While being able to express <code>fixed_point&lt;Integer&gt;</code> reinforces the fact that integers are merely fixed-point types with radix point fixed at zero, the second parameter, <code>Exponent</code> is perhaps more important to specify.</p>
<h3><a name="Extended-Comparison-Range"></a>Extended Comparison Range</h3>
<p>Comparison operations between two <code>fixed_point</code> operands require that they both have the same exponent. When they do not, conversion takes place to ensure they do. Unfortunately, if the difference in exponents is too great, the conversion may cause an out-of-bounds condition.</p>
<p>However, where two operands have bits whose values are in ranges that do not overlap, it may not be necessary to perform a conversion which results in out-of-range results: a result that ensures they continue to not overlap may be sufficient. For example,</p>
<pre><code>static_assert(fixed_point&lt;uint8_t, 0&gt;{0} &lt; fixed_point&lt;uint8_t, 128&gt;{4.e38});
</code></pre>
<p>requires that the right-hand operand be converted to <code>fixed_point&lt;uint8_t, 0&gt;</code>. This will result in the underlying integer being scaled up by 1000 bits, resulting in undefined behavior and/or a flushed value. But in this case, it only needed to be scaled by 8 bits in order for none of its bit values to overlap with those of the left-hand operand.</p>
<h3><a name="Extensions-to-Exponent-Parameter"></a>Extensions to Exponent Parameter</h3>
<p>The possibility of scaling by other than an exponent has been discussed previously <a href="https://groups.google.com/a/isocpp.org/forum/#!search/fixed_point/std-proposals/nK2EsdEf20A/LWmGn-GhAwAJ">[future]</a>. It is likely that <code>fixed_point</code> is just one example of a more general numeric type, <code>scaled</code>:</p>
<pre><code>// a numeric type
template&lt;class Rep, class Scale&gt;
class scaled;

// a member of concept, &quot;scale&quot;
template&lt;int Exponent, int Radix&gt;
class power;

// fixed_point as a numeric type
template&lt;class Rep, int Exponent, int Radix&gt;
using fixed_point = scaled&lt;Rep, power&lt;Exponent, Radix&gt;&gt;;
</code></pre>
<p>This approach separates two concerns currently combined in <code>fixed_point</code>:</p>
<ol>
<li>using an existing number type to represent a new number type and</li>
<li>applying a scaling factor to the existing number.</li>
</ol>
<p>In this dichotomy, <code>scaled</code> holds onto a member variable of type, <code>Rep</code>, while <code>power</code> is stateless and provides an API which converts to and from the <code>Rep</code> type through function parameters. <code>power</code> also provides arithmetic support.</p>
<p>Alternatives to <code>power</code> would include:</p>
<ul>
<li>existing class, <code>ratio</code> (with additional arithmetic support)</li>
<li>units (containing static dimension information)</li>
<li>rounding and overflow-handling facilities</li>
<li>bounded integer</li>
<li>unit scalar (in the range [0, 1] or [-1, 1])</li>
</ul>
<p>This design is a matter for future experimentation but it has immediate consequences for the API of <code>fixed_point</code>.</p>
<h3><a name="Allow-Binary-Operations-if-Radixes-are-Different"></a>Allow Binary Operations if Radixes are Different</h3>
<p>Does it make sense to allow binary operations which take, say, a base-2 and a base-10 number? The answer is relatively straight-forward when one considers that all base-2 numbers can be expressed using base-10 numbers. What about a base-2 and a base-3 number? At this point, we may need to convert them to a base-6 number to proceed.</p>
<p>Next, how do the exponents interact in situations when the radixes are different? For example, when adding <code>fixed_point&lt;int, -2, 2&gt;</code> and <code>fixed_point&lt;int, -1, 4&gt;</code>, is the result the former or the latter? They are computationally equivalent because they both represent units of 0.25.</p>
<p>The likely solution is to choose a result type with the minimum radix and then the minimum exponent necessary in order to be able to represent all possible values. However, this may result in a set of operators which are surprising to the user. Thus is it tempting to simply forbid inter-radix operations. (Note: a similar problem is faced by <code>common_type(chrono::duration)</code>.)</p>
<h2><a name="Prior-Art"></a>Prior Art</h2>
<p>Many examples of fixed-point support in C and C++ exist. While almost all of them aim for low run-time cost and expressive alternatives to raw integer manipulation, they vary greatly in detail and in terms of their interface.</p>
<p>One especially interesting dichotomy is between solutions which offer a discrete selection of fixed-point types and libraries which contain a continuous range of exponents through type parameterization.</p>
<h3><a name="N1169"></a>N1169</h3>
<p>One example of the former is found in proposal N1169 <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1169.pdf">[N1169]</a>, the intent of which is to expose features found in certain embedded hardware. It introduces a succinct set of language-level fixed-point types and impose constraints on the number of integer or fractional digits each can possess.</p>
<p>As with all examples of discrete-type fixed-point support, the limited choice of exponents is a considerable restriction on the versatility and expressiveness of the API.</p>
<p>Nevertheless, it may be possible to harness performance gains provided by N1169 fixed-point types through explicit template specialization. This is likely to be a valuable proposition to potential users of the library who find themselves targeting platforms which support fixed-point arithmetic at the hardware level.</p>
<h3><a name="P0106"></a>P0106</h3>
<p>There are many other C++ libraries available which fall into the latter category of continuous-range fixed-point arithmetic <a href="https://github.com/mizvekov/fp">[mizvekov]</a> <a href="http://www.codeproject.com/Articles/37636/Fixed-Point-Class">[schregle]</a> <a href="https://github.com/viboes/fixed_point">[viboes]</a>. In particular, an existing library proposal by Lawrence Crowl, P0106 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0106r0.html">[P0106]</a> (formerly N3352), aims to achieve very similar goals through similar means and warrants closer comparison than N1169.</p>
<p>P0106 introduces four class templates covering the quadrant of signed versus unsigned and fractional versus integer numeric types. It is intended to replace built-in types in a wide variety of situations and accordingly, is highly compile-time configurable in terms of how rounding and overflow are handled. Parameters to these four class templates include the range in bits and - for fractional types - the resolution.</p>
<p>The <code>fixed_point</code> class template could probably - with a few caveats - be generated using the two fractional types, <code>nonnegative</code> and <code>negatable</code>, replacing the <code>Rep</code> parameter with the integer bit count of <code>Rep</code>, specifying <code>fastest</code> for the rounding mode and specifying <code>undefined</code> as the overflow mode.</p>
<p>However, <code>fixed_point</code> more closely and concisely caters to the needs of users who already use integer types and simply desire a more concise, less error-prone form. It more closely follows the four design aims of the library and - it can be argued - more closely follows the spirit of the standard in its pursuit of zero-cost abstraction.</p>
<p>Some aspects of the design of the P0106 API which back up these conclusion are that:</p>
<ul>
<li>the nature of the range-specifying template parameters - through careful framing in mathematical terms - abstracts away valuable information regarding machine-critical type size information;</li>
<li>the breaking up of duties amongst four separate class templates introduces four new concepts and incurs additional mental load for relatively little gain while further detaching the interface from vital machine-level details;</li>
<li>the absence of the most negative number from signed types reduces the capacity of all types by one and</li>
<li>the selection of rounding and overflow modes via enumerations limits the choices to a pre-existing finite set and prevents the user from providing their own such strategies -- or indeed from customizing fixed-point types in more exotic ways such as by using non-standard, platform-specific integer types.</li>
</ul>
<p>A more detailed comparison of the approaches taken in this paper and P0106 can be found in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0554r0.html">[P0554]</a>.</p>
<h2><a name="Acknowledgements"></a>Acknowledgements</h2>
<p>SG6: Lawrence Crowl<br />
SG14: Guy Davidson, Michael Wong<br />
Contributors: Ed Ainsley, Billy Baker, Lance Dyson, Marco Foco, Mathias Gaunard, Clément Grégoire, Nicolas Guillemot, Kurt Guntheroth, Matt Kinzelman, Joël Lamotte, Sean Middleditch, Paul Robinson, Patrice Roy, Peter Schregle, Ryhor Spivak</p>
<h2><a name="Revisions"></a>Revisions</h2>
<p>This paper revises <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p0037r4.md">P0037R4</a>:</p>
<ul>
<li>feedback from SG6 chair:
<ul>
<li>removed <code>multiply</code> and <code>divide</code> functions</li>
<li>added <code>Radix</code> non-type template parameter to <code>fixed_point</code>
<ul>
<li>added discussion of operators with different radixes</li>
<li>removed discussion of operators with different exponents</li>
</ul></li>
<li>put case for rearranging template parameters of <code>fixed_point</code> to put <code>Exponent</code> first</li>
<li>corrected innacurate or out-of-date information in the P0106 prior art section</li>
</ul></li>
<li>added references to <code>fractional</code> and <code>elastic_integer</code></li>
<li>added deduction guides and <code>fractional</code> c'tor and assignment operator</li>
</ul>
<p>P0037R4 revises <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0037r3.html">P0037R3</a>:</p>
<ul>
<li>removed mention of <code>width</code> and <code>set_width</code></li>
<li>rewritten description of <code>Rep</code> template parameter</li>
<li>added sections, <strong>Access to <code>Rep</code> Value</strong> and <strong>Class Template Deduction</strong></li>
<li>removed <code>make_fixed</code> and <code>make_ufixed</code> function templates</li>
<li>rewritten <strong>Operator Overloads</strong> section, renamed <strong>Operators</strong> and included <code>constant</code> operators</li>
<li>removed sections, <strong>Overflow</strong> and <strong>Underflow</strong></li>
<li>removed <code>add</code> and <code>subtract</code> function templates</li>
<li>reversed the roles of <code>operator/</code> and <code>divide</code></li>
<li>replaced section on composability with link to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0554r0.html">[P0554]</a></li>
<li>replaced reference to <a href="http://johnmcfarlane.github.io/fixed_point/papers/p0381r1.html">[P0381]</a> with reference to <a href="https://github.com/johnmcfarlane/papers/blob/master/wg21/p0675r0.md">[P0675]</a></li>
<li>revised synopsis</li>
<li>renamed section <strong>Future Issues</strong> to <strong>Open Issues</strong> and added sections,
<ul>
<li><strong>Different Division Strategies</strong>, <strong>Template Parameter Order</strong>, <strong>Disable Addition/Subtraction if Exponents are Different</strong>, <strong>Named Functions</strong>, <strong>Extended Comparison Range</strong> and remove sections</li>
<li><strong>Compile-Time Bit-Shift Operations</strong>, <strong>Alternative Return Type Policies</strong>,</li>
</ul></li>
<li>removed section, <strong>References</strong>, moving links into document body</li>
<li>rewrote <strong>Appendix 1: Reference Implementation</strong> referencing <a href="https://github.com/johnmcfarlane/cnl">[github]</a></li>
<li>formatting changes intended to make markdown more readable as plain text</li>
</ul>
<h2><a name="Reference-Implementation"></a>Appendix 1: Reference Implementation</h2>
<p>An in-development implementation of the fixed_point class template and its essential supporting functions and types is available <a href="https://github.com/johnmcfarlane/cnl">[github]</a>.</p>
<h2><a name="Performance"></a>Appendix 2: Performance</h2>
<p>Despite a focus on usable interface and direct translation from integer-based fixed-point operations, there is an overwhelming expectation that the source code result in minimal instructions and clock cycles. A few preliminary numbers are presented to give a very early idea of how the API might perform.</p>
<p>Some notes:</p>
<ul>
<li><p>A few test functions were run, ranging from single arithmetic operations to basic geometric functions, performed against integer, floating-point and fixed-point types for comparison.</p></li>
<li><p>Figures were taken from a single CPU, OS and compiler, namely:</p>
<ul>
<li>Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)</li>
<li>Target: x86_64-pc-linux-gnu</li>
<li>Thread model: posix</li>
</ul></li>
<li><p>Fixed inputs were provided to each function, meaning that branch prediction rarely fails. Results may also not represent the full range of inputs.</p></li>
<li><p>Details of the test harness used can be found in the source project mentioned in Appendix 1;</p></li>
<li><p>Times are in nanoseconds;</p></li>
<li><p>Code has not yet been optimized for performance.</p></li>
</ul>
<h3><a name="Types"></a>Types</h3>
<p>Where applicable various combinations of integer, floating-point and fixed-point types were tested with the following identifiers:</p>
<ul>
<li><code>uint8_t</code>, <code>int8_t</code>, <code>uint16_t</code>, <code>int16_t</code>, <code>uint32_t</code>, <code>int32_t</code>, <code>uint64_t</code> and <code>int64_t</code> built-in integer types;</li>
<li><code>float</code>, <code>double</code> and <code>long double</code> built-in floating-point types;</li>
<li>s3:4, u4:4, s7:8, u8:8, s15:16, u16:16, s31:32 and u32:32 format fixed-point types.</li>
</ul>
<h3><a name="Basic-Arithmetic"></a>Basic Arithmetic</h3>
<p>Plus, minus, multiplication and division were tested in isolation using a number of different numeric types with the following results:</p>
<p>name cpu_time<br />
add(float) 1.78011<br />
add(double) 1.73966<br />
add(long double) 3.46011<br />
add(u4_4) 1.87726<br />
add(s3_4) 1.85051<br />
add(u8_8) 1.85417<br />
add(s7_8) 1.82057<br />
add(u16_16) 1.94194<br />
add(s15_16) 1.93463<br />
add(u32_32) 1.94674<br />
add(s31_32) 1.94446<br />
add(int8_t) 2.14857<br />
add(uint8_t) 2.12571<br />
add(int16_t) 1.9936<br />
add(uint16_t) 1.88229<br />
add(int32_t) 1.82126<br />
add(uint32_t) 1.76<br />
add(int64_t) 1.76<br />
add(uint64_t) 1.83223<br />
sub(float) 1.96617<br />
sub(double) 1.98491<br />
sub(long double) 3.55474<br />
sub(u4_4) 1.77006<br />
sub(s3_4) 1.72983<br />
sub(u8_8) 1.72983<br />
sub(s7_8) 1.72983<br />
sub(u16_16) 1.73966<br />
sub(s15_16) 1.85051<br />
sub(u32_32) 1.88229<br />
sub(s31_32) 1.87063<br />
sub(int8_t) 1.76<br />
sub(uint8_t) 1.74994<br />
sub(int16_t) 1.82126<br />
sub(uint16_t) 1.83794<br />
sub(int32_t) 1.89074<br />
sub(uint32_t) 1.85417<br />
sub(int64_t) 1.83703<br />
sub(uint64_t) 2.04914<br />
mul(float) 1.9376<br />
mul(double) 1.93097<br />
mul(long double) 102.446<br />
mul(u4_4) 2.46583<br />
mul(s3_4) 2.09189<br />
mul(u8_8) 2.08<br />
mul(s7_8) 2.18697<br />
mul(u16_16) 2.12571<br />
mul(s15_16) 2.10789<br />
mul(u32_32) 2.10789<br />
mul(s31_32) 2.10789<br />
mul(int8_t) 1.76<br />
mul(uint8_t) 1.78011<br />
mul(int16_t) 1.8432<br />
mul(uint16_t) 1.76914<br />
mul(int32_t) 1.78011<br />
mul(uint32_t) 2.19086<br />
mul(int64_t) 1.7696<br />
mul(uint64_t) 1.79017<br />
div(float) 5.12<br />
div(double) 7.64343<br />
div(long double) 8.304<br />
div(u4_4) 3.82171<br />
div(s3_4) 3.82171<br />
div(u8_8) 3.84<br />
div(s7_8) 3.8<br />
div(u16_16) 9.152<br />
div(s15_16) 11.232<br />
div(u32_32) 30.8434<br />
div(s31_32) 34<br />
div(int8_t) 3.82171<br />
div(uint8_t) 3.82171<br />
div(int16_t) 3.8<br />
div(uint16_t) 3.82171<br />
div(int32_t) 3.82171<br />
div(uint32_t) 3.81806<br />
div(int64_t) 10.2286<br />
div(uint64_t) 8.304</p>
<p>Among the slowest types are <code>long double</code>. It is likely that they are emulated in software. The next slowest operations are fixed-point multiply and divide operations - especially with 64-bit types. This is because values need to be promoted temporarily to double-width types. This is a known fixed-point technique which inevitably experiences slowdown where a 128-bit type is required on a 64-bit system.</p>
<p>Here is a section of the disassembly of the s15:16 multiply call:</p>
<pre><code>30:   mov    %r14,%rax  
      mov    %r15,%rax  
      movslq -0x28(%rbp),%rax  
      movslq -0x30(%rbp),%rcx  
      imul   %rax,%rcx  
      shr    $0x10,%rcx  
      mov    %ecx,-0x38(%rbp)  
      mov    %r12,%rax  
4c:   movzbl (%rbx),%eax  
      cmp    $0x1,%eax  
    ↓ jne    68  
54:   mov    0x8(%rbx),%rax  
      lea    0x1(%rax),%rcx  
      mov    %rcx,0x8(%rbx)  
      cmp    0x38(%rbx),%rax  
    ↑ jb     30
</code></pre>
<p>The two 32-bit numbers are multiplied together and the result shifted down - much as it would if raw <code>int</code> values were used. The efficiency of this operation varies with the exponent. An exponent of zero should mean no shift at all.</p>
<h3><a name="3-Dimensional-Magnitude-Squared"></a>3-Dimensional Magnitude Squared</h3>
<p>A fast <code>sqrt</code> implementation has not yet been tested with <code>fixed_point</code>. (The naive implementation takes over 300ns.) For this reason, a magnitude-squared function is measured, combining multiply and add operations:</p>
<pre><code>template &lt;class FP&gt;
constexpr FP magnitude_squared(const FP &amp; x, const FP &amp; y, const FP &amp; z)
{
    return x * x + y * y + z * z;
}
</code></pre>
<p>Only real number formats are tested:</p>
<p>float 2.42606<br />
double 2.08<br />
long double 4.5056<br />
s3_4 2.768<br />
s7_8 2.77577<br />
s15_16 2.752<br />
s31_32 4.10331</p>
<p>Again, the size of the type seems to have the largest impact.</p>
<h3><a name="Circle-Intersection"></a>Circle Intersection</h3>
<p>A similar operation includes a comparison and branch:</p>
<pre><code>template &lt;class Real&gt;
bool circle_intersect_generic(Real x1, Real y1, Real r1, Real x2, Real y2, Real r2)
{
    auto x_diff = x2 - x1;
    auto y_diff = y2 - y1;
    auto distance_squared = x_diff * x_diff + y_diff * y_diff;

    auto touch_distance = r1 + r2;
    auto touch_distance_squared = touch_distance * touch_distance;

    return distance_squared &lt;= touch_distance_squared;
}
</code></pre>
<p>float 3.46011<br />
double 3.48<br />
long double 6.4<br />
s3_4 3.88<br />
s7_8 4.5312<br />
s15_16 3.82171<br />
s31_32 5.92</p>
<p>Again, fixed-point and native performance are comparable.</p>
</body>
</html>
