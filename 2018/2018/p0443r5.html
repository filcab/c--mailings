<table style="width:79%;">
<colgroup>
<col width="27%" />
<col width="51%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">Title:</td>
<td align="left">A Unified Executors Proposal for C++</td>
</tr>
<tr class="even">
<td align="left">Authors:</td>
<td align="left">Jared Hoberock, jhoberock@nvidia.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Michael Garland, mgarland@nvidia.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Chris Kohlhoff, chris@kohlhoff.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Chris Mysen, mysen@google.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Carter Edwards, hcedwar@sandia.gov</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Gordon Brown, gordon@codeplay.com</td>
</tr>
<tr class="even">
<td align="left">Other Contributors:</td>
<td align="left">Hans Boehm, hboehm@google.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Thomas Heller, thom.heller@gmail.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Lee Howes, lwh@fb.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Bryce Lelbach, brycelelbach@gmail.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Hartmut Kaiser, hartmut.kaiser@gmail.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Bryce Lelbach, brycelelbach@gmail.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Gor Nishanov, gorn@microsoft.com</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Thomas Rodgers, rodgert@twrodgers.com</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">David Hollman, dshollm@sandia.gov</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Michael Wong, michael@codeplay.com</td>
</tr>
<tr class="even">
<td align="left">Document Number:</td>
<td align="left">P0443R5</td>
</tr>
<tr class="odd">
<td align="left">Date:</td>
<td align="left">2018-02-12</td>
</tr>
<tr class="even">
<td align="left">Audience:</td>
<td align="left">SG1 - Concurrency and Parallelism, LEWG</td>
</tr>
<tr class="odd">
<td align="left">Reply-to:</td>
<td align="left">sg1-exec@googlegroups.com</td>
</tr>
<tr class="even">
<td align="left">Abstract:</td>
<td align="left">This paper proposes a programming model for executors, which are modular components for creating execution. The design of this proposal is described in paper <a href="https://wg21.link/P0761">P0761</a>.</td>
</tr>
</tbody>
</table>
<h2 id="changelog"><span class="header-section-number">0.1</span> Changelog</h2>
<h3 id="revision-5"><span class="header-section-number">0.1.1</span> Revision 5</h3>
<p>Revision 5 of this proposal responds to feedback requested during the 2017 Albuquerque ISO C++ Standards Committee meeting and introduces changes which allow properties to better interoperate with polymorphic executor wrappers and also simplify <code>execution::require</code>'s behavior.</p>
<ul>
<li>Defined general property type requirements</li>
<li>Elaborated specification of standard property types</li>
<li>Simplified <code>execution::prefer</code>'s specification</li>
<li>Enhanced polymorphic executor wrapper
<ul>
<li>Templatized <code>execution::executor&lt;SupportableProperties...&gt;</code></li>
<li>Introduced <code>prefer_only</code> property adaptor</li>
</ul></li>
<li>Responded to Albuquerque feedback
<ul>
<li>From SG1
<ul>
<li>Execution contexts are now optional properties of executors</li>
<li>Eliminated ill-specified caller-agent forward progress properties</li>
<li>Elaborated <code>Future</code>'s requirements to incorporate forward progress</li>
<li>Reworded operational semantics of execution functions to use similar language as the blocking properties</li>
<li>Elaborated <code>static_thread_pool</code>'s specification to guarantee that threads in the bool boost-block their work</li>
<li>Elaborated operational semantics of execution functions to note that forward progress guarantees are specific to the concrete executor type</li>
</ul></li>
<li>From LEWG
<ul>
<li>Eliminated named <code>BaseExecutor</code> concept</li>
<li>Simplified general executor requirements</li>
<li>Enhanced the <code>OneWayExecutor</code> introductory paragraph</li>
<li>Eliminated <code>has_*_member</code> type traits</li>
</ul></li>
</ul></li>
<li>Minor changes
<ul>
<li>Renamed TS namespace from <code>concurrency_v2</code> to <code>executors_v1</code></li>
<li>Introduced <code>static_query_v</code> enabling static queries</li>
<li>Eliminated unused <code>property_value</code> trait</li>
<li>Eliminated the names <code>allocator_wrapper_t</code> and <code>default_allocator</code></li>
</ul></li>
</ul>
<h3 id="revision-4"><span class="header-section-number">0.1.2</span> Revision 4</h3>
<ul>
<li>Specified the guarantees implied by <code>bulk_sequenced_execution</code>, <code>bulk_parallel_execution</code>, and <code>bulk_unsequenced_execution</code></li>
</ul>
<h3 id="revision-3"><span class="header-section-number">0.1.3</span> Revision 3</h3>
<ul>
<li>Introduced <code>execution::query()</code> for executor property introspection</li>
<li>Simplified the design of <code>execution::prefer()</code></li>
<li><code>oneway</code>, <code>twoway</code>, <code>single</code>, and <code>bulk</code> are now <code>require()</code>-only properties</li>
<li>Introduced properties allowing executors to opt into adaptations that add blocking semantics</li>
<li>Introduced properties describing the forward progress relationship between caller and agents</li>
<li>Various minor improvements to existing functionality based on prototyping</li>
</ul>
<h3 id="revision-2"><span class="header-section-number">0.1.4</span> Revision 2</h3>
<ul>
<li>Separated wording from explanatory prose, now contained in paper <a href="https://wg21.link/P0761">P0761</a></li>
<li>Applied the simplification proposed by paper <a href="https://wg21.link/P0688">P0688</a></li>
</ul>
<h3 id="revision-1"><span class="header-section-number">0.1.5</span> Revision 1</h3>
<ul>
<li>Executor category simplification</li>
<li>Specified executor customization points in detail</li>
<li>Introduced new fine-grained executor type traits
<ul>
<li>Detectors for execution functions</li>
<li>Traits for introspecting cross-cutting concerns
<ul>
<li>Introspection of mapping of agents to threads</li>
<li>Introspection of execution function blocking behavior</li>
</ul></li>
</ul></li>
<li>Allocator support for single agent execution functions</li>
<li>Renamed <code>thread_pool</code> to <code>static_thread_pool</code></li>
<li>New introduction</li>
</ul>
<h3 id="revision-0"><span class="header-section-number">0.1.6</span> Revision 0</h3>
<ul>
<li>Initial design</li>
</ul>
<h1 id="proposed-wording"><span class="header-section-number">1</span> Proposed Wording</h1>
<h3 id="header-execution-synopsis"><span class="header-section-number">1.0.1</span> Header <code>&lt;execution&gt;</code> synopsis</h3>
<pre><code>namespace std {
namespace experimental {
inline namespace executors_v1 {
namespace execution {

  // Customization points:

  namespace {
    constexpr unspecified require = unspecified;
    constexpr unspecified prefer = unspecified;
    constexpr unspecified query = unspecified;
  }

  // Customization point type traits:

  template&lt;class Executor, class... Properties&gt; struct can_require;
  template&lt;class Executor, class... Properties&gt; struct can_prefer;
  template&lt;class Executor, class Property&gt; struct can_query;

  template&lt;class Executor, class... Properties&gt;
    constexpr bool can_require_v = can_require&lt;Executor, Properties...&gt;::value;
  template&lt;class Executor, class... Properties&gt;
    constexpr bool can_prefer_v = can_prefer&lt;Executor, Properties...&gt;::value;
  template&lt;class Executor, class Property&gt;
    constexpr bool can_query_v = can_query&lt;Executor, Property&gt;::value;

  // Associated execution context property:

  struct context_t;

  constexpr context_t context;

  // Directionality properties:

  struct oneway_t;
  struct twoway_t;
  struct then_t;

  constexpr oneway_t oneway;
  constexpr twoway_t twoway;
  constexpr then_t then;

  // Cardinality properties:

  struct single_t;
  struct bulk_t;

  constexpr single_t single;
  constexpr bulk_t bulk;

  // Blocking properties:

  struct possibly_blocking_t;
  struct always_blocking_t;
  struct never_blocking_t;

  constexpr possibly_blocking_t possibly_blocking;
  constexpr always_blocking_t always_blocking;
  constexpr never_blocking_t never_blocking;

  // Properties to allow adaptation of blocking and directionality:

  struct adaptable_blocking_t;
  struct not_adaptable_blocking_t;

  constexpr adaptable_blocking_t adaptable_blocking;
  constexpr not_adaptable_blocking_t not_adaptable_blocking;

  // Properties to indicate if submitted tasks represent continuations:

  struct not_continuation_t;
  struct continuation_t;

  constexpr not_continuation_t not_continuation;
  constexpr continuation_t continuation;

  // Properties to indicate likely task submission in the future:

  struct not_outstanding_work_t;
  struct outstanding_work_t;

  constexpr not_outstanding_work_t not_outstanding_work;
  constexpr outstanding_work_t outstanding_work;

  // Properties for bulk execution guarantees:

  struct bulk_sequenced_execution_t;
  struct bulk_parallel_execution_t;
  struct bulk_unsequenced_execution_t;

  constexpr bulk_sequenced_execution_t bulk_sequenced_execution;
  constexpr bulk_parallel_execution_t bulk_parallel_execution;
  constexpr bulk_unsequenced_execution_t bulk_unsequenced_execution;

  // Properties for mapping of execution on to threads:

  struct other_execution_mapping_t;
  struct thread_execution_mapping_t;
  struct new_thread_execution_mapping_t;

  constexpr other_execution_mapping_t other_execution_mapping;
  constexpr thread_execution_mapping_t thread_execution_mapping;
  constexpr new_thread_execution_mapping_t new_thread_execution_mapping;

  // Memory allocation properties:

  template &lt;typename ProtoAllocator&gt;
  struct allocator_t;

  constexpr allocator_t allocator;

  // Executor type traits:

  template&lt;class Executor&gt; struct is_oneway_executor;
  template&lt;class Executor&gt; struct is_twoway_executor;
  template&lt;class Executor&gt; struct is_then_executor;
  template&lt;class Executor&gt; struct is_bulk_oneway_executor;
  template&lt;class Executor&gt; struct is_bulk_twoway_executor;
  template&lt;class Executor&gt; struct is_bulk_then_executor;

  template&lt;class Executor&gt; constexpr bool is_oneway_executor_v = is_oneway_executor&lt;Executor&gt;::value;
  template&lt;class Executor&gt; constexpr bool is_twoway_executor_v = is_twoway_executor&lt;Executor&gt;::value;
  template&lt;class Executor&gt; constexpr bool is_then_executor_v = is_then_executor&lt;Executor&gt;::value;
  template&lt;class Executor&gt; constexpr bool is_bulk_oneway_executor_v = is_bulk_oneway_executor&lt;Executor&gt;::value;
  template&lt;class Executor&gt; constexpr bool is_bulk_twoway_executor_v = is_bulk_twoway_executor&lt;Executor&gt;::value;
  template&lt;class Executor&gt; constexpr bool is_bulk_then_executor_v = is_bulk_then_executor&lt;Executor&gt;::value;

  template&lt;class Executor, class T&gt; struct executor_future;
  template&lt;class Executor&gt; struct executor_shape;
  template&lt;class Executor&gt; struct executor_index;

  template&lt;class Executor, class T&gt; using executor_future_t = typename executor_future&lt;Executor, T&gt;::type;
  template&lt;class Executor&gt; using executor_shape_t = typename executor_shape&lt;Executor&gt;::type;
  template&lt;class Executor&gt; using executor_index_t = typename executor_index&lt;Executor&gt;::type;

  // Polymorphic executor wrappers:

  class bad_executor;

  template &lt;class... SupportableProperties&gt;
  class executor;
  template&lt;class Property&gt; struct prefer_only;

} // namespace execution
} // inline namespace executors_v1
} // namespace experimental
} // namespace std</code></pre>
<h2 id="requirements"><span class="header-section-number">1.1</span> Requirements</h2>
<h3 id="customization-point-objects"><span class="header-section-number">1.1.1</span> Customization point objects</h3>
<p><em>(The following text has been adapted from the draft Ranges Technical Specification.)</em></p>
<p>A <em>customization point object</em> is a function object (C++ Std, [function.objects]) with a literal class type that interacts with user-defined types while enforcing semantic requirements on that interaction.</p>
<p>The type of a customization point object shall satisfy the requirements of <code>CopyConstructible</code> (C++Std [copyconstructible]) and <code>Destructible</code> (C++Std [destructible]).</p>
<p>All instances of a specific customization point object type shall be equal.</p>
<p>Let <code>t</code> be a (possibly const) customization point object of type <code>T</code>, and <code>args...</code> be a parameter pack expansion of some parameter pack <code>Args...</code>. The customization point object <code>t</code> shall be callable as <code>t(args...)</code> when the types of <code>Args...</code> meet the requirements specified in that customization point object's definition. Otherwise, <code>T</code> shall not have a function call operator that participates in overload resolution.</p>
<p>Each customization point object type constrains its return type to satisfy some particular type requirements.</p>
<p>The library defines several named customization point objects. In every translation unit where such a name is defined, it shall refer to the same instance of the customization point object.</p>
<p>[<em>Note:</em> Many of the customization points objects in the library evaluate function call expressions with an unqualified name which results in a call to a user-defined function found by argument dependent name lookup (C++Std [basic.lookup.argdep]). To preclude such an expression resulting in a call to unconstrained functions with the same name in namespace <code>std</code>, customization point objects specify that lookup for these expressions is performed in a context that includes deleted overloads matching the signatures of overloads defined in namespace <code>std</code>. When the deleted overloads are viable, user-defined overloads must be more specialized (C++Std [temp.func.order]) to be used by a customization point object. <em>--end note</em>]</p>
<h3 id="future-requirements"><span class="header-section-number">1.1.2</span> <code>Future</code> requirements</h3>
<p>A type <code>F</code> meets the <code>Future</code> requirements for some value type <code>T</code> if <code>F</code> is <code>std::experimental::future&lt;T&gt;</code> (defined in the C++ Concurrency TS, ISO/IEC TS 19571:2016). [<em>Note:</em> This concept is included as a placeholder to be elaborated, with the expectation that the elaborated requirements for <code>Future</code> will expand the applicability of some executor customization points. <em>--end note</em>]</p>
<p>Forward progress guarantees are a property of the concrete <code>Future</code> type. [<em>Note:</em> <code>std::experimental::future&lt;T&gt;::wait()</code> blocks with forward progress guarantee delegation until the shared state is ready. <em>--end note</em>]</p>
<h3 id="protoallocator-requirements"><span class="header-section-number">1.1.3</span> <code>ProtoAllocator</code> requirements</h3>
<p>A type <code>A</code> meets the <code>ProtoAllocator</code> requirements if <code>A</code> is <code>CopyConstructible</code> (C++Std [copyconstructible]), <code>Destructible</code> (C++Std [destructible]), and <code>allocator_traits&lt;A&gt;::rebind_alloc&lt;U&gt;</code> meets the allocator requirements (C++Std [allocator.requirements]), where <code>U</code> is an object type. [<em>Note:</em> For example, <code>std::allocator&lt;void&gt;</code> meets the proto-allocator requirements but not the allocator requirements. <em>--end note</em>] No comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception.</p>
<h3 id="general-requirements-on-executors"><span class="header-section-number">1.1.4</span> General requirements on executors</h3>
<p>An executor type shall satisfy the requirements of <code>CopyConstructible</code> (C++Std [copyconstructible]), <code>Destructible</code> (C++Std [destructible]), and <code>EqualityComparable</code> (C++Std [equalitycomparable]).</p>
<p>None of these concepts' operations, nor an executor type's swap operations, shall exit via an exception.</p>
<p>None of these concepts' operations, nor an executor type's associated execution functions, associated query functions, or other member functions defined in executor type requirements, shall introduce data races as a result of concurrent calls to those functions from different threads.</p>
<p>For any two (possibly const) values <code>x1</code> and <code>x2</code> of some executor type <code>X</code>, <code>x1 == x2</code> shall return <code>true</code> only if <code>x1.query(p) == x2.query(p)</code> for every property <code>p</code> where both <code>x1.query(p)</code> and <code>x2.query(p)</code> are well-formed and result in a non-void type that is <code>EqualityComparable</code> (C++Std [equalitycomparable]). [<em>Note:</em> The above requirements imply that <code>x1 == x2</code> returns <code>true</code> if <code>x1</code> and <code>x2</code> can be interchanged with identical effects. An executor may conceptually contain additional properties which are not exposed by a named property type that can be observed via <code>execution::query</code>; in this case, it is up to the concrete executor implementation to decide if these properties affect equality. Returning <code>false</code> does not necessarily imply that the effects are not identical. <em>--end note</em>]</p>
<p>An executor type's destructor shall not block pending completion of the submitted function objects. [<em>Note:</em> The ability to wait for completion of submitted function objects may be provided by the associated execution context. <em>--end note</em>]</p>
<h3 id="onewayexecutor-requirements"><span class="header-section-number">1.1.5</span> <code>OneWayExecutor</code> requirements</h3>
<p>The <code>OneWayExecutor</code> requirements specify requirements for executors which create execution agents. A type <code>X</code> satisfies the <code>OneWayExecutor</code> requirements if it satisfies the general requirements on executors, as well as the requirements in the table below.</p>
<p>[<em>Note:</em> <code>OneWayExecutor</code>s provides fire-and-forget semantics without a channel for awaiting the completion of a submitted function object and obtaining its result. <em>--end note</em>]</p>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code> and <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.execute(f)</code></td>
<td align="left"><code>void</code></td>
<td align="left">Creates an execution agent which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> at most once, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>execute</code>. <br/> <br/> May block pending completion of <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code>. <br/> <br/> The invocation of <code>execute</code> synchronizes with (C++Std [intro.multithread]) the invocation of <code>f</code>. <br/> <br/> <code>execute</code> shall not propagate any exception thrown by <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> or any other function submitted to the executor. [<em>Note:</em> The treatment of exceptions thrown by one-way submitted functions and the forward progress guarantee of execution agents created by one-way execution functions are specific to the concrete executor type. <em>--end note.</em>]</td>
</tr>
</tbody>
</table>
<h3 id="twowayexecutor-requirements"><span class="header-section-number">1.1.6</span> <code>TwoWayExecutor</code> requirements</h3>
<p>The <code>TwoWayExecutor</code> requirements specify requirements for executors which create execution agents with a channel for awaiting the completion of a submitted function object and obtaining its result.</p>
<p>A type <code>X</code> satisfies the <code>TwoWayExecutor</code> requirements if it satisfies the general requirements on executors, as well as the requirements in the table below.</p>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements, and <code>R</code> denotes the type of the expression <code>DECAY_COPY(std::forward&lt;F&gt;(f))()</code>.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.twoway_execute(f)</code></td>
<td align="left">A type that satisfies the <code>Future</code> requirements for the value type <code>R</code>.</td>
<td align="left">Creates an execution agent which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code> at most once, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>twoway_execute</code>. <br/> <br/> May block pending completion of <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code>. <br/> <br/> The invocation of <code>twoway_execute</code> synchronizes with (C++Std [intro.multithread]) the invocation of <code>f</code>. <br/> <br/> Stores the result of <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code>, or any exception thrown by <code>DECAY_COPY( std::forward&lt;F&gt;(f))()</code>, in the associated shared state of the resulting <code>Future</code>.</td>
</tr>
</tbody>
</table>
<h3 id="thenexecutor-requirements"><span class="header-section-number">1.1.7</span> <code>ThenExecutor</code> requirements</h3>
<p>The <code>ThenExecutor</code> requirements specify requirements for executors which create execution agents whose initiation is predicated on the readiness of a specified future, and which provide a channel for awaiting the completion of the submitted function object and obtaining its result.</p>
<p>A type <code>X</code> satisfies the <code>ThenExecutor</code> requirements if it satisfies the general requirements on executors, as well as the requirements in the table below.</p>
<p>In the Table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, <code>fut</code> denotes a future object satisfying the Future requirements, <code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))(fut)</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements, and <code>R</code> denotes the type of the expression <code>DECAY_COPY(std::forward&lt;F&gt;(f))(fut)</code>.</p>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.then_execute(f, fut)</code></td>
<td align="left">A type that satisfies the <code>Future</code> requirements for the value type <code>R</code>.</td>
<td align="left">When <code>fut</code> is ready, creates an execution agent which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(fut)</code> at most once, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>then_execute</code>. <br/> <br/> May block pending completion of <code>DECAY_COPY( std::forward&lt;F&gt;(f))(fut)</code>. <br/> <br/> The invocation of <code>then_execute</code> synchronizes with (C++Std [intro.multithread]) the invocation of <code>f</code>. <br/> <br/> Stores the result of <code>DECAY_COPY( std::forward&lt;F&gt;(f))(fut)</code>, or any exception thrown by <code>DECAY_COPY( std::forward&lt;F&gt;(f))(fut)</code>, in the associated shared state of the resulting <code>Future</code>.</td>
</tr>
</tbody>
</table>
<h3 id="bulkonewayexecutor-requirements"><span class="header-section-number">1.1.8</span> <code>BulkOneWayExecutor</code> requirements</h3>
<p>The <code>BulkOneWayExecutor</code> requirements specify requirements for executors which create groups of execution agents in bulk from a single execution function, without a channel for awaiting the completion of the submitted function object invocations and obtaining their result. [<em>Note:</em> That is, the executor provides fire-and-forget semantics. <em>--end note</em>]</p>
<p>A type <code>X</code> satisfies the <code>BulkOneWayExecutor</code> requirements if it satisfies the general requirements on executors, as well as the requirements in the table below.</p>
<p>In the Table below,</p>
<ul>
<li><code>x</code> denotes a (possibly const) executor object of type <code>X</code>,</li>
<li><code>n</code> denotes a shape object whose type is <code>executor_shape_t&lt;X&gt;</code>,</li>
<li><code>sf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>S</code>,</li>
<li><code>i</code> denotes a (possibly const) object whose type is <code>executor_index_t&lt;X&gt;</code>,</li>
<li><code>s</code> denotes an object whose type is <code>S</code>,</li>
<li><code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))(i, s)</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</li>
</ul>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.bulk_execute(f, n, sf)</code></td>
<td align="left"><code>void</code></td>
<td align="left">Invokes <code>sf()</code> on an unspecified execution agent to produce the value <code>s</code>. Creates a group of execution agents of shape <code>n</code> which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, s)</code> at most once for each value of <code>i</code> in the range <code>[0,n)</code>, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>bulk_execute</code>. <br/> <br/> May block pending completion of one or more calls to <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, s)</code>. <br/> <br/> The invocation of <code>bulk_execute</code> synchronizes with (C++Std [intro.multithread]) the invocations of <code>f</code>. <br/> <br/> <code>bulk_execute</code> shall not propagate any exception thrown by <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, s)</code> or any other function submitted to the executor. [<em>Note:</em> The treatment of exceptions thrown by bulk one-way submitted functions and the forward progress guarantee of execution agents created by one-way execution functions is specific to the concrete executor type. <em>--end note.</em>]</td>
</tr>
</tbody>
</table>
<h3 id="bulktwowayexecutor-requirements"><span class="header-section-number">1.1.9</span> <code>BulkTwoWayExecutor</code> requirements</h3>
<p>The <code>BulkTwoWayExecutor</code> requirements specify requirements for executors which create groups of execution agents in bulk from a single execution function with a channel for awaiting the completion of a submitted function object invoked by those execution agents and obtaining its result.</p>
<p>A type <code>X</code> satisfies the <code>BulkTwoWayExecutor</code> requirements if it satisfies the general requirements on executors, as well as the requirements in the table below.</p>
<p>In the Table below,</p>
<ul>
<li><code>x</code> denotes a (possibly const) executor object of type <code>X</code>,</li>
<li><code>n</code> denotes a shape object whose type is <code>executor_shape_t&lt;X&gt;</code>,</li>
<li><code>rf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>R</code>,</li>
<li><code>sf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>S</code>,</li>
<li><code>i</code> denotes a (possibly const) object whose type is <code>executor_index_t&lt;X&gt;</code>,</li>
<li><code>s</code> denotes an object whose type is <code>S</code>,</li>
<li>if <code>R</code> is non-void,
<ul>
<li><code>r</code> denotes an object whose type is <code>R</code>,</li>
<li><code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))(i, r, s)</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</li>
</ul></li>
<li>if <code>R</code> is void,
<ul>
<li><code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))(i, s)</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</li>
</ul></li>
</ul>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.bulk_twoway_execute(f, n, rf, sf)</code></td>
<td align="left">A type that satisfies the <code>Future</code> requirements for the value type <code>R</code>.</td>
<td align="left">If <code>R</code> is non-void, invokes <code>rf()</code> on an unspecified execution agent to produce the value <code>r</code>. Invokes <code>sf()</code> on an unspecified execution agent to produce the value <code>s</code>. Creates a group of execution agents of shape <code>n</code> which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, r, s)</code> if <code>R</code> is non-void, and otherwise invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, s)</code>, at most once for each value of <code>i</code> in the range <code>[0,n)</code>, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>bulk_twoway_execute</code>. <br/> <br/> May block pending completion of one or more invocations of <code>f</code>. <br/> <br/> The invocation of <code>bulk_twoway_execute</code> synchronizes with (C++Std [intro.multithread]) the invocations of <code>f</code>. <br/> <br/> Once all invocations of <code>f</code> finish execution, stores <code>r</code>, or any exception thrown by an invocation of <code>f</code>, in the associated shared state of the resulting <code>Future</code>.</td>
</tr>
</tbody>
</table>
<h3 id="bulkthenexecutor-requirements"><span class="header-section-number">1.1.10</span> <code>BulkThenExecutor</code> requirements</h3>
<p>The <code>BulkThenExecutor</code> requirements specify requirements for executors which create execution agents whose initiation is predicated on the readiness of a specified future, and which provide a channel for awaiting the completion of the submitted function object and obtaining its result.</p>
<p>A type <code>X</code> satisfies the <code>BulkThenExecutor</code> requirements if it satisfies the general requirements on executors, as well as the requirements in the table below.</p>
<p>In the Table below,</p>
<ul>
<li><code>x</code> denotes a (possibly const) executor object of type <code>X</code>,</li>
<li><code>n</code> denotes a shape object whose type is <code>executor_shape_t&lt;X&gt;</code>,</li>
<li><code>fut</code> denotes a future object satisfying the Future requirements,</li>
<li><code>rf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>R</code>,</li>
<li><code>sf</code> denotes a <code>CopyConstructible</code> function object with zero arguments whose result type is <code>S</code>,</li>
<li><code>i</code> denotes a (possibly const) object whose type is <code>executor_index_t&lt;X&gt;</code>,</li>
<li><code>s</code> denotes an object whose type is <code>S</code>,</li>
<li>if <code>R</code> is non-void,
<ul>
<li><code>r</code> denotes an object whose type is <code>R</code>,</li>
<li><code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))(i, fut, r, s)</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</li>
</ul></li>
<li>if <code>R</code> is void,
<ul>
<li><code>f</code> denotes a function object of type <code>F&amp;&amp;</code> callable as <code>DECAY_COPY(std::forward&lt;F&gt;(f))(i, fut, s)</code> and where <code>decay_t&lt;F&gt;</code> satisfies the <code>MoveConstructible</code> requirements.</li>
</ul></li>
</ul>
<table style="width:69%;">
<colgroup>
<col width="18%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Return Type</th>
<th align="left">Operational semantics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.bulk_then_execute(f, n, fut, rf, sf)</code></td>
<td align="left">A type that satisfies the <code>Future</code> requirements for the value type <code>R</code>.</td>
<td align="left">If <code>R</code> is non-void, invokes <code>rf()</code> on an unspecified execution agent to produce the value <code>r</code>. Invokes <code>sf()</code> on an unspecified execution agent to produce the value <code>s</code>. When <code>fut</code> is ready, creates a group of execution agents of shape <code>n</code> which invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, fut, r, s)</code> if <code>R</code> is non-void, and otherwise invokes <code>DECAY_COPY( std::forward&lt;F&gt;(f))(i, fut, s)</code>, at most once for each value of <code>i</code> in the range <code>[0,n)</code>, with the call to <code>DECAY_COPY</code> being evaluated in the thread that called <code>bulk_then_execute</code>. <br/> <br/> May block pending completion of one or more invocations of <code>f</code>. <br/> <br/> The invocation of <code>bulk_then_execute</code> synchronizes with (C++Std [intro.multithread]) the invocations of <code>f</code>. <br/> <br/> Once all invocations of <code>f</code> finish execution, stores <code>r</code>, or any exception thrown by an invocation of <code>f</code>, in the associated shared state of the resulting <code>Future</code>.</td>
</tr>
</tbody>
</table>
<h2 id="executor-customization-points"><span class="header-section-number">1.2</span> Executor customization points</h2>
<p><em>Executor customization points</em> are functions which adapt an executor's properties. Executor customization points enable uniform use of executors in generic contexts.</p>
<p>When an executor customization point named <em>NAME</em> invokes a free execution function of the same name, overload resolution is performed in a context that includes the declaration <code>void</code> <em>NAME</em><code>(auto&amp;... args) = delete;</code>, where <code>sizeof...(args)</code> is the arity of the free execution function. This context also does not include a declaration of the executor customization point.</p>
<p>[<em>Note:</em> This provision allows executor customization points to call the executor's free, non-member execution function of the same name without recursion. <em>--end note</em>]</p>
<p>Whenever <code>std::experimental::executors_v1::execution::</code><em>NAME</em><code>(</code><em>ARGS</em><code>)</code> is a valid expression, that expression satisfies the syntactic requirements for the free execution function named <em>NAME</em> with arity <code>sizeof...(</code><em>ARGS</em><code>)</code> with that free execution function's semantics.</p>
<h3 id="require"><span class="header-section-number">1.2.1</span> <code>require</code></h3>
<pre><code>namespace {
  constexpr unspecified require = unspecified;
}</code></pre>
<p>The name <code>require</code> denotes a customization point. The effect of the expression <code>std::experimental::executors_v1::execution::require(E, P0, Pn...)</code> for some expressions <code>E</code> and <code>P0</code>, and where <code>Pn...</code> represents <code>N</code> expressions (where <code>N</code> is 0 or more), is equivalent to:</p>
<ul>
<li><p>If <code>N == 0</code>, <code>P0::is_requirable</code> is true, and the expression <code>decay_t&lt;decltype(P0)&gt;::template static_query_v&lt;decay_t&lt;decltype(E)&gt;&gt; == decay_t&lt;decltype(P0)&gt;::value()</code> is a well-formed constant expression with value <code>true</code>, <code>E</code>.</p></li>
<li><p>If <code>N == 0</code>, <code>P0::is_requirable</code> is true, and the expression <code>(E).require(P0)</code> is well-formed, <code>(E).require(P0)</code>.</p></li>
<li><p>If <code>N == 0</code>, <code>P0::is_requirable</code> is true, and the expression <code>require(E, P0)</code> is well-formed, <code>require(E, P0)</code>.</p></li>
<li><p>If <code>N &gt; 0</code> and the expression <code>std::experimental::executors_v1::execution::require( std::experimental::executors_v1::execution::require(E, P0), Pn...)</code> is well formed, <code>std::experimental::executors_v1::execution::require( std::experimental::executors_v1::execution::require(E, P0), Pn...)</code>.</p></li>
<li><p>Otherwise, <code>std::experimental::executors_v1::execution::require(E, P0, Pn...)</code> is ill-formed.</p></li>
</ul>
<h3 id="prefer"><span class="header-section-number">1.2.2</span> <code>prefer</code></h3>
<pre><code>namespace {
  constexpr unspecified prefer = unspecified;
}</code></pre>
<p>The name <code>prefer</code> denotes a customization point. The effect of the expression <code>std::experimental::executors_v1::execution::prefer(E, P0, Pn...)</code> for some expressions <code>E</code> and <code>P0</code>, and where <code>Pn...</code> represents <code>N</code> expressions (where <code>N</code> is 0 or more), is equivalent to:</p>
<ul>
<li><p>If <code>N == 0</code>, <code>P0::is_preferable</code> is true, and the expression <code>decay_t&lt;decltype(P0)&gt;::template static_query_v&lt;decay_t&lt;decltype(E)&gt;&gt; == decay_t&lt;decltype(P0)&gt;::value()</code> is a well-formed constant expression with value <code>true</code>, <code>E</code>.</p></li>
<li><p>If <code>N == 0</code>, <code>P0::is_preferable</code> is true, and the expression <code>(E).require(P0)</code> is well-formed, <code>(E).require(P0)</code>.</p></li>
<li><p>If <code>N == 0</code>, <code>P0::is_preferable</code> is true, and the expression <code>prefer(E, P0)</code> is well-formed, <code>prefer(E, P0)</code>.</p></li>
<li><p>If <code>N == 0</code> and <code>P0::is_preferable</code> is true, <code>E</code>.</p></li>
<li><p>If <code>N &gt; 0</code> and the expression <code>std::experimental::executors_v1::execution::prefer( std::experimental::executors_v1::execution::prefer(E, P0), Pn...)</code> is well formed, <code>std::experimental::executors_v1::execution::prefer( std::experimental::executors_v1::execution::prefer(E, P0), Pn...)</code>.</p></li>
<li><p>Otherwise, <code>std::experimental::executors_v1::execution::require(E, P0, Pn...)</code> is ill-formed.</p></li>
</ul>
<h3 id="query"><span class="header-section-number">1.2.3</span> <code>query</code></h3>
<pre><code>namespace {
  constexpr unspecified query = unspecified;
}</code></pre>
<p>The name <code>query</code> denotes a customization point. The effect of the expression <code>std::experimental::executors_v1::execution::query(E, P)</code> for some expressions <code>E</code> and <code>P</code> is equivalent to:</p>
<ul>
<li><p>If the expression <code>decay_t&lt;decltype(P0)&gt;::template static_query_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code> is a well-formed constant expression, <code>decay_t&lt;decltype(P0)&gt;::template static_query_v&lt;decay_t&lt;decltype(E)&gt;&gt;</code>.</p></li>
<li><p>If the expression <code>(E).query(P0)</code> is well-formed, <code>(E).query(P0)</code>.</p></li>
<li><p>If the expression <code>query(E, P0)</code> is well-formed, <code>query(E, P0)</code>.</p></li>
<li><p>Otherwise, <code>std::experimental::executors_v1::execution::query(E, P)</code> is ill-formed.</p></li>
</ul>
<h3 id="customization-point-type-traits"><span class="header-section-number">1.2.4</span> Customization point type traits</h3>
<pre><code>template&lt;class Executor, class... Properties&gt; struct can_require;
template&lt;class Executor, class... Properties&gt; struct can_prefer;
template&lt;class Executor, class Property&gt; struct can_query;</code></pre>
<p>This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of <code>true_type</code> if the corresponding condition is true, otherwise <code>false_type</code>.</p>
<table style="width:94%;">
<colgroup>
<col width="40%" />
<col width="30%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Template</th>
<th align="left">Condition</th>
<th align="left">Preconditions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_require</code></td>
<td align="left">The expression <code>std::experimental::executors_v1::execution::require( declval&lt;const Executor&gt;(), declval&lt;Properties&gt;()...)</code> is well formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_prefer</code></td>
<td align="left">The expression <code>std::experimental::executors_v1::execution::prefer( declval&lt;const Executor&gt;(), declval&lt;Properties&gt;()...)</code> is well formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct can_query</code></td>
<td align="left">The expression <code>std::experimental::executors_v1::execution::query( declval&lt;const Executor&gt;(), declval&lt;Property&gt;())</code> is well formed.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
</tbody>
</table>
<h2 id="executor-properties"><span class="header-section-number">1.3</span> Executor properties</h2>
<h3 id="in-general"><span class="header-section-number">1.3.1</span> In general</h3>
<p>An executor's behavior in generic contexts is determined by a set of executor properties, and each executor property imposes certain requirements on the executor.</p>
<p>Given an existing executor, a related executor with different properties may be created by calling the <code>require</code> member or non-member functions. These functions behave according the table below. In the table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, and <code>p</code> denotes a (possibly const) property object.</p>
<p>[<em>Note:</em> As a general design note properties which define a mutually exclusive pair, that describe an enabled or non-enabled behaviour follow the convention of having the same property name for both with the <code>not_</code> prefix to the property for the non-enabled behaviour. <em>--end note</em>]</p>
<table style="width:33%;">
<colgroup>
<col width="18%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.require(p)</code> <br/> <code>require(x,p)</code></td>
<td align="left">Returns an executor object with the requested property <code>p</code> added to the set. All other properties of the returned executor are identical to those of <code>x</code>, except where those properties are described below as being mutually exclusive to <code>p</code>. In this case, the mutually exclusive properties are implicitly removed from the set associated with the returned executor. <br/> <br/> The expression is ill formed if an executor is unable to add the requested property.</td>
</tr>
</tbody>
</table>
<p>The current value of an executor's properties can be queried by calling the <code>query</code> function. This function behaves according the table below. In the table below, <code>x</code> denotes a (possibly const) executor object of type <code>X</code>, and <code>p</code> denotes a (possibly const) property object.</p>
<table style="width:33%;">
<colgroup>
<col width="18%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Expression</th>
<th align="left">Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x.query(p)</code></td>
<td align="left">Returns the current value of the requested property <code>p</code>. The expression is ill formed if an executor is unable to return the requested property.</td>
</tr>
</tbody>
</table>
<h3 id="requirements-on-properties"><span class="header-section-number">1.3.2</span> Requirements on properties</h3>
<p>A property type <code>P</code> shall provide:</p>
<ul>
<li>A nested constant expression named <code>is_requirable</code> of type <code>bool</code>, usable as <code>P::is_requirable</code>.</li>
<li>A nested constant expression named <code>is_preferable</code> of type <code>bool</code>, usable as <code>P::is_preferable</code>.</li>
</ul>
<p>[<em>Note:</em> These constants are used to determine whether the property can be used with the <code>require</code> and <code>prefer</code> customization points, respectively. <em>--end note</em>]</p>
<p>A property type <code>P</code> may provide a nested type <code>polymorphic_query_result_type</code>. [<em>Note:</em> When present, this type allows the property to be used with the polymorphic <code>executor</code> wrapper. <em>--end note</em>]</p>
<p>A property type <code>P</code> may provide:</p>
<ul>
<li>A nested variable template <code>static_query_v</code>, usable as <code>P::static_query_v&lt;Executor&gt;</code>. This may be conditionally present.</li>
<li>A member function <code>value()</code>.</li>
</ul>
<p>If both <code>static_query_v</code> and <code>value()</code> are present, they shall return the same type and this type shall satisfy the <code>EqualityComparable</code> requirements.</p>
<p>[<em>Note:</em> These are used to determine whether a <code>require</code> call would result in an identity transformation. <em>--end note</em>]</p>
<h3 id="query-only-properties"><span class="header-section-number">1.3.3</span> Query-only properties</h3>
<h4 id="associated-execution-context-property"><span class="header-section-number">1.3.3.1</span> Associated execution context property</h4>
<pre><code>struct context_t
{
  static constexpr bool is_requirable = false;
  static constexpr bool is_preferable = false;

  using polymorphic_query_result_type = any; // TODO: alternatively consider void*, or simply omitting the type.

  template&lt;class Executor&gt;
    static constexpr bool static_query_v
      = Executor::query(context_t());
};</code></pre>
<p>The <code>context_t</code> property can be used only with <code>query</code>, which returns the <strong>execution context</strong> associated with the executor.</p>
<p>An execution context is a program object that represents a specific collection of execution resources and the <strong>execution agents</strong> that exist within those resources. Execution agents are units of execution, and a 1-to-1 mapping exists between an execution agent and an invocation of a callable function object submitted via the executor.</p>
<p>The value returned from <code>execution::query(e, context_t)</code>, where <code>e</code> is an executor, shall not change between calls.</p>
<h3 id="interface-changing-properties"><span class="header-section-number">1.3.4</span> Interface-changing properties</h3>
<h4 id="directionality-properties"><span class="header-section-number">1.3.4.1</span> Directionality properties</h4>
<pre><code>struct oneway_t;
struct twoway_t;
struct then_t;</code></pre>
<p>The directionality properties conform to the following specification:</p>
<pre><code>struct S
{
  static constexpr bool is_requirable = true;
  static constexpr bool is_preferable = false;

  using polymorphic_query_result_type = bool;

  template&lt;class Executor&gt;
    static constexpr bool static_query_v
      = see-below;

  static constexpr bool value() const { return true; }
};</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>oneway_t</code></td>
<td align="left">The executor type satisfies the <code>OneWayExecutor</code> or <code>BulkOneWayExecutor</code> requirements.</td>
</tr>
<tr class="even">
<td align="left"><code>twoway_t</code></td>
<td align="left">The executor type satisfies the <code>TwoWayExecutor</code> or <code>BulkTwoWayExecutor</code> requirements.</td>
</tr>
<tr class="odd">
<td align="left"><code>then_t</code></td>
<td align="left">The executor type satisfies the <code>ThenExecutor</code> or <code>BulkThenExecutor</code> requirements.</td>
</tr>
</tbody>
</table>
<p><code>S::static_query_v&lt;Executor&gt;</code> is true if and only if <code>Executor</code> fulfills <code>S</code>'s requirements.</p>
<p>The <code>oneway_t</code>, <code>twoway_t</code> and <code>then_t</code> properties are not mutually exclusive.</p>
<h5 id="twoway_t-customization-points"><span class="header-section-number">1.3.4.1.1</span> <code>twoway_t</code> customization points</h5>
<p>In addition to conforming to the above specification, the <code>twoway_t</code> property provides the following customization:</p>
<pre><code>struct twoway_t
{
  template&lt;class Executor&gt;
    friend see-below require(Executor ex, twoway_t);
};</code></pre>
<p>If the executor has the <code>oneway_t</code> and <code>adaptable_blocking_t</code> properties, this customization returns an adapter that implements the twoway property and its requirements.</p>
<p><em>Returns:</em> A value <code>e1</code> of type <code>E1</code> that holds a copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>OneWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>OneWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>, if present, and <code>E1</code> shall satisfy the <code>TwoWayExecutor</code> requirements by implementing <code>twoway_execute</code> in terms of <code>execute</code>. Similarly, if <code>Executor</code> satisfies the <code>BulkOneWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>BulkOneWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>bulk_execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>, if present, and <code>E1</code> shall satisfy the <code>BulkTwoWayExecutor</code> requirements by implementing <code>bulk_twoway_execute</code> in terms of <code>bulk_execute</code>. For some type <code>T</code>, the type yielded by <code>executor_future_t&lt;E1, T&gt;</code> is <code>std::experimental::future&lt;T&gt;</code>. <code>e1</code> has the same executor properties as <code>ex</code>, except for the addition of the <code>twoway_t</code> property.</p>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless <code>is_twoway_executor_v&lt;Executor&gt; ||</code> <code>is_bulk_twoway_executor_v&lt;Executor&gt;</code> is false, <code>is_oneway_executor_v&lt;Executor&gt;</code> <code>||</code> <code>is_bulk_oneway_executor_v&lt;Executor&gt;</code> is true, and <code>adaptable_blocking_t::static_query_v&lt;Executor&gt;</code> is a constant expression with value <code>true</code>.</p>
<h4 id="cardinality-properties"><span class="header-section-number">1.3.4.2</span> Cardinality properties</h4>
<pre><code>struct single_t;
struct bulk_t;</code></pre>
<p>The cardinality properties conform to the following specification:</p>
<pre><code>struct S
{
  static constexpr bool is_requirable = true;
  static constexpr bool is_preferable = false;

  using polymorphic_query_result_type = bool;

  template&lt;class Executor&gt;
    static constexpr bool static_query_v
      = see-below;

  static constexpr bool value() const { return true; }
};</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>single_t</code></td>
<td align="left">The executor type satisfies the <code>OneWayExecutor</code>, <code>TwoWayExecutor</code>, or <code>ThenExecutor</code> requirements.</td>
</tr>
<tr class="even">
<td align="left"><code>bulk_t</code></td>
<td align="left">The executor type satisfies the <code>BulkOneWayExecutor</code>, <code>BulkTwoWayExecutor</code>, or <code>BulkThenExecutor</code> requirements.</td>
</tr>
</tbody>
</table>
<p><code>S::static_query_v&lt;Executor&gt;</code> is true if and only if <code>Executor</code> fulfills <code>S</code>'s requirements.</p>
<p>The <code>single_t</code> and <code>bulk_t</code> properties are not mutually exclusive.</p>
<h5 id="bulk_t-customization-points"><span class="header-section-number">1.3.4.2.1</span> <code>bulk_t</code> customization points</h5>
<p>In addition to conforming to the above specification, the <code>bulk_t</code> property provides the following customization:</p>
<pre><code>struct bulk_t
{
  template&lt;class Executor&gt;
    friend see-below require(Executor ex, bulk_t);
};</code></pre>
<p>If the executor has the <code>oneway_t</code> property, this customization returns an adapter that implements the bulk property and its requirements.</p>
<pre><code>template&lt;class Executor&gt;
  friend see-below require(Executor ex, bulk_t);</code></pre>
<p><em>Returns:</em> A value <code>e1</code> of type <code>E1</code> that holds a copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>OneWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>OneWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>, if present, and <code>E1</code> shall satisfy the <code>BulkExecutor</code> requirements by implementing <code>bulk_execute</code> in terms of <code>execute</code>. If <code>Executor</code> also satisfies the <code>TwoWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>TwoWayExecutor</code> requirements by providing the member function <code>twoway_execute</code> that forwards to the corresponding member function of the copy of <code>ex</code>, if present, and <code>E1</code> shall satisfy the <code>BulkTwoWayExecutor</code> requirements by implementing <code>bulk_twoway_execute</code> in terms of <code>bulk_execute</code>. <code>e1</code> has the same executor properties as <code>ex</code>, except for the addition of the <code>bulk_t</code> property.</p>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless <code>is_bulk_oneway_executor_v&lt;Executor&gt; ||</code> <code>is_bulk_twoway_executor_v&lt;Executor&gt;</code> is false, and <code>is_oneway_executor_v&lt;Executor&gt;</code> is true.</p>
<h3 id="behavioral-properties"><span class="header-section-number">1.3.5</span> Behavioral properties</h3>
<p>Behavioral properties conform to the following specification:</p>
<pre><code>struct S
{
  static constexpr bool is_requirable = true;
  static constexpr bool is_preferable = true;

  using polymorphic_query_result_type = bool;

  template&lt;class Executor&gt;
    static constexpr bool static_query_v
      = Executor::query(S());

  static constexpr bool value() const { return true; }
};</code></pre>
<p>The result of the <code>query</code> customization point for a behavioral property is <code>true</code> if the property is present in the executor, and <code>false</code> if it is not.</p>
<h4 id="blocking-properties"><span class="header-section-number">1.3.5.1</span> Blocking properties</h4>
<pre><code>struct possibly_blocking_t;
struct always_blocking_t;
struct never_blocking_t;</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>possibly_blocking_t</code></td>
<td align="left">A call to an executor's execution function may block pending completion of one or more of the execution agents created by that execution function.</td>
</tr>
<tr class="even">
<td align="left"><code>always_blocking_t</code></td>
<td align="left">A call to an executor's execution function shall block until completion of all execution agents created by that execution function.</td>
</tr>
<tr class="odd">
<td align="left"><code>never_blocking_t</code></td>
<td align="left">A call to an executor's execution function shall not block pending completion of the execution agents created by that execution function.</td>
</tr>
</tbody>
</table>
<p>The <code>possibly_blocking_t</code>, <code>always_blocking_t</code> and <code>never_blocking_t</code> properties are mutually exclusive.</p>
<p>[<em>Note:</em> The guarantees of <code>possibly_blocking_t</code>, <code>always_blocking_t</code> and <code>never_blocking_t</code> implies the relationships: <code>possibly_blocking &lt; always_blocking</code> and <code>possibly_blocking &lt; never_blocking</code> <em>--end note</em>]</p>
<p>The value returned from <code>execution::query(e, p)</code> shall not change between calls unless <code>e</code> is assigned another executor which has a different value for <code>p</code>. The value returned from <code>execution::query(e, p1)</code> and a subsequent call <code>execution::query(e1, p1)</code> where: * <code>p1</code> is <code>execution::possibly_blocking</code>, <code>execution::always_blocking</code> or <code>execution::never_blocking</code>, and * <code>e1</code> is the result of <code>execution::require(e, p2)</code> or <code>execution::prefer(e, p2)</code>, shall compare equal unless: * <code>p2</code> is <code>execution::possibly_blocking</code>, <code>execution::always_blocking</code> or <code>execution::never_blocking</code>, and * <code>p1</code> and <code>p2</code> are different types.</p>
<h5 id="possibly_blocking_t-customization-points"><span class="header-section-number">1.3.5.1.1</span> <code>possibly_blocking_t</code> customization points</h5>
<p>In addition to conforming to the above specification, the <code>possibly_blocking_t</code> property provides the following customization:</p>
<pre><code>struct possibly_blocking_t
{
  template&lt;class Executor&gt;
    friend constexpr bool query(const Executor&amp; ex, possibly_blocking_t);
};</code></pre>
<p>This customization automatically enables the <code>possibly_blocking_t</code> property for all executors that do not otherwise support the <code>always_blocking_t</code> or <code>never_blocking_t</code> properties. [<em>Note:</em> That is, all executors are treated as possibly blocking unless otherwise specified. <em>--end note</em>]</p>
<pre><code>template&lt;class Executor&gt;
  friend constexpr bool query(const Executor&amp; ex, possibly_blocking_t);</code></pre>
<p><em>Returns:</em> <code>true</code>.</p>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless <code>can_query_v&lt;Executor, always_blocking_t&gt; || can_query_v&lt;Executor, never_blocking_t&gt;</code> is <code>false</code>.</p>
<h5 id="always_blocking_t-customization-points"><span class="header-section-number">1.3.5.1.2</span> <code>always_blocking_t</code> customization points</h5>
<p>In addition to conforming to the above specification, the <code>always_blocking_t</code> property provides the following customization:</p>
<pre><code>struct always_blocking_t
{
  template&lt;class Executor&gt;
    friend see-below require(Executor ex, always_blocking_t);
};</code></pre>
<p>If the executor has the <code>adaptable_blocking_t</code> property, this customization uses an adapter to implement the <code>always_blocking_t</code> property.</p>
<pre><code>template&lt;class Executor&gt;
  friend see-below require(Executor ex, always_blocking_t);</code></pre>
<p><em>Returns:</em> A value <code>e1</code> of type <code>E1</code> that holds a copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>OneWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>OneWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>TwoWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>TwoWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>twoway_execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>BulkOneWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>BulkOneWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>bulk_execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>BulkTwoWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>BulkTwoWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>bulk_twoway_execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. In addition, <code>E1</code> provides an overload of <code>require</code> such that <code>e1.require(always_blocking)</code> returns a copy of <code>e1</code>, an overload of <code>query</code> such that <code>e1.query(always_blocking)</code> returns <code>true</code>, and all functions <code>execute</code>, <code>twoway_execute</code>, <code>bulk_execute</code>, and <code>bulk_twoway_execute</code> shall block the calling thread until the submitted functions have finished execution. <code>e1</code> has the same executor properties as <code>ex</code>, except for the addition of the <code>always_blocking_t</code> property, and removal of <code>never_blocking_t</code> and <code>possibly_blocking_t</code> properties if present.</p>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless <code>adaptable_blocking_t::static_query_v&lt;Executor&gt;</code> is <code>true</code>.</p>
<h4 id="properties-to-indicate-if-blocking-and-directionality-may-be-adapted"><span class="header-section-number">1.3.5.2</span> Properties to indicate if blocking and directionality may be adapted</h4>
<pre><code>struct adaptable_blocking_t;
struct not_adaptable_blocking_t;</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>adaptable_blocking_t</code></td>
<td align="left">The <code>require</code> customization point may adapt the executor to add the <code>two_way_t</code> or <code>always_blocking_t</code> properties.</td>
</tr>
<tr class="even">
<td align="left"><code>not_adaptable_blocking_t</code></td>
<td align="left">The <code>require</code> customization point may not adapt the executor to add the <code>two_way_t</code> or <code>always_blocking_t</code> properties.</td>
</tr>
</tbody>
</table>
<p>The <code>not_adaptable_blocking_t</code> and <code>adaptable_blocking_t</code> properties are mutually exclusive.</p>
<p>[<em>Note:</em> The <code>two_way_t</code> property is included here as the <code>require</code> customization point's <code>two_way_t</code> adaptation is specified in terms of <code>std::experimental::future</code>, and that template supports blocking wait operations. <em>--end note</em>]</p>
<p>The value returned from <code>execution::query(e, p)</code> shall not change between calls unless <code>e</code> is assigned another executor which has a different value for <code>p</code>. The value returned from <code>execution::query(e, p1)</code> and a subsequent call <code>execution::query(e1, p1)</code> where: * <code>p1</code> is <code>execution::adaptable_blocking</code> or <code>execution::not_adaptable_blocking</code>, and * <code>e1</code> is the result of <code>execution::require(e, p2)</code> or <code>execution::prefer(e, p2)</code>, shall compare equal unless: * <code>p2</code> is <code>execution::adaptable_blocking</code> or <code>execution::not_adaptable_blocking</code>, and * <code>p1</code> and <code>p2</code> are different types.</p>
<h5 id="adaptable_blocking_t-customization-points"><span class="header-section-number">1.3.5.2.1</span> <code>adaptable_blocking_t</code> customization points</h5>
<p>In addition to conforming to the above specification, the <code>adaptable_blocking_t</code> property provides the following customization:</p>
<pre><code>struct adaptable_blocking_t
{
  template&lt;class Executor&gt;
    friend see-below require(Executor ex, adaptable_blocking_t);
};</code></pre>
<p>This customization uses an adapter to implement the <code>adaptable_blocking_t</code> property.</p>
<pre><code>template&lt;class Executor&gt;
  friend see-below require(Executor ex, adaptable_blocking_t);</code></pre>
<p><em>Returns:</em> A value <code>e1</code> of type <code>E1</code> that holds a copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>OneWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>OneWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>TwoWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>TwoWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>twoway_execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>BulkOneWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>BulkOneWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>bulk_execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. If <code>Executor</code> satisfies the <code>BulkTwoWayExecutor</code> requirements, <code>E1</code> shall satisfy the <code>BulkTwoWayExecutor</code> requirements by providing member functions <code>require</code>, <code>query</code>, and <code>bulk_twoway_execute</code> that forward to the corresponding member functions of the copy of <code>ex</code>. In addition, <code>adaptable_blocking_t::static_query_v&lt;E1&gt;</code> is <code>true</code>, and <code>e1.require(not_adaptable_blocking)</code> yields a copy of <code>ex</code>. <code>e1</code> has the same executor properties as <code>ex</code>, except for the addition of the <code>adaptable_blocking_t</code> property.</p>
<h4 id="properties-to-indicate-if-submitted-tasks-represent-continuations"><span class="header-section-number">1.3.5.3</span> Properties to indicate if submitted tasks represent continuations</h4>
<pre><code>struct continuation_t;
struct not_continuation_t;</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>continuation_t</code></td>
<td align="left">Function objects submitted through the executor represent continuations of the caller. If the caller is a lightweight execution agent managed by the executor or its associated execution context, the execution of the submitted function object may be deferred until the caller completes.</td>
</tr>
<tr class="even">
<td align="left"><code>not_continuation_t</code></td>
<td align="left">Function objects submitted through the executor do not represent continuations of the caller.</td>
</tr>
</tbody>
</table>
<p>The <code>not_continuation_t</code> and <code>continuation_t</code> properties are mutually exclusive.</p>
<p>The value returned from <code>execution::query(e, p)</code> shall not change between calls unless <code>e</code> is assigned another executor which has a different value for <code>p</code>. The value returned from <code>execution::query(e, p1)</code> and a subsequent call <code>execution::query(e1, p1)</code> where: * <code>p1</code> is <code>execution::continuation</code> or <code>execution::not_continuation</code>, and * <code>e1</code> is the result of <code>execution::require(e, p2)</code> or <code>execution::prefer(e, p2)</code>, shall compare equal unless: * <code>p2</code> is <code>execution::continuation</code> or <code>execution::not_continuation</code>, and * <code>p1</code> and <code>p2</code> are different types.</p>
<h4 id="properties-to-indicate-likely-task-submission-in-the-future"><span class="header-section-number">1.3.5.4</span> Properties to indicate likely task submission in the future</h4>
<pre><code>struct not_outstanding_work_t;
struct outstanding_work_t;</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>outstanding_work_t</code></td>
<td align="left">The existence of the executor object represents an indication of likely future submission of a function object. The executor or its associated execution context may choose to maintain execution resources in anticipation of this submission.</td>
</tr>
<tr class="even">
<td align="left"><code>not_outstanding_work_t</code></td>
<td align="left">The existence of the executor object does not indicate any likely future submission of a function object.</td>
</tr>
</tbody>
</table>
<p>The <code>not_outstanding_work_t</code> and <code>outstanding_work_t</code> properties are mutually exclusive.</p>
<p>[<em>Note:</em> The <code>outstanding_work_t</code> and <code>not_outstanding_work_t</code> properties are use to communicate to the associated execution context intended future work submission on the executor. The intended effect of the properties is the behavior of execution context's facilities for awaiting outstanding work; specifically whether it considers the existance of the executor object with the <code>outstanding_work_t</code> property enabled outstanding work when deciding what to wait on. However this will be largely defined by the execution context implementation. It is intended that the execution context will define its wait facilities and on-destruction behaviour and provide an interface for querying this. An initial work towards this is included in P0737r0. <em>--end note</em>]</p>
<p>The value returned from <code>execution::query(e, p)</code> shall not change between calls unless <code>e</code> is assigned another executor which has a different value for <code>p</code>. The value returned from <code>execution::query(e, p1)</code> and a subsequent call <code>execution::query(e1, p1)</code> where: * <code>p1</code> is <code>execution::outstanding_work</code> or <code>execution::not_outstanding_work</code>, and * <code>e1</code> is the result of <code>execution::require(e, p2)</code> or <code>execution::prefer(e, p2)</code>, shall compare equal unless: * <code>p2</code> is <code>execution::outstanding_work</code> or <code>execution::not_outstanding_work</code>, and * <code>p1</code> and <code>p2</code> are different types.</p>
<h4 id="properties-for-bulk-execution-guarantees"><span class="header-section-number">1.3.5.5</span> Properties for bulk execution guarantees</h4>
<p>These properties communicate the forward progress and ordering guarantees of execution agents with respect to other agents within the same bulk submission.</p>
<pre><code>struct bulk_sequenced_execution_t;
struct bulk_parallel_execution_t;
struct bulk_unsequenced_execution_t;</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>bulk_sequenced_execution_t</code></td>
<td align="left">Execution agents within the same bulk execution may not be parallelized.</td>
</tr>
<tr class="even">
<td align="left"><code>bulk_parallel_execution_t</code></td>
<td align="left">Execution agents within the same bulk execution may be parallelized.</td>
</tr>
<tr class="odd">
<td align="left"><code>bulk_unsequenced_execution_t</code></td>
<td align="left">Execution agents within the same bulk execution may be parallelized and vectorized.</td>
</tr>
</tbody>
</table>
<p>Execution agents created by executors with the <code>bulk_sequenced_execution_t</code> property execute in sequence in lexicographic order of their indices.</p>
<p>Execution agents created by executors with the <code>bulk_parallel_execution_t</code> property execute with a parallel forward progress guarantee. Any such agents executing in the same thread of execution are indeterminately sequenced with respect to each other. [<em>Note:</em> It is the caller's responsibility to ensure that the invocation does not introduce data races or deadlocks. <em>--end note</em>]</p>
<p>Execution agents created by executors with the <code>bulk_unsequenced_execution_t</code> property may execute in an unordered fashion. Any such agents executing in the same thread of execution are unsequenced with respect to each other. [<em>Note:</em> This means that multiple execution agents may be interleaved on a single thread of execution, which overrides the usual guarantee from [intro.execution] that function executions do not interleave with one another. <em>--end note</em>]</p>
<p>[<em>Editorial note:</em> The descriptions of these properties were ported from [algorithms.parallel.user]. The intention is that a future standard will specify execution policy behavior in terms of the fundamental properties of their associated executors. We did not include the accompanying code examples from [algorithms.parallel.user] because the examples seem easier to understand when illustrated by <code>std::for_each</code>. <em>--end editorial note</em>]</p>
<p>[<em>Note:</em> The guarantees provided by these properties implies the relationship: <code>bulk_unsequenced_execution &lt; bulk_parallel_execution &lt; bulk_sequenced_execution</code>. <em>--end note</em>]</p>
<p>[<em>Editorial note:</em> The note above is intended to describe when one bulk executor can be substituted for another and provide the required semantics. For example, if a user needs sequenced execution, then only an executor with the <code>bulk_sequenced_execution_t</code> property will do. On the other hand, if a user only needs <code>bulk_unsequenced_execution_t</code>, then an executor with any of the above properties will suffice. <em>--end editorial note</em>]</p>
<p>The <code>bulk_unsequenced_execution_t</code>, <code>bulk_parallel_execution_t</code>, and <code>bulk_sequenced_execution_t</code> properties are mutually exclusive.</p>
<p>The value returned from <code>execution::query(e, p)</code> shall not change between calls unless <code>e</code> is assigned another executor which has a different value for <code>p</code>. The value returned from <code>execution::query(e, p1)</code> and a subsequent call <code>execution::query(e1, p1)</code> where: * <code>p1</code> is <code>execution::bulk_unsequenced_execution</code>, <code>execution::bulk_parallel_execution</code> or <code>execution::bulk_sequenced_execution</code>, and * <code>e1</code> is the result of <code>execution::require(e, p2)</code> or <code>execution::prefer(e, p2)</code>, shall compare equal unless: * <code>p2</code> is <code>execution::bulk_unsequenced_execution</code>, <code>execution::bulk_parallel_execution</code> or <code>execution::bulk_sequenced_execution</code>, and * <code>p1</code> and <code>p2</code> are different types.</p>
<h4 id="properties-for-mapping-of-execution-on-to-threads"><span class="header-section-number">1.3.5.6</span> Properties for mapping of execution on to threads</h4>
<pre><code>struct other_execution_mapping_t;
struct thread_execution_mapping_t;
struct new_thread_execution_mapping_t;</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>other_execution_mapping_t</code></td>
<td align="left">Mapping of each execution agent created by the executor is implementation defined.</td>
</tr>
<tr class="even">
<td align="left"><code>thread_execution_mapping_t</code></td>
<td align="left">Execution agents created by the executor are mapped onto threads of execution.</td>
</tr>
<tr class="odd">
<td align="left"><code>new_thread_execution_mapping_t</code></td>
<td align="left">Each execution agent created by the executor is mapped onto a new thread of execution.</td>
</tr>
</tbody>
</table>
<p>The <code>other_execution_mapping_t</code>, <code>thread_execution_mapping_t</code> and <code>new_thread_execution_mapping_t</code> properties are mutually exclusive.</p>
<p>[<em>Note:</em> The guarantees of <code>other_execution_mapping_t</code>, <code>thread_execution_mapping_t</code> and <code>new_thread_execution_mapping_t</code> implies the relationship: <code>other_execution_mapping_t &lt; thread_execution_mapping_t &lt; new_thread_execution_mapping_t</code> <em>--end note</em>]</p>
<p>[<em>Note:</em> A mapping of an execution agent onto a thread of execution implies the agent executes as-if on a <code>std::thread</code>. Therefore, the facilities provided by <code>std::thread</code>, such as thread-local storage, are available. <code>new_thread_execution_mapping_t</code> provides stronger guarantees, in particular that thread-local storage will not be shared between execution agents. <em>--end note</em>]</p>
<p>The value returned from <code>execution::query(e, p)</code> shall not change between calls unless <code>e</code> is assigned another executor which has a different value for <code>p</code>. The value returned from <code>execution::query(e, p1)</code> and a subsequent call <code>execution::query(e1, p1)</code> where: * <code>p1</code> is <code>execution::other_execution_mapping</code>, <code>execution::thread_execution_mapping</code> or <code>execution::new_thread_execution_mapping</code>, and * <code>e1</code> is the result of <code>execution::require(e, p2)</code> or <code>execution::prefer(e, p2)</code>, shall compare equal unless: * <code>p2</code> is <code>execution::other_execution_mapping</code>, <code>execution::thread_execution_mapping</code> or <code>execution::new_thread_execution_mapping</code>, and * <code>p1</code> and <code>p2</code> are different types.</p>
<h3 id="properties-for-customizing-memory-allocation"><span class="header-section-number">1.3.6</span> Properties for customizing memory allocation</h3>
<pre><code>template &lt;typename ProtoAllocator&gt;
struct allocator_t;</code></pre>
<p>The <code>allocator_t</code> property conforms to the following specification:</p>
<pre><code>template &lt;typename ProtoAllocator&gt;
struct allocator_t
{
    static constexpr bool is_requirable = true;
    static constexpr bool is_preferable = true;

    template&lt;class Executor&gt;
    static constexpr bool static_query_v
      = Executor::query(allocator_t);

    template &lt;typename OtherProtoAllocator&gt;
    allocator_t&lt;OtherProtoAllocator&gt; operator()(const OtherProtoAllocator &amp;a) const {
        return allocator_t&lt;OtherProtoAllocator&gt;{a};
    }

    static constexpr bool value() const { return a; }
};</code></pre>
<table style="width:36%;">
<colgroup>
<col width="15%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>allocator_t&lt;ProtoAllocator&gt;</code></td>
<td align="left">Result of <code>allocator_t&lt;void&gt;::operator(OtherProtoAllocator)</code>. The executor type satisfies the <code>OneWayExecutor</code>, <code>TwoWayExecutor</code>, or <code>ThenExecutor</code> requirements. The executor implementation shall use the encapsulated allocator to allocate any memory required to store the submitted function object.</td>
</tr>
<tr class="even">
<td align="left"><code>allocator_t&lt;void&gt;</code></td>
<td align="left">Specialisation of <code>allocator_t&lt;ProtoAllocator&gt;</code>. The executor type satisfies the <code>OneWayExecutor</code>, <code>TwoWayExecutor</code>, or <code>ThenExecutor</code> requirements. The executor implementation shall use an implementation defined default allocator to allocate any memory required to store the submitted function object.</td>
</tr>
</tbody>
</table>
<p><em>Remarks:</em> <code>operator(OtherProtoAllocator)</code> and <code>value()</code> shall not participate in overload resolution unless <code>ProtoAllocator</code> is <code>void</code>.</p>
<p><em>Postconditions:</em> <code>alloc.value()</code> returns <code>a</code>, where <code>alloc</code> is the result of <code>allocator(a)</code>.</p>
<p>[<em>Note:</em> Where the <code>allocator_t</code> is queryable, it must be accepted as both <code>allocator_t&lt;ProtoAllocator&gt;</code> and <code>allocator_t&lt;void&gt;</code>. <em>--end note</em>]</p>
<p>[<em>Note:</em> As the <code>allocator_t&lt;ProtoAllocator&gt;</code> property enapsulates a value which can be set and queried, it is required to be implemented such that it is callable with the <code>OtherProtoAllocator</code> parameter where the customization points accepts the result of <code>allocator_t&lt;void&gt;::operator(OtherProtoAllocator)</code>; <code>allocator_t&lt;OtherProtoAllocator&gt;</code> and is passable as an instance where the customization points accept an instance of <code>allocator_t&lt;void&gt;</code>. <em>--end note</em>]</p>
<p>[<em>Note:</em> It is permitted for an allocator provided via <code>allocator_t&lt;void&gt;::operator(OtherProtoAllocator)</code> property to be the same type as the default allocator provided by the implementation. <em>--end note</em>]</p>
<p>The value returned from <code>execution::query(e, p)</code> shall not change between calls unless <code>e</code> is assigned another executor which has a different value for <code>p</code>. The value returned from <code>execution::query(e, p1)</code> and a subsequent call <code>execution::query(e1, p1)</code> where: * <code>p1</code> is <code>execution::allocator</code> or <code>execution::allocator(ProtoAllocator)</code>, and <code>e1</code> is the result of <code>execution::require(e, p2)</code> or <code>execution::prefer(e, p2)</code>, shall compare equal unless: * <code>p2</code> is <code>execution::allocator</code> or <code>execution::allocator(ProtoAllocator)</code>.</p>
<h2 id="executor-type-traits"><span class="header-section-number">1.4</span> Executor type traits</h2>
<h3 id="determining-that-a-type-satisfies-executor-type-requirements"><span class="header-section-number">1.4.1</span> Determining that a type satisfies executor type requirements</h3>
<pre><code>template&lt;class T&gt; struct is_oneway_executor;
template&lt;class T&gt; struct is_twoway_executor;
template&lt;class T&gt; struct is_then_executor;
template&lt;class T&gt; struct is_bulk_oneway_executor;
template&lt;class T&gt; struct is_bulk_twoway_executor;
template&lt;class T&gt; struct is_bulk_then_executor;</code></pre>
<p>This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of <code>true_type</code> if the corresponding condition is true, otherwise <code>false_type</code>.</p>
<table style="width:94%;">
<colgroup>
<col width="40%" />
<col width="30%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Template</th>
<th align="left">Condition</th>
<th align="left">Preconditions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_oneway_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>OneWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_twoway_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>TwoWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_then_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>ThenExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_bulk_oneway_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>BulkOneWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="odd">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_bulk_twoway_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>BulkTwoWayExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
<tr class="even">
<td align="left"><code>template&lt;class T&gt;</code> <br/><code>struct is_bulk_then_executor</code></td>
<td align="left"><code>T</code> meets the syntactic requirements for <code>BulkThenExecutor</code>.</td>
<td align="left"><code>T</code> is a complete type.</td>
</tr>
</tbody>
</table>
<h3 id="associated-future-type"><span class="header-section-number">1.4.2</span> Associated future type</h3>
<pre><code>template&lt;class Executor, class T&gt;
struct executor_future
{
  using type = decltype(execution::require(declval&lt;const Executor&amp;&gt;(), execution::twoway).twoway_execute(declval&lt;T(*)()&gt;()));
};</code></pre>
<h3 id="associated-shape-type"><span class="header-section-number">1.4.3</span> Associated shape type</h3>
<pre><code>template&lt;class Executor&gt;
struct executor_shape
{
  private:
    // exposition only
    template&lt;class T&gt;
    using helper = typename T::shape_type;

  public:
    using type = std::experimental::detected_or_t&lt;
      size_t, helper, decltype(execution::require(declval&lt;const Executor&amp;&gt;(), execution::bulk))
    &gt;;

    // exposition only
    static_assert(std::is_integral_v&lt;type&gt;, &quot;shape type must be an integral type&quot;);
};</code></pre>
<h3 id="associated-index-type"><span class="header-section-number">1.4.4</span> Associated index type</h3>
<pre><code>template&lt;class Executor&gt;
struct executor_index
{
  private:
    // exposition only
    template&lt;class T&gt;
    using helper = typename T::index_type;

  public:
    using type = std::experimental::detected_or_t&lt;
      executor_shape_t&lt;Executor&gt;, helper, decltype(execution::require(declval&lt;const Executor&amp;&gt;(), execution::bulk))
    &gt;;

    // exposition only
    static_assert(std::is_integral_v&lt;type&gt;, &quot;index type must be an integral type&quot;);
};</code></pre>
<h2 id="polymorphic-executor-wrappers"><span class="header-section-number">1.5</span> Polymorphic executor wrappers</h2>
<p>[<em>Commentary: The polymorphic executor wrapper class has been written such that it could be separated from the rest of the proposal if necessary.</em>]</p>
<p>In several places in this section the operation <code>CONTAINS_PROPERTY(p, pn)</code> is used. All such uses mean <code>std::disjunction_v&lt;std::is_same&lt;p, pn&gt;...&gt;</code>.</p>
<h3 id="class-bad_executor"><span class="header-section-number">1.5.1</span> Class <code>bad_executor</code></h3>
<p>An exception of type <code>bad_executor</code> is thrown by <code>executor</code> member functions <code>execute</code>, <code>twoway_execute</code>, <code>bulk_execute</code>, and <code>bulk_twoway_execute</code> when the executor object has no target.</p>
<pre><code>class bad_executor : public exception
{
public:
  // constructor:
  bad_executor() noexcept;
};</code></pre>
<h4 id="bad_executor-constructors"><span class="header-section-number">1.5.1.1</span> <code>bad_executor</code> constructors</h4>
<pre><code>bad_executor() noexcept;</code></pre>
<p><em>Effects:</em> Constructs a <code>bad_executor</code> object.</p>
<p><em>Postconditions:</em> <code>what()</code> returns an implementation-defined NTBS.</p>
<h3 id="class-template-executor"><span class="header-section-number">1.5.2</span> Class template <code>executor</code></h3>
<p>The <code>executor</code> class template provides a polymorphic wrapper for executor types.</p>
<pre><code>template &lt;class... SupportableProperties&gt;
class executor
{
public:
  // construct / copy / destroy:

  executor() noexcept;
  executor(nullptr_t) noexcept;
  executor(const executor&amp; e) noexcept;
  executor(executor&amp;&amp; e) noexcept;
  template&lt;class Executor&gt; executor(Executor e);
  template&lt;class... OtherSupportableProperties&gt; executor(executor&lt;OtherSupportableProperties...&gt; e);

  executor&amp; operator=(const executor&amp; e) noexcept;
  executor&amp; operator=(executor&amp;&amp; e) noexcept;
  executor&amp; operator=(nullptr_t) noexcept;
  template&lt;class Executor&gt; executor&amp; operator=(Executor e);

  ~executor();

  // executor modifiers:

  void swap(executor&amp; other) noexcept;

  // executor operations:

  template &lt;class Property&gt;
  executor require(Property) const;

  template &lt;class Property&gt;
  executor query(Property) const;

  template&lt;class Function&gt;
    void execute(Function&amp;&amp; f) const;

  template&lt;class Function&gt;
    std::experimental::future&lt;result_of_t&lt;decay_t&lt;Function&gt;()&gt;&gt;
      twoway_execute(Function&amp;&amp; f) const

  template&lt;class Function, class SharedFactory&gt;
    void bulk_execute(Function&amp;&amp; f, size_t n, SharedFactory&amp;&amp; sf) const;

  template&lt;class Function, class ResultFactory, class SharedFactory&gt;
    std::experimental::future&lt;result_of_t&lt;decay_t&lt;ResultFactory&gt;()&gt;&gt;
      bulk_twoway_execute(Function&amp;&amp; f, size_t n, ResultFactory&amp;&amp; rf, SharedFactory&amp;&amp; sf) const;

  // executor capacity:

  explicit operator bool() const noexcept;

  // executor target access:

  const type_info&amp; target_type() const noexcept;
  template&lt;class Executor&gt; Executor* target() noexcept;
  template&lt;class Executor&gt; const Executor* target() const noexcept;
};

// executor comparisons:

template &lt;class... SupportableProperties&gt;
bool operator==(const executor&lt;SupportableProperties...&gt;&amp; a, const executor&lt;SupportableProperties...&gt;&amp; b) noexcept;
template &lt;class... SupportableProperties&gt;
bool operator==(const executor&lt;SupportableProperties...&gt;&amp; e, nullptr_t) noexcept;
template &lt;class... SupportableProperties&gt;
bool operator==(nullptr_t, const executor&lt;SupportableProperties...&gt;&amp; e) noexcept;
template &lt;class... SupportableProperties&gt;
bool operator!=(const executor&lt;SupportableProperties...&gt;&amp; a, const executor&lt;SupportableProperties...&gt;&amp; b) noexcept;
template &lt;class... SupportableProperties&gt;
bool operator!=(const executor&lt;SupportableProperties...&gt;&amp; e, nullptr_t) noexcept;
template &lt;class... SupportableProperties&gt;
bool operator!=(nullptr_t, const executor&lt;SupportableProperties...&gt;&amp; e) noexcept;

// executor specialized algorithms:

template &lt;class... SupportableProperties&gt;
void swap(executor&lt;SupportableProperties...&gt;&amp; a, executor&lt;SupportableProperties...&gt;&amp; b) noexcept;

template &lt;class Property, class... SupportableProperties&gt;
executor prefer(const executor&lt;SupportableProperties&gt;&amp; e, Property p);</code></pre>
<p>The <code>executor</code> class satisfies the general requirements on executors.</p>
<p>[<em>Note:</em> To meet the <code>noexcept</code> requirements for executor copy constructors and move constructors, implementations may share a target between two or more <code>executor</code> objects. <em>--end note</em>]</p>
<p>The <em>target</em> is the executor object that is held by the wrapper.</p>
<h4 id="executor-constructors"><span class="header-section-number">1.5.2.1</span> <code>executor</code> constructors</h4>
<pre><code>executor() noexcept;</code></pre>
<p><em>Postconditions:</em> <code>!*this</code>.</p>
<pre><code>executor(nullptr_t) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>!*this</code>.</p>
<pre><code>executor(const executor&amp; e) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>!*this</code> if <code>!e</code>; otherwise, <code>*this</code> targets <code>e.target()</code> or a copy of <code>e.target()</code>.</p>
<pre><code>executor(executor&amp;&amp; e) noexcept;</code></pre>
<p><em>Effects:</em> If <code>!e</code>, <code>*this</code> has no target; otherwise, moves <code>e.target()</code> or move-constructs the target of <code>e</code> into the target of <code>*this</code>, leaving <code>e</code> in a valid state with an unspecified value.</p>
<pre><code>template&lt;class Executor&gt; executor(Executor e);</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: * <code>can_require_v&lt;Executor, P</code>, if <code>P::is_requireable</code>, where <code>P</code> is each property in <code>SupportableProperties...</code>. * <code>can_prefer_v&lt;Executor, P</code>, if <code>P::is_preferable</code>, where <code>P</code> is each property in <code>SupportableProperties...</code>. * and <code>can_query_v&lt;Executor, P</code>, where <code>P</code> is each property in <code>SupportableProperties...</code>.</p>
<p><em>Effects:</em> * <code>*this</code> targets a copy of <code>e5</code> initialized with <code>std::move(e5)</code>, where: * If <code>CONTAINS_PROPERTY(execution::single_t, SupportableProperties)</code>, <code>e1</code> is the result of <code>execution::require(e, execution::single_t)</code>, otherwise <code>e1</code> is <code>e</code>, * If <code>CONTAINS_PROPERTY(execution::bulk_t, SupportableProperties)</code>, <code>e2</code> is the result of <code>execution::require(e, execution::bulk_t)</code>, otherwise <code>e2</code> is <code>e1</code> * If <code>CONTAINS_PROPERTY(execution::oneway_t, SupportableProperties)</code>, <code>e3</code> is the result of <code>execution::require(e, execution::oneway_t)</code>, otherwise <code>e3</code> is <code>e2</code> * If <code>CONTAINS_PROPERTY(execution::twoway_t, SupportableProperties)</code>, <code>e4</code> is the result of <code>execution::require(e, execution::twoway_t)</code>, otherwise <code>e4</code> is <code>e3</code>. * * If <code>CONTAINS_PROPERTY(execution::then_t, SupportableProperties)</code>, <code>e5</code> is the result of <code>execution::require(e, execution::then_t)</code>, otherwise <code>e5</code> is <code>e4</code>.</p>
<pre><code>template&lt;class... OtherSupportableProperties&gt; executor(executor&lt;OtherSupportableProperties...&gt; e);</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: * <code>CONTAINS_PROPERTY(p, OtherSupportableProperties)</code> , where <code>p</code> is each property in <code>SupportableProperties...</code>.</p>
<p><em>Effects:</em> <code>*this</code> targets a copy of <code>e</code> initialized with <code>std::move(e)</code>.</p>
<h4 id="executor-assignment"><span class="header-section-number">1.5.2.2</span> <code>executor</code> assignment</h4>
<pre><code>executor&amp; operator=(const executor&amp; e) noexcept;</code></pre>
<p><em>Effects:</em> <code>executor(e).swap(*this)</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>executor&amp; operator=(executor&amp;&amp; e) noexcept;</code></pre>
<p><em>Effects:</em> Replaces the target of <code>*this</code> with the target of <code>e</code>, leaving <code>e</code> in a valid state with an unspecified value.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>executor&amp; operator=(nullptr_t) noexcept;</code></pre>
<p><em>Effects:</em> <code>executor(nullptr).swap(*this)</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>template&lt;class Executor&gt; executor&amp; operator=(Executor e);</code></pre>
<p><em>Requires:</em> As for <code>template&lt;class Executor&gt; executor(Executor e)</code>.</p>
<p><em>Effects:</em> <code>executor(std::move(e)).swap(*this)</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<h4 id="executor-destructor"><span class="header-section-number">1.5.2.3</span> <code>executor</code> destructor</h4>
<pre><code>~executor();</code></pre>
<p><em>Effects:</em> If <code>*this != nullptr</code>, releases shared ownership of, or destroys, the target of <code>*this</code>.</p>
<h4 id="executor-modifiers"><span class="header-section-number">1.5.2.4</span> <code>executor</code> modifiers</h4>
<pre><code>void swap(executor&amp; other) noexcept;</code></pre>
<p><em>Effects:</em> Interchanges the targets of <code>*this</code> and <code>other</code>.</p>
<h4 id="executor-operations"><span class="header-section-number">1.5.2.5</span> <code>executor</code> operations</h4>
<pre><code>template &lt;class Property&gt;
executor require(Property p) const;</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: <code>CONTAINS_PROPERTY(Property, SupportableProperties) &amp;&amp; Property::is_requirable</code>.</p>
<p><em>Returns:</em> A polymorphic wrapper whose target is the result of <code>execution::require(e, p)</code>, where <code>e</code> is the target object of <code>*this</code>.</p>
<pre><code>template &lt;class Property&gt;
executor query(Property p) const;</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: <code>CONTAINS_PROPERTY(Property, SupportableProperties)</code>.</p>
<p><em>Effects:</em> Performs <code>execution::query(e, p)</code>, where <code>e</code> is the target object of <code>*this</code>.</p>
<p><em>Returns:</em> <code>static_cast&lt;Property::polymorphic_query_result_type&gt;(e.query(p))</code>.</p>
<pre><code>template&lt;class Function&gt;
  void execute(Function&amp;&amp; f) const;</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: * <code>CONTAINS_PROPERTY(execution::oneway_t, SupportableProperties)</code>, * and <code>CONTAINS_PROPERTY(execution::single_t, SupportableProperties)</code>.</p>
<p><em>Effects:</em> Performs <code>e.execute(f2)</code>, where:</p>
<ul>
<li><code>e</code> is the target object of <code>*this</code>;</li>
<li><code>f1</code> is the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>;</li>
<li><code>f2</code> is a function object of unspecified type that, when called as <code>f2()</code>, performs <code>f1()</code>.</li>
</ul>
<pre><code>template&lt;class Function&gt;
  std::experimental::future&lt;result_of_t&lt;decay_t&lt;Function&gt;()&gt;&gt;
    twoway_execute(Function&amp;&amp; f) const</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: * <code>CONTAINS_PROPERTY(execution::twoway_t, SupportableProperties)</code>, * and <code>CONTAINS_PROPERTY(execution::single_t, SupportableProperties)</code>.</p>
<p><em>Effects:</em> Performs <code>e.twoway_execute(f2)</code>, where:</p>
<ul>
<li><code>e</code> is the target object of <code>*this</code>;</li>
<li><code>f1</code> is the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>;</li>
<li><code>f2</code> is a function object of unspecified type that, when called as <code>f2()</code>, performs <code>f1()</code>.</li>
</ul>
<p><em>Returns:</em> A future, whose shared state is made ready when the future returned by <code>e.twoway_execute(f2)</code> is made ready, containing the result of <code>f1()</code> or any exception thrown by <code>f1()</code>. [<em>Note:</em> <code>e2.twoway_execute(f2)</code> may return any future type that satisfies the Future requirements, and not necessarily <code>std::experimental::future</code>. One possible implementation approach is for the polymorphic wrapper to attach a continuation to the inner future via that object's <code>then()</code> member function. When invoked, this continuation stores the result in the outer future's associated shared and makes that shared state ready. <em>--end note</em>]</p>
<pre><code>template&lt;class Function, class SharedFactory&gt;
  void bulk_execute(Function&amp;&amp; f, size_t n, SharedFactory&amp;&amp; sf) const;</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: * <code>CONTAINS_PROPERTY(execution::oneway_t, SupportableProperties)</code>, * and <code>CONTAINS_PROPERTY(execution::bulk_t, SupportableProperties)</code>.</p>
<p><em>Effects:</em> Performs <code>e.bulk_execute(f2, n, sf2)</code>, where:</p>
<ul>
<li><code>e</code> is the target object of <code>*this</code>;</li>
<li><code>sf1</code> is the result of <code>DECAY_COPY(std::forward&lt;SharedFactory&gt;(sf))</code>;</li>
<li><code>sf2</code> is a function object of unspecified type that, when called as <code>sf2()</code>, performs <code>sf1()</code>;</li>
<li><code>s1</code> is the result of <code>sf1()</code>;</li>
<li><code>s2</code> is the result of <code>sf2()</code>;</li>
<li><code>f1</code> is the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>;</li>
<li><code>f2</code> is a function object of unspecified type that, when called as <code>f2(i, s2)</code>, performs <code>f1(i, s1)</code>, where <code>i</code> is a value of type <code>size_t</code>.</li>
</ul>
<pre><code>template&lt;class Function, class ResultFactory, class SharedFactory&gt;
  std::experimental::future&lt;result_of_t&lt;decay_t&lt;ResultFactory&gt;()&gt;&gt;
    void bulk_twoway_execute(Function&amp;&amp; f, size_t n, ResultFactory&amp;&amp; rf, SharedFactory&amp;&amp; sf) const;</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: * <code>CONTAINS_PROPERTY(execution::twoway_t, SupportableProperties)</code>, * and <code>CONTAINS_PROPERTY(execution::bulk_t, SupportableProperties)</code>.</p>
<p><em>Effects:</em> Performs <code>e.bulk_twoway_execute(f2, n, rf2, sf2)</code>, where:</p>
<ul>
<li><code>e</code> is the target object of <code>*this</code>;</li>
<li><code>rf1</code> is the result of <code>DECAY_COPY(std::forward&lt;ResultFactory&gt;(rf))</code>;</li>
<li><code>rf2</code> is a function object of unspecified type that, when called as <code>rf2()</code>, performs <code>rf1()</code>;</li>
<li><code>sf1</code> is the result of <code>DECAY_COPY(std::forward&lt;SharedFactory&gt;(rf))</code>;</li>
<li><code>sf2</code> is a function object of unspecified type that, when called as <code>sf2()</code>, performs <code>sf1()</code>;</li>
<li>if <code>decltype(rf1())</code> is non-void, <code>r1</code> is the result of <code>rf1()</code>;</li>
<li>if <code>decltype(rf2())</code> is non-void, <code>r2</code> is the result of <code>rf2()</code>;</li>
<li><code>s1</code> is the result of <code>sf1()</code>;</li>
<li><code>s2</code> is the result of <code>sf2()</code>;</li>
<li><code>f1</code> is the result of <code>DECAY_COPY(std::forward&lt;Function&gt;(f))</code>;</li>
<li>if <code>decltype(rf1())</code> is non-void and <code>decltype(rf2())</code> is non-void, <code>f2</code> is a function object of unspecified type that, when called as <code>f2(i, r2, s2)</code>, performs <code>f1(i, r1, s1)</code>, where <code>i</code> is a value of type <code>size_t</code>.</li>
<li>if <code>decltype(rf1())</code> is non-void and <code>decltype(rf2())</code> is void, <code>f2</code> is a function object of unspecified type that, when called as <code>f2(i, s2)</code>, performs <code>f1(i, r1, s1)</code>, where <code>i</code> is a value of type <code>size_t</code>.</li>
<li>if <code>decltype(rf1())</code> is void and <code>decltype(rf2())</code> is non-void, <code>f2</code> is a function object of unspecified type that, when called as <code>f2(i, r2, s2)</code>, performs <code>f1(i, s1)</code>, where <code>i</code> is a value of type <code>size_t</code>.</li>
<li>if <code>decltype(rf1())</code> is void and <code>decltype(rf2())</code> is void, <code>f2</code> is a function object of unspecified type that, when called as <code>f2(i, s2)</code>, performs <code>f1(i, s1)</code>, where <code>i</code> is a value of type <code>size_t</code>.</li>
</ul>
<p><em>Returns:</em> A future, whose shared state is made ready when the future returned by <code>e.bulk_twoway_execute(f2, n, rf2, sf2)</code> is made ready, containing the result in <code>r1</code> (if <code>decltype(rf1())</code> is non-void) or any exception thrown by an invocation<code>f1</code>. [<em>Note:</em> <code>e.bulk_twoway_execute(f2)</code> may return any future type that satisfies the Future requirements, and not necessarily <code>std::experimental::future</code>. One possible implementation approach is for the polymorphic wrapper to attach a continuation to the inner future via that object's <code>then()</code> member function. When invoked, this continuation stores the result in the outer future's associated shared and makes that shared state ready. <em>--end note</em>]</p>
<h4 id="executor-capacity"><span class="header-section-number">1.5.2.6</span> <code>executor</code> capacity</h4>
<pre><code>explicit operator bool() const noexcept;</code></pre>
<p><em>Returns:</em> <code>true</code> if <code>*this</code> has a target, otherwise <code>false</code>.</p>
<h4 id="executor-target-access"><span class="header-section-number">1.5.2.7</span> <code>executor</code> target access</h4>
<pre><code>const type_info&amp; target_type() const noexcept;</code></pre>
<p><em>Returns:</em> If <code>*this</code> has a target of type <code>T</code>, <code>typeid(T)</code>; otherwise, <code>typeid(void)</code>.</p>
<pre><code>template&lt;class Executor&gt; Executor* target() noexcept;
template&lt;class Executor&gt; const Executor* target() const noexcept;</code></pre>
<p><em>Returns:</em> If <code>target_type() == typeid(Executor)</code> a pointer to the stored executor target; otherwise a null pointer value.</p>
<h4 id="executor-comparisons"><span class="header-section-number">1.5.2.8</span> <code>executor</code> comparisons</h4>
<pre><code>template&lt;class... SupportableProperties&gt;
bool operator==(const executor&lt;SupportableProperties...&gt;&amp; a, const executor&lt;SupportableProperties...&gt;&amp; b) noexcept;</code></pre>
<p><em>Returns:</em></p>
<ul>
<li><code>true</code> if <code>!a</code> and <code>!b</code>;</li>
<li><code>true</code> if <code>a</code> and <code>b</code> share a target;</li>
<li><code>true</code> if <code>e</code> and <code>f</code> are the same type and <code>e == f</code>, where <code>e</code> is the target of <code>a</code> and <code>f</code> is the target of <code>b</code>;</li>
<li>otherwise <code>false</code>.</li>
</ul>
<pre><code>template&lt;class... SupportableProperties&gt;
bool operator==(const executor&lt;SupportableProperties...&gt;&amp; e, nullptr_t) noexcept;
template&lt;class... SupportableProperties&gt;
bool operator==(nullptr_t, const executor&lt;SupportableProperties...&gt;&amp; e) noexcept;</code></pre>
<p><em>Returns:</em> <code>!e</code>.</p>
<pre><code>template&lt;class... SupportableProperties&gt;
bool operator!=(const executor&lt;SupportableProperties...&gt;&amp; a, const executor&lt;SupportableProperties...&gt;&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>!(a == b)</code>.</p>
<pre><code>template&lt;class... SupportableProperties&gt;
bool operator!=(const executor&lt;SupportableProperties...&gt;&amp; e, nullptr_t) noexcept;
template&lt;class... SupportableProperties&gt;
bool operator!=(nullptr_t, const executor&lt;SupportableProperties...&gt;&amp; e) noexcept;</code></pre>
<p><em>Returns:</em> <code>(bool) e</code>.</p>
<h4 id="executor-specialized-algorithms"><span class="header-section-number">1.5.2.9</span> <code>executor</code> specialized algorithms</h4>
<pre><code>template&lt;class... SupportableProperties&gt;
void swap(executor&lt;SupportableProperties...&gt;&amp; a, executor&lt;SupportableProperties...&gt;&amp; b) noexcept;</code></pre>
<p><em>Effects:</em> <code>a.swap(b)</code>.</p>
<pre class="s"><code>template &lt;class Property, class... SupportableProperties&gt;
executor prefer(const executor&lt;SupportableProperties...&gt;&amp; e, Property p);</code></pre>
<p><em>Remarks:</em> This function shall not participate in overload resolution unless: <code>CONTAINS_PROPERTY(Property, SupportableProperties)</code>.</p>
<p><em>Returns:</em> A polymorphic wrapper whose target is the result of <code>execution::prefer(e, p)</code>, where <code>e</code> is the target object of <code>*this</code>.</p>
<h3 id="struct-prefer_only"><span class="header-section-number">1.5.3</span> Struct <code>prefer_only</code></h3>
<p>The <code>prefer_only</code> struct is a property adapter that disables the <code>is_requirable</code> value.</p>
<p>[<em>Example:</em></p>
<p>Consider a generic function that performs some task immediately if it can, and otherwise asynchronously in the background.</p>
<pre><code>template&lt;class Executor&gt;
void do_async_work(
    Executor ex,
    Callback callback)
{
  if (try_work() == done)
  {
    // Work completed immediately, invoke callback.
    execution::require(ex,
        execution::single,
        execution::oneway,
      ).execute(callback);
  }
  else
  {
    // Perform work in background. Track outstanding work.
    start_background_work(
        execution::prefer(ex,
          execution::outstanding_work),
        callback);
  }
}</code></pre>
<p>This function can be used with an inline executor which is defined as follows:</p>
<pre><code>struct inline_executor
{
  constexpr bool operator==(const inline_executor&amp;) const noexcept
  {
    return true;
  }

  constexpr bool operator!=(const inline_executor&amp;) const noexcept
  {
    return false;
  }

  template&lt;class Function&gt; void execute(Function f) const noexcept
  {
    f();
  }
};</code></pre>
<p>as, in the case of an unsupported property, the <code>execution::prefer</code> call will fall back to an identity operation.</p>
<p>The polymorphic <code>executor</code> wrapper should be able to simply swap in, so that we could change <code>do_async_work</code> to the non-template function:</p>
<pre><code>void do_async_work(
    executor&lt;
      execution::single,
      execution::oneway,
      execution::outstanding_work&gt; ex,
    std::function&lt;void()&gt; callback)
{
  if (try_work() == done)
  {
    // Work completed immediately, invoke callback.
    execution::require(ex,
        execution::single,
        execution::oneway,
      ).execute(callback);
  }
  else
  {
    // Perform work in background. Track outstanding work.
    start_background_work(
        execution::prefer(ex,
          execution::outstanding_work),
        callback);
  }
}</code></pre>
<p>with no change in behavior or semantics.</p>
<p>However, if we simply specify <code>execution::outstanding_work</code> in the <code>executor</code> template parameter list, we will get a compile error. This is because the <code>executor</code> template doesn't know that <code>execution::outstanding_work</code> is intended for use with <code>prefer</code> only. At the point of construction from an <code>inline_executor</code> called <code>ex</code>, <code>executor</code> will try to instantiate implementation templates that perform the ill-formed <code>execution::require(ex, execution::outstanding_work)</code>.</p>
<p>The <code>prefer_only</code> adapter addresses this by turning off the <code>is_requirable</code> attribute for a specific property. It would be used in the above example as follows:</p>
<pre><code>void do_async_work(
    executor&lt;
      execution::single,
      execution::oneway,
      prefer_only&lt;execution::outstanding_work&gt;&gt; ex,
    std::function&lt;void()&gt; callback)
{
  ...
}</code></pre>
<p><em>-- end example</em>]</p>
<pre><code>template&lt;class InnerProperty&gt;
struct prefer_only
{
  InnerProperty property;

  static constexpr bool is_requirable = false;
  static constexpr bool is_preferable = InnerProperty::is_preferable;

  using polymorphic_query_result_type = see-below; // not always defined

  template&lt;class Executor&gt;
    static constexpr auto static_query_v = see-below; // not always defined

  constexpr prefer_only(const InnerProperty&amp; p);

  constexpr auto value() const
    noexcept(noexcept(std::declval&lt;const InnerProperty&gt;().value()))
      -&gt; decltype(std::declval&lt;const InnerProperty&gt;().value());

  template&lt;class Executor&gt;
  friend auto prefer(Executor ex, const prefer_only&amp; p)
    noexcept(noexcept(execution::prefer(std::move(ex), std::declval&lt;const InnerProperty&gt;())))
      -&gt; decltype(execution::prefer(std::move(ex), std::declval&lt;const InnerProperty&gt;()));

  template&lt;class Executor&gt;
  friend constexpr auto query(const Executor&amp; ex, const prefer_only&amp; p)
    noexcept(noexcept(execution::query(ex, std::declval&lt;const InnerProperty&gt;())))
      -&gt; decltype(execution::query(ex, std::declval&lt;const InnerProperty&gt;()));
};</code></pre>
<p>If <code>InnerProperty::polymorphic_query_result_type</code> is valid and denotes a type, the template instantiation <code>prefer_only&lt;InnerProperty&gt;</code> defines a nested type <code>polymorphic_query_result_type</code> as a synonym for <code>InnerProperty::polymorphic_query_result_type</code>.</p>
<p>If <code>InnerProperty::static_query_v</code> is a variable template and <code>InnerProperty::static_query_v&lt;E&gt;</code> is well formed for some executor type <code>E</code>, the template instantiation <code>prefer_only&lt;InnerProperty&gt;</code> defines a nested variable template <code>static_query_v</code> as a synonym for <code>InnerProperty::static_query_v</code>.</p>
<pre><code>constexpr prefer_only(const InnerProperty&amp; p);</code></pre>
<p><em>Effects:</em> Initializes <code>property</code> with <code>p</code>.</p>
<pre><code>constexpr auto value() const
  noexcept(noexcept(std::declval&lt;const InnerProperty&gt;().value()))
    -&gt; decltype(std::declval&lt;const InnerProperty&gt;().value());</code></pre>
<p><em>Returns:</em> <code>property.value()</code>.</p>
<p><em>Remarks:</em> Shall not participate in overload resolution unless the expression <code>property.value()</code> is well-formed.</p>
<pre><code>template&lt;class Executor&gt;
friend auto prefer(Executor ex, const prefer_only&amp; p)
  noexcept(noexcept(execution::prefer(std::move(ex), std::declval&lt;const InnerProperty&gt;())))
    -&gt; decltype(execution::prefer(std::move(ex), std::declval&lt;const InnerProperty&gt;()));</code></pre>
<p><em>Returns:</em> <code>execution::prefer(std::move(ex), p.property)</code>.</p>
<p><em>Remarks:</em> Shall not participate in overload resolution unless the expression <code>execution::prefer(std::move(ex), p.property)</code> is well-formed.</p>
<pre><code>template&lt;class Executor&gt;
friend constexpr auto query(const Executor&amp; ex, const prefer_only&amp; p)
  noexcept(noexcept(execution::query(ex, std::declval&lt;const InnerProperty&gt;())))
    -&gt; decltype(execution::query(ex, std::declval&lt;const InnerProperty&gt;()));</code></pre>
<p><em>Returns:</em> <code>execution::query(ex, p.property)</code>.</p>
<p><em>Remarks:</em> Shall not participate in overload resolution unless the expression <code>execution::query(ex, p.property)</code> is well-formed.</p>
<h2 id="thread-pools"><span class="header-section-number">1.6</span> Thread pools</h2>
<p>Thread pools create execution agents which execute on threads without incurring the overhead of thread creation and destruction whenever such agents are needed.</p>
<h3 id="header-thread_pool-synopsis"><span class="header-section-number">1.6.1</span> Header <code>&lt;thread_pool&gt;</code> synopsis</h3>
<pre><code>namespace std {
namespace experimental {
inline namespace executors_v1 {

  class static_thread_pool;

} // inline namespace executors_v1
} // namespace experimental
} // namespace std</code></pre>
<h3 id="class-static_thread_pool"><span class="header-section-number">1.6.2</span> Class <code>static_thread_pool</code></h3>
<p><code>static_thread_pool</code> is a statically-sized thread pool which may be explicitly grown via thread attachment. The <code>static_thread_pool</code> is expected to be created with the use case clearly in mind with the number of threads known by the creator. As a result, no default constructor is considered correct for arbitrary use cases and <code>static_thread_pool</code> does not support any form of automatic resizing.</p>
<p><code>static_thread_pool</code> presents an effectively unbounded input queue and the execution functions of <code>static_thread_pool</code>'s associated executors do not block on this input queue.</p>
<p>[<em>Note:</em> Because <code>static_thread_pool</code> represents work as parallel execution agents, situations which require concurrent execution properties are not guaranteed correctness. <em>--end note.</em>]</p>
<pre><code>class static_thread_pool
{
  public:
    using executor_type = see-below;
    
    // construction/destruction
    explicit static_thread_pool(std::size_t num_threads);
    
    // nocopy
    static_thread_pool(const static_thread_pool&amp;) = delete;
    static_thread_pool&amp; operator=(const static_thread_pool&amp;) = delete;

    // stop accepting incoming work and wait for work to drain
    ~static_thread_pool();

    // attach current thread to the thread pools list of worker threads
    void attach();

    // signal all work to complete
    void stop();

    // wait for all threads in the thread pool to complete
    void wait();

    // placeholder for a general approach to getting executors from 
    // standard contexts.
    executor_type executor() noexcept;
};</code></pre>
<p>For an object of type <code>static_thread_pool</code>, <em>outstanding work</em> is defined as the sum of:</p>
<ul>
<li><p>the number of existing executor objects associated with the <code>static_thread_pool</code> for which the <code>execution::outstanding_work</code> property is established;</p></li>
<li><p>the number of function objects that have been added to the <code>static_thread_pool</code> via the <code>static_thread_pool</code> executor, but not yet executed; and</p></li>
<li><p>the number of function objects that are currently being executed by the <code>static_thread_pool</code>.</p></li>
</ul>
<p>The <code>static_thread_pool</code> member functions <code>executor</code>, <code>attach</code>, <code>wait</code>, and <code>stop</code>, and the associated executors' copy constructors and member functions, do not introduce data races as a result of concurrent calls to those functions from different threads of execution.</p>
<p>A <code>static_thread_pool</code>'s threads execute execution agents created via its associated executors with forward progress guarantee delegation. [<em>Note:</em> Forward progress is delegated to an execution agent for its lifetime. Because <code>static_thread_pool</code> guarantees only parallel forward progress to execution agents created via its executors, forward progress delegation does not apply to execution agents which have not yet started executing their first execution step. <em>--end note</em>]</p>
<h4 id="types"><span class="header-section-number">1.6.2.1</span> Types</h4>
<pre><code>using executor_type = see-below;</code></pre>
<p>An executor type conforming to the specification for <code>static_thread_pool</code> executor types described below.</p>
<h4 id="construction-and-destruction"><span class="header-section-number">1.6.2.2</span> Construction and destruction</h4>
<pre><code>static_thread_pool(std::size_t num_threads);</code></pre>
<p><em>Effects:</em> Constructs a <code>static_thread_pool</code> object with <code>num_threads</code> threads of execution, as if by creating objects of type <code>std::thread</code>.</p>
<pre><code>~static_thread_pool();</code></pre>
<p><em>Effects:</em> Destroys an object of class <code>static_thread_pool</code>. Performs <code>stop()</code> followed by <code>wait()</code>.</p>
<h4 id="worker-management"><span class="header-section-number">1.6.2.3</span> Worker management</h4>
<pre><code>void attach();</code></pre>
<p><em>Effects:</em> Adds the calling thread to the pool such that this thread is used to execute submitted function objects. [<em>Note:</em> Threads created during thread pool construction, or previously attached to the pool, will continue to be used for function object execution. <em>--end note</em>] Blocks the calling thread until signalled to complete by <code>stop()</code> or <code>wait()</code>, and then blocks until all the threads created during <code>static_thread_pool</code> object construction have completed. (NAMING: a possible alternate name for this function is <code>join()</code>.)</p>
<pre><code>void stop();</code></pre>
<p><em>Effects:</em> Signals the threads in the pool to complete as soon as possible. If a thread is currently executing a function object, the thread will exit only after completion of that function object. The call to <code>stop()</code> returns without waiting for the threads to complete. Subsequent calls to attach complete immediately.</p>
<pre><code>void wait();</code></pre>
<p><em>Effects:</em> If not already stopped, signals the threads in the pool to complete once the outstanding work is <code>0</code>. Blocks the calling thread (C++Std [defns.block]) until all threads in the pool have completed, without executing submitted function objects in the calling thread. Subsequent calls to attach complete immediately.</p>
<p><em>Synchronization:</em> The completion of each thread in the pool synchronizes with (C++Std [intro.multithread]) the corresponding successful <code>wait()</code> return.</p>
<h4 id="executor-creation"><span class="header-section-number">1.6.2.4</span> Executor creation</h4>
<pre><code>executor_type executor() noexcept;</code></pre>
<p><em>Returns:</em> An executor that may be used to submit function objects to the thread pool. The returned executor has the following properties already established:</p>
<ul>
<li><code>execution::oneway</code></li>
<li><code>execution::twoway</code></li>
<li><code>execution::then</code></li>
<li><code>execution::single</code></li>
<li><code>execution::bulk</code></li>
<li><code>execution::possibly_blocking</code></li>
<li><code>execution::not_continuation</code></li>
<li><code>execution::not_outstanding_work</code></li>
<li><code>execution::allocator</code></li>
<li><code>execution::allocator(std::allocator&lt;void&gt;())</code></li>
</ul>
<h3 id="static_thread_pool-executor-types"><span class="header-section-number">1.6.3</span> <code>static_thread_pool</code> executor types</h3>
<p>All executor types accessible through <code>static_thread_pool::executor()</code>, and subsequent calls to the member function <code>require</code>, conform to the following specification.</p>
<pre><code>class C
{
  public:
    // types:

    typedef std::size_t shape_type;
    typedef std::size_t index_type;

    // construct / copy / destroy:

    C(const C&amp; other) noexcept;
    C(C&amp;&amp; other) noexcept;

    C&amp; operator=(const C&amp; other) noexcept;
    C&amp; operator=(C&amp;&amp; other) noexcept;

    // executor operations:

    see-below require(execution::never_blocking_t) const;
    see-below require(execution::possibly_blocking_t) const;
    see-below require(execution::always_blocking_t) const;
    see-below require(execution::continuation_t) const;
    see-below require(execution::not_continuation_t) const;
    see-below require(execution::outstanding_work_t) const;
    see-below require(execution::not_outstanding_work_t) const;
    see-below require(const execution::allocator_t&lt;void&gt;&amp; a) const;
    template&lt;class ProtoAllocator&gt;
    see-below require(const execution::allocator_t&lt;ProtoAllocator&gt;&amp; a) const;

    static constexpr bool query(execution::bulk_parallel_execution_t) const;
    static constexpr bool query(execution::thread_execution_mapping_t) const;
    bool query(execution::never_blocking_t) const;
    bool query(execution::possibly_blocking_t) const;
    bool query(execution::always_blocking_t) const;
    bool query(execution::continuation_t) const;
    bool query(execution::not_continuation_t) const;
    bool query(execution::outstanding_work_t) const;
    bool query(execution::not_outstanding_work_t) const;
    see-below query(execution::context_t) const noexcept;
    see-below query(execution::allocator_t&lt;void&gt;) const noexcept;
    template&lt;class ProtoAllocator&gt;
    see-below query(execution::allocator_t&lt;ProtoAllocator&gt;) const noexcept;

    bool running_in_this_thread() const noexcept;

    template&lt;class Function&gt;
      void execute(Function&amp;&amp; f) const;

    template&lt;class Function&gt;
      std::experimental::future&lt;result_of_t&lt;decay_t&lt;Function&gt;()&gt;&gt;
        twoway_execute(Function&amp;&amp; f) const

    template&lt;class Function, class Future&gt;
      std::experimental::future&lt;result_of_t&lt;decay_t&lt;Function&gt;(decay_t&lt;Future&gt;)&gt;&gt;
        then_execute(Function&amp;&amp; f, Future&amp;&amp; pred) const;

    template&lt;class Function, class SharedFactory&gt;
      void bulk_execute(Function&amp;&amp; f, size_t n, SharedFactory&amp;&amp; sf) const;

    template&lt;class Function, class ResultFactory, class SharedFactory&gt;
      std::experimental::future&lt;result_of_t&lt;decay_t&lt;ResultFactory&gt;()&gt;&gt;
        void bulk_twoway_execute(Function&amp;&amp; f, size_t n, ResultFactory&amp;&amp; rf, SharedFactory&amp;&amp; sf) const;
};

bool operator==(const C&amp; a, const C&amp; b) noexcept;
bool operator!=(const C&amp; a, const C&amp; b) noexcept;</code></pre>
<p><code>C</code> is a type satisfying the <code>OneWayExecutor</code>, <code>TwoWayExecutor</code>, <code>BulkOneWayExecutor</code>, and <code>BulkTwoWayExecutor</code> requirements. Objects of type <code>C</code> are associated with a <code>static_thread_pool</code>.</p>
<h4 id="constructors"><span class="header-section-number">1.6.3.1</span> Constructors</h4>
<pre><code>C(const C&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this == other</code>.</p>
<pre><code>C(C&amp;&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this</code> is equal to the prior value of <code>other</code>.</p>
<h4 id="assignment"><span class="header-section-number">1.6.3.2</span> Assignment</h4>
<pre><code>C&amp; operator=(const C&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this == other</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<pre><code>C&amp; operator=(C&amp;&amp; other) noexcept;</code></pre>
<p><em>Postconditions:</em> <code>*this</code> is equal to the prior value of <code>other</code>.</p>
<p><em>Returns:</em> <code>*this</code>.</p>
<h4 id="operations"><span class="header-section-number">1.6.3.3</span> Operations</h4>
<pre><code>see-below require(execution::never_blocking_t) const;
see-below require(execution::possibly_blocking_t) const;
see-below require(execution::always_blocking_t) const;
see-below require(execution::continuation_t) const;
see-below require(execution::not_continuation_t) const;
see-below require(execution::outstanding_work_t) const;
see-below require(execution::not_outstanding_work_t) const;</code></pre>
<p><em>Returns:</em> An executor object of an unspecified type conforming to these specifications, associated with the same thread pool as <code>*this</code>, and having the requested property established. When the requested property is part of a group that is defined as a mutually exclusive set, any other properties in the group are removed from the returned executor object. All other properties of the returned executor object are identical to those of <code>*this</code>.</p>
<pre><code>see-below require(const execution::allocator_t&lt;void&gt;&amp; a) const;</code></pre>
<p><em>Returns:</em> <code>require(execution::allocator(x))</code>, where <code>x</code> is an implementation-defined default allocator.</p>
<pre><code>template&lt;class ProtoAllocator&gt;
  see-below require(const execution::allocator_t&lt;ProtoAllocator&gt;&amp; a) const;</code></pre>
<p><em>Returns:</em> An executor object of an unspecified type conforming to these specifications, associated with the same thread pool as <code>*this</code>, with the <code>execution::allocator_t&lt;ProtoAllocator&gt;</code> property established such that allocation and deallocation associated with function submission will be performed using a copy of <code>a.alloc</code>. All other properties of the returned executor object are identical to those of <code>*this</code>.</p>
<pre><code>static constexpr bool query(execution::bulk_parallel_execution_t) const;
static constexpr bool query(execution::thread_execution_mapping_t) const;</code></pre>
<p><em>Returns:</em> <code>true</code>.</p>
<pre><code>bool query(execution::never_blocking_t) const;
bool query(execution::possibly_blocking_t) const;
bool query(execution::always_blocking_t) const;
bool query(execution::continuation_t) const;
bool query(execution::not_continuation_t) const;
bool query(execution::outstanding_work_t) const;
bool query(execution::not_outstanding_work_t) const;</code></pre>
<p><em>Returns:</em> <code>true</code> if <code>*this</code> has the property established such that it meets that properties requirements.</p>
<pre><code>static_thread_pool&amp; query(execution::context_t) const noexcept;</code></pre>
<p><em>Returns:</em> A reference to the associated <code>static_thread_pool</code> object.</p>
<pre><code>see-below query(execution::allocator_t&lt;void&gt;) const noexcept;
see-below query(execution::allocator_t&lt;ProtoAllocator&gt;) const noexcept;</code></pre>
<p><em>Returns:</em> The allocator object associated with the executor, with type and value as either previously established by the <code>execution::allocator_t&lt;ProtoAllocator&gt;</code> property or the implementation defined default allocator established by the <code>execution::allocator_t&lt;void&gt;</code> property.</p>
<pre><code>bool running_in_this_thread() const noexcept;</code></pre>
<p><em>Returns:</em> <code>true</code> if the current thread of execution is a thread that was created by or attached to the associated <code>static_thread_pool</code> object.</p>
<pre><code>template&lt;class Function&gt;
  void execute(Function&amp;&amp; f) const;</code></pre>
<p><em>Effects:</em> Submits the function <code>f</code> for execution on the <code>static_thread_pool</code> according to the <code>OneWayExecutor</code> requirements and the properties established for <code>*this</code>. If the submitted function <code>f</code> exits via an exception, the <code>static_thread_pool</code> calls <code>std::terminate()</code>.</p>
<pre><code>template&lt;class Function&gt;
  std::experimental::future&lt;result_of_t&lt;decay_t&lt;Function&gt;()&gt;&gt;
    twoway_execute(Function&amp;&amp; f) const</code></pre>
<p><em>Effects:</em> Submits the function <code>f</code> for execution on the <code>static_thread_pool</code> according to the <code>TwoWayExecutor</code> requirements and the properties established for <code>*this</code>.</p>
<p><em>Returns:</em> A future with behavior as specified by the <code>TwoWayExecutor</code> requirements.</p>
<pre><code>template&lt;class Function, class Future&gt;
  std::experimental::future&lt;result_of_t&lt;decay_t&lt;Function&gt;(decay_t&lt;Future&gt;)&gt;&gt;
    then_execute(Function&amp;&amp; f, Future&amp;&amp; pred) const</code></pre>
<p><em>Effects:</em> Submits the function <code>f</code> for execution on the <code>static_thread_pool</code> according to the <code>ThenExecutor</code> requirements and the properties established for <code>*this</code>.</p>
<p><em>Returns:</em> A future with behavior as specified by the <code>ThenExecutor</code> requirements.</p>
<pre><code>template&lt;class Function, class SharedFactory&gt;
  void bulk_execute(Function&amp;&amp; f, size_t n, SharedFactory&amp;&amp; sf) const;</code></pre>
<p><em>Effects:</em> Submits the function <code>f</code> for bulk execution on the <code>static_thread_pool</code> according to the <code>BulkOneWayExecutor</code> requirements and the properties established for <code>*this</code>. If the submitted function <code>f</code> exits via an exception, the <code>static_thread_pool</code> calls <code>std::terminate()</code>.</p>
<pre><code>template&lt;class Function, class ResultFactory, class SharedFactory&gt;
  std::experimental::future&lt;result_of_t&lt;decay_t&lt;ResultFactory&gt;()&gt;&gt;
    void bulk_twoway_execute(Function&amp;&amp; f, size_t n, ResultFactory&amp;&amp; rf, SharedFactory&amp;&amp; sf) const;</code></pre>
<p><em>Effects:</em> Submits the function <code>f</code> for bulk execution on the <code>static_thread_pool</code> according to the <code>BulkTwoWayExecutor</code> requirements and the properties established for <code>*this</code>.</p>
<p><em>Returns:</em> A future with behavior as specified by the <code>BulkTwoWayExecutor</code> requirements.</p>
<pre><code>template&lt;class Function, class Future, class ResultFactory, class SharedFactory&gt;
  std::experimental::future&lt;result_of_t&lt;decay_t&lt;ResultFactory&gt;()&gt;&gt;
    void bulk_then_execute(Function&amp;&amp; f, size_t n, Future&amp;&amp; pred, ResultFactory&amp;&amp; rf, SharedFactory&amp;&amp; sf) const;</code></pre>
<p><em>Effects:</em> Submits the function <code>f</code> for bulk execution on the <code>static_thread_pool</code> according to the <code>BulkThenExecutor</code> requirements and the properties established for <code>*this</code>.</p>
<p><em>Returns:</em> A future with behavior as specified by the <code>BulkThenExecutor</code> requirements.</p>
<h4 id="comparisons"><span class="header-section-number">1.6.3.4</span> Comparisons</h4>
<pre><code>bool operator==(const C&amp; a, const C&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>true</code> if <code>&amp;a.query(execution::context) == &amp;b.query(execution::context)</code> and <code>a</code> and <code>b</code> have identical properties, otherwise <code>false</code>.</p>
<pre><code>bool operator!=(const C&amp; a, const C&amp; b) noexcept;</code></pre>
<p><em>Returns:</em> <code>!(a == b)</code>.</p>
